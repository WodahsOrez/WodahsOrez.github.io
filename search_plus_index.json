{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介 记录一部分整理的笔记。 "},"basic/class.html":{"url":"basic/class.html","title":"类，抽象类，接口，多态","keywords":"","body":"类，抽象类，接口，多态 一般类 类的声明与使用 修饰符 class 类名 { // 构造方法 修饰符 类名(参数列表) {} // 成员变量 修饰符 变量类型 变量名; // 成员方法 修饰符 返回类型 方法名(参数列表) {} } 类名 实例名 = new 类名(参数列表); // 创建对象实例，通过参数列表选择不同的构造方法进行初始化 实例名.变量名; // 调用成员变量 实例名.方法名(); // 调用成员方法 若不写构造方法则默认有个隐式的无参构造方法，若自定义了一个有参构造方法，则需自己定义无参构造方法。 继承 子类会继承父类可继承（看权限控制修饰符）的成员变量和成员方法。 class 子类 extends 父类 {} 单继承：extends后只能跟一个类，即一个子类只能继承一个父类。 多重继承：A继承B，B继承C，A和C是在一个继承体系中，即多重继承。 super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用，可以用this.成员变量名来避免同名。 覆盖override 子类中出现一个和父类相同的方法（参数列表，方法名）时，称子类的这个方法覆盖了父类的方法。 子类覆盖父类时，子类权限必须要大于等于父类的权限。 返回类型必须和被覆盖方法的返回类型相同或者是返回类型的子类型。 final方法不能被覆盖，static方法只能被static方法覆盖。 覆盖方法不能抛出新的检查异常，或者是抛出比被覆盖方法声明的检查异常更广泛的检查异常。 构造方法 子类不会继承父类的构造方法 如果子类没有构造方法，默认会写一个无参构造方法其内部隐式调用父类的无参构造方法。 子类的构造方法内部默认第一句是隐式的super()，除非显示的定义了super(参数)来调用父类的构造函数。 子类要使用父类有参的构造器，使用super（参数）形式，且super只能是子类构造方法内部的第一条语句。除非是第一句是this()，调用了本类的其他构造方法，且该方法第一句是super。 如果父类没有不带参数的构造方法，且子类的构造方法中又没显示的调用父类的有参构造方法，则Java编译器将报告错误。 抽象类 public abstract class Demo { public Demo() { name = \"demo\"; } private String name; public abstract String showName(); } 抽象类不可以被实例化。继承抽象类的子类必须覆盖了所有的抽象方法后，该子类才可以实例化。 抽象方法：被abstract修饰，没有具体实现，如public abstract void fn(int a);。 抽象类中有构造函数。抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象关键字不可以和那些关键字共存? private 不行 (私有后不能被子类继承) static 不行 (没有具体内容不能被创建) final 不行 (不能被覆盖) 接口 接口即是只有抽象方法和全局静态常量的特殊抽象类。 访问修饰符 interface 接口名称 [extends 其他的接口名] { // 声明变量，不写修饰符也是默认为全局静态常量 [public static final] String name; // 抽象方法，不写也是默认为public abstract [public abstract] void show(); } // 接口可以继承多个接口，如 public 接口A extends 接口B,接口C {} // 一个类可以继承一个类并实现多个接口 public class 子类 extends 父类 implements 接口A，接口B 接口不可以实例化。实现了接口的子类，覆盖了接口中所有的抽象方法后，该子类才可以实例化。否则，这个子类就是一个抽象类。 多态 简单说就是一个对象对应着不同类型。体现就是父类或者接口的引用指向其子类的对象。 多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容。 多态的弊端：前期定义的内容不能使用(调用)后期子类的特有内容。 多态的前提：1，必须有关系，继承，实现。2，要有覆盖方法。 Animal a = new Cat(); 向上转型：自动类型提升，Cat对象提升为Animal类型。但是不能使用子类的特有方法。 Cat c = (Cat)a; 向下转型：为了使用子类中的特有方法。 注意：对于转型，自始自终都是子类对象在做着类型的变化。 instanceof：用于判断对象的具体类型。只能用于引用数据类型判断。对象 instanceof 类名判断对象是否属于该类型，结果为布尔值。 多态时创建对象的执行顺序 如果静态代码块内引用了静态变量，则静态变量必须写在静态代码块之前，否则编译失败。非静态变量和构造代码块也一样。 1、父类静态变量和静态代码块（先声明的先执行）； 2、子类静态变量和静态代码块（先声明的先执行）； 3、父类的变量和代码块（先声明的先执行）； 4、父类的构造函数； 5、子类的变量和代码块（先声明的先执行）； 6、子类的构造函数。 public class Test { public static int a = 0; static {// Step 1 a = 10; System.out.println(\"静态代码块在执行a=\" + a); } {// Step 4 a = 8; System.out.println(\"非静态代码块（构造代码块）在执行a=\" + a); } public Test() { this(\"调用带参构造方法1，a=\" + a); // Step 2 System.out.println(\"无参构造方法在执行a=\" + a);// Step 7 } public Test(String n) { this(n, \"调用带参构造方法2，a=\" + a); // Step 3 System.out.println(\"带参构造方法1在执行a=\" + a); // Step 6 } public Test(String s1, String s2) { System.out.println(s1 + \"；\" + s2);// Step 5 } public static void main(String[] args) { Test t = null;// JVM加载Test类，静态代码块执行 System.out.println(\"下面new一个Test实例：\"); t = new Test(); } } 执行结果： 静态代码块在执行a=10 下面new一个Test实例： 非静态代码块（构造代码块）在执行a=8 调用带参构造方法1，a=10；调用带参构造方法2，a=10 带参构造方法1在执行a=8 无参构造方法在执行a=8 "},"basic/controlStatement.html":{"url":"basic/controlStatement.html","title":"流程控制语句","keywords":"","body":"流程控制语句 选择判断语句 if…else语句 if (布尔表达式) { 执行语句; } else if (布尔表达式) { 执行语句; …… } else { 执行语句; } switch语句 switch(expression){ case value1 : //语句 break; //可选 case value2 : //语句 break; //可选 …… default : //可选 //语句 break; //可选 } expression支持类型为int，String和枚举.(byte,short,char是通过自动转成int实现的 ) case 后的值必须与expression的数据类型相同，而且只能是常量或者字面常量。 当expression的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。 如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。 default 在没有 case 语句的值和变量值相等的时候执行。推荐写在末尾 循环结构 while语句 while( 布尔表达式 ) { //循环内容 } 当满足布尔表达式时，进入循环，执行语句，再次判断，直到不满足布尔表达式，退出循环。 do while语句 do { //代码语句 }while(布尔表达式); 先执行循环语句，然后判断布尔表达式，满足后就再次执行，反之，退出循环。 for循环语句 for(初始化; 布尔表达式; 更新) { //代码语句 } 执行顺序：初始化→布尔表达式→代码语句→更新→布尔表达式…… 初始化可以声明一个或多个循环控制变量，也可以为空 for each语句 for(声明语句 : 表达式){ //代码句子 } 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与当前循环到的数组元素的值相等。 表达式：要访问的数组名，或者是返回值为数组的方法。 continue 关键字 continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 break 关键字 break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 嵌套循环结构中，break 跳出最里层的循环结构，并且继续执行外层循环接下来的语句。 break和continue带label的用法 标签（label）：用标识符和：给代码块或是条件控制语句命名。 a:{ b: while(true) { c: for(;;) { d: if (true) { break c; } } continue b; } } break label：跳出label命名的代码块，继续执行外部的代码。 continue label：跳过label命名的循环代码块的本次循环，进入下一次循环。 注意：以上两种语句的label命名的代码块只能是包含该语句的代码块。 a: do { b: switch(1){ default: break c; //不被c包含，无法跳出 } continue c; //不被c包含，无法跳过 }while(true); c: for(;;){} "},"basic/datatype.html":{"url":"basic/datatype.html","title":"数据类型和运算符","keywords":"","body":"数据类型和运算符 标识符 由大小写字母，数字，_$组成的自定义名称，其中不能以数字开头，且不能和关键词重名。 正则表达式：^[A-Za-z_$][A-Za-z0-9_$]*$ 基础数据类型 类型 范围 备注 byte 8位(-2^7^~ 2^7^-1) short 16位(-2^15^~2^15^-1) int 32位(-2^31^~2^31^-1) long 64位(-2^63^~2^63^-1) 末尾加L float 32位(1符号8指数23尾数) 末尾加f double 64位(1符号11指数52尾数) char 16位(0~2^16^-1) boolean true/false 运算符 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + + - ！〜 从右到左 乘性 * /％ 左到右 加性 + - 左到右 移位 >> >>> 左到右 关系 >>= 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 \\ 左到右 逻辑与 && 左到右 逻辑或 \\ \\ 左到右 条件 ？： 从右到左 赋值 = + = - = * = / =％= >> = = 从右到左 逗号 ， 左到右 = > 只支持数值类型数据比较 /两个整型相除,结果强制转换为整形，正负跟随被除数。 3+\"2\"结果为\"32\"(任何和字符串相加为连接) ++在前和在后的差别: j = i++ ,j为i j = ++i,j为i+1 取余运算符 对于整数： a%b=a-(a/b)*b 操作数中有浮点数： a%b=a-(b*q),这里q=int(a/b) 例如：5%-2结果为1(5-(-2*（5/-2）)) 逻辑运算符 &和&&的差别是当&&左边判定为假时,会跳过右边判断语句,直接输出假.同理||和|. 位运算 位运算的操作数是整形数，包括int、short、long、byte和char。位运算的结果只能是int、long。 左移位： 右移位：>>，有符号的移位操作 右移操作是将运算数的二进制码整体右移指定位数，右移之后的空位用符号位补充，如果是正数用0补充，负数用1补充。 按位右移补零操作符:>>>,左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 如果操作数是char、byte、short，位运算其值自动晋升为int。 例题：对两个整数变量的值进行互换 (不需要第三方变量) ​ a = a ^ b; //a = 3 ^ 5; ​ b = a ^ b; //b = (3^5)^5; b = 3; ​ a = a ^ b; //a = (3^5)^3; a = 5; ​ （a&1） = 0 偶数 ​ （a&1） = 1 奇数 三元运算符 (条件表达式)?表达式1:表达式2 ()不是必须的 当条件表达式为true时,执行表达式1,反之,执行表达式2. 数据类型自动转换及溢出问题 规则1：低字节向高字节自动转换 byte->short->int->long->float->double 不涉及运算，例如赋值时使用。 char不可与byte，short自动转换，只能往int转，原因是char范围为正，没负，转换和被转换都会溢出 规则2：运算时，统一向涉及运算的最高字节的类型转换。byte,short,char一律转换成int。 (即同类型相加也会强制转换成int，导致赋值时报错。如： byte a = 1; byte b = 2; a = a + b;报错 a+=b不报) short s = 3; s+=4; s = s + 4; 差别是+=是赋值运算会自动判断并强制转换类型,赋值运算会直接判断后面输入数字是否溢出来报错 s = s + 4为short和int相加，结果自动转成int，int不能赋给byte所以报错。通过强制类型转换解决：s = (short)(s+4); 规则3：常量不溢出可以自动转换，溢出则不行。涉及变量，有溢出可能性就不行。 注释 注释不会被编译到class文件内 // 单行注释 /* 多行注释 */ /** *文档注释,可以使用javadoc命令导出API帮助文档 */ 标签 描述 示例 @author 标识一个类的作者 @author name @deprecated 指名一个过期的类或成员 @deprecated description @param 说明一个方法的参数 @param parameter-name explanation @return 说明返回值类型 @return explanation @see 指定一个到另一个主题的链接 @see anchor @serial 说明一个序列化属性 @serial description @serialData 说明通过writeObject( ) 和 writeExternal( )方法写的数据 @serialData description @serialField 说明一个ObjectStreamField组件 @serialField name type description @since 标记当引入一个特定的变化时 @since release @exception 标志一个类抛出的异常 @exception exception-name explanation @throws 和 @exception标签一样. The @throws tag has the same meaning as the @exception tag. @version 指定类的版本 @version 1.2 {@docRoot} 指明当前文档根目录的路径 Directory Path {@inheritDoc} 从直接父类继承的注释 Inherits a comment from the immediate surperclass. {@link} 插入一个到另一个主题的链接 {@link name text} {@linkplain} 插入一个到另一个主题的链接，但是该链接显示纯文本字体 Inserts an in-line link to another topic. {@value} 显示常量的值，该常量必须是static属性。 Displays the value of a constant, which must be a static field. "},"basic/function.html":{"url":"basic/function.html","title":"方法和数组","keywords":"","body":"方法和数组 方法 方法的定义 修饰符 返回值类型 方法名(参数类型1 参数名1，参数类型2 参数名2){ ... 方法体 ... return 返回值; } 返回值类型：如果没有返回值则写void，return后面可以不加返回值，也可是直接不写return。 参数：可以是一个或多个，也可没有。 方法的调用 方法名（实参1，实参2）; int result = sum(2,3); // 可以这样把方法有的返回值赋值给变量 方法的调用时填写的参数，必须与定义时的参数类型和顺序和个数相匹配。 方法的重载 同一个类中，相同方法名，不同参数列表（参数类型，个数，顺序不同）的方法叫做重载方法。 public class A{ public int fn(int a,double b){...} public void fn(int a,double b){...} // 返回类型不同不算重载，看做是重复定义。 public int fn(double a,int b){...} // 只是顺序不同也算重载 public int fn(double a,long b,char c){...} // 个数，类型都不同的重载 } 可变参数 适用于参数个数不确定，类型确定的情况，java把可变参数当做数组处理。 格式：变量类型... 变量名 public int fn(int x, int... args) { int sum = 0; for (int i = 0; i 可变参数的特点： 只能出现在参数列表的末尾，一个方法只能有一个可变参数。 ...位于变量类型和变量名之间，前后有无空格都可以。 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。 语义逻辑： 因为参数个数不定，所以当其后边还有相同类型参数时，java无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数必须位于最后一项。 当可变参数个数多余一个时，必将有一个不是最后一项，所以只支持有一个可变参数。 数组 // 声明数组 变量类型[] 数组名； // 常用 变量类型 数组名[]； // 也符合语法，但不常用。 // 创建数组 变量类型[] 数组名 = new 变量类型[数组大小]； // 创建空数组 变量类型[] 数组名 = new 变量类型[]{值1，值2，……}； // 根据值创建数组 变量类型[] 数组名 = {值1，值2，……}； // 根据值创建数组 数组名.length // 获得数组的大小 数组名[index] // 获取数组内对应索引的值，index为0,1，2…… // 多维数组，以二维为例，多维类推 变量类型[][] 数组名 = new 变量类型[外维大小][內维大小]; // 即每个外维元素都是一个內维大小的数组，內维大小给定就每个外维元素都一样大，也可以不写。 // 可以通过给每个外维元素单独赋值来分配不同的內维大小，如： int[][] arr = new int[2][]; arr[0] = {2,3,4}; arr[1] = {7,0,10,23,5}; "},"basic/innerClass.html":{"url":"basic/innerClass.html","title":"内部类","keywords":"","body":"内部类 成员内部类 实例内部类 创建实力内部类的实例时.外部类的实例必须已经存在. 实例内部类的实例自动持有外部类的实例的引用.可以访问外部类的所有成员变量和方法.多重嵌套中,内部类可以访问所有外部类的成员. 在外部类中不能直接访问内部类的成员,必须通过内部类的实例去访问. 实例内部类不能定义静态成员. 如果实力内部类B与外部类A包含同名的成员(如变量v),那么在类B中,this.v表示类B的成员, A.this.v表示类A的实例成员,A.v表示类A的静态成员 静态内部类 静态内部类的实例不会自动持有外部类的特定实例的引用.创建外内部类实例时可以不必创建外部类实例.如:new A.B(); 静态内部类可以直接访问外部类的静态成员,访问外部类的实例成员需通过外部类的实例去访问 静态内部类中可以定义静态成员和实例成员 可以通过A.B.v2直接访问静态内部类B的静态成员变量v2,不能通过A.B.v1访问静态内部类的实例变量v1. 局部内部类(方法内部类) 局部内部类及其内部类不能被public,private,protected和static修饰 局部内部类只能在当前方法中使用. 局部内部类不能包含静态成员 局部内部类可以访问外部类的所有成员.可以访问所在方法的final类型变量和参数,不能访问非final修饰的变量和参数(原因:局部变量的生命周期与局部内部类的对象的生命周期的不一致性!解决办法:通过将final局部变量\"复制\"一份,复制品直接作为局部内部中的数据成员,通过构造方法注入) 匿名类 匿名类本身没有构造方法，但会调用父类的构造方法。如new A（v）{}，若参数v是局部变量，则v必须为final类型 匿名类可以通过写构造代码块来实现自定义的初始化。 匿名类除了定义在方法内外还可以用在成员变量的显示初始化上。 匿名类除了可以继承类还可以实现接口 匿名类和局部内部类一样可以访问外部类的所有成员和方法内的final变量和参数。 内部类的特性 不允许内部类与外部类重名 内部类的继承 public class Sample extends Outer.Inner{ public Sample(Outer o){ o.super; } } 因为构建一个内部类的实例需要外部类的实例,所以,Sample继承Inner类时需在构造时传入一个Outer实例的引用,o.super()指的是执行o的inner内部类的构造方法. 子父类的内部类同名 和子父类的同名成员变量一样,子父类的同名内部类都是独立的,互相不影响.java编译器不会检查子类中的Inner类是否缩小了父类中的Inner类的访问权限. 内部接口 一个类中可以定义内部接口（静态非静态都可以）。 接口的静态内部类 接口中可以定义静态内部类，实现了接口的类对内部类可见（可直接调用） 非实现类必须通过接口.内部类来调用。 命名规则 内部类的class文件命名是：包名.外部类名$内部类名 匿名类的class文件命名是：包名.外部类名$由1开始的正整数-按照类装载顺序依次排列 局部内部类class文件命名是：包名.外部类名$由1开始的正整数后跟局部类名-其中数字部分是局部类在外部类上下文出现的先后顺序 "},"basic/modifier.html":{"url":"basic/modifier.html","title":"修饰符","keywords":"","body":"修饰符 修饰对象 可用修饰符（及书写顺序） 类的修饰符 public、abstract、final 构造方法 public、protected、private 方法 public、protected、private、abstract、static、final、synchronized、native 成员变量 public、protected、private、static、final、transient、volatile 局部变量 final 访问控制修饰符 访问修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N（说明） N default(friendly/包访问权限) Y Y Y N N private Y N N N N 访问控制修饰符控制的是访问被修饰者的代码所写的位置，即影响其可见范围。 访问继承的方法或成员时，其可见性范围取决于被继承的方法或成员 对于protected，不同包的子类中，只能由子类实例或子类的子类实例对象访问，不能由父类或父类的其他分支的子孙类实例对象访问。但是可以在非静态方法内由super来访问。 package p1; import P2.Son2; public class Father1 { // 可见范围为同包P1或子类中。 protected void f() {} // Father继承自Object的clone（）的可见范围为同包java.lang和Object的子类。 public static void main(String[] args) { Son2 son = new Son2(); son2.clone(); // 来源Object,不同包子类，由Father的子类实例访问，可见。 } } package p1; import P2.Son2; public class Son1 extends Father1 { public static void main(String[] args) { Son2 son = new Son2(); //son.clone(); // 来源父类，同包子类不可见。 } } package P2; import p1.Father1; public class Son2 extends Father1 { public void f() { super.f(); // 不同包子类，super访问可见。 } public static void main(String[] args) { Father1 father1 = new Father1(); //father1.f(); // 不同包子类，父类实例调用不可见。 } } package p1; import P2.Son2; public class Test { public static void main(String[] args) { Son1 son1 = new Son1(); son1.f(); // 来源Father,同包可见。 //son1.clone(); // 来源Object,不同包子类，父类其他分支子类调用不可见。 Son2 son2 = new Son2(); son2.f(); // 来源Father,同包可见。 //son2.clone(); // Compile Error，因为访问的是继承的clone(),可见性等同Object的clone()，因为不同包且非子类不可见 // 同包非子类，不可见。 } } 其他修饰符 static 静态变量：对于同一对象类型的不同对象实例，共用一个静态变量。 静态方法：内部不能使用非静态变量，不需要对象实例就能使用。 两者可以直接用类名访问，如classname.variablename 和 classname.methodname final 修饰变量：即常量，不能被重新赋值，所以必须在声明时定义初始值。 修饰方法：可以被子类继承，但不能被override。 修饰类：不能被继承。 abstract 抽象方法：没有实现内容的方法，不能被final和static修饰。子类继承后必须实现该方法，除非子类也是抽象类。拥有抽象方法的类必须声明为抽象类。 抽象类：抽象类不能实例化对象，不能被final修饰，可以同时包含抽象方法和非抽象方法，或只有其一。 "},"advanced/annotation.html":{"url":"advanced/annotation.html","title":"注解(annotation)","keywords":"","body":"注解(annotation) 内建注解 // java.lang @Override 在重写的子类方法前加上即可 @Deprecated 在已过时的程序元素前标识 @SuppressWarnings 关闭编译器对该程序元素和其所有子元素的警告 // 例: @SuppressWarnings(value =\"unchecked\"); @SuppressWarnings(value ={\"unchecked\",\"fallthrough\"});其中value =可以省略 value的常用参数有: deprecation:使用了过时程序元素 unchecked:执行了未检查的转换 unused:有程序元素未被使用 fallthrough:switch程序块直接通往下一种情况而没有break path:在类路径,源文件路径等中有不存在的路径 serial:在可序列化的类上缺少serialVersionUID定义 finally:任何finally子句不能正常完成 all:所有情况 自定义注解 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型。可以通过default来声明参数的默认值。 定义注解格式： public @interface 注解名 { 成员类型 成员名() [default 默认值]; } 成员的可支持数据类型： 所有基本数据类型（int,float,boolean,byte,double,char,long,short)及其封装类 String类型 Class类型 enum类型 Annotation类型 以上所有类型的数组(赋值时用{}) Annotation类型里面的参数该怎么设定: 只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；　 　 如果只有一个参数成员,必须把参数名称设为\"value\",后加小括号.只对value成员赋值时可以省略成员名和赋值号=,同时对多个成员赋值时,必须使用赋值号. 注解成员的默认值： 总结：成员必须有值(默认指定，使用指定)，用负数或空字符串表示成员缺失。　　 注解成员必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解成员的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个成员的存在或缺失的状态，因为每个注解的声明中，所有成员都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，以此表示某个成员不存在，在定义注解时，这已经成为一个习惯用法。 元注解 java.lang.annotation 元注解,是给注解的注解. @Target　　 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 取值(ElementType)有： CONSTRUCTOR:用于描述构造器 FIELD:用于描述域,类成员变量或常量 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） 取值（RetentionPoicy）有： SOURCE:在源文件中有效（即源文件保留）,字节码中不会有 CLASS:在class文件中有效（即class保留）,JVM中不会有 RUNTIME:在运行时有效（即运行时保留）,可以通过反射机制读取注解信息 @Inherited 作用：@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。 @Documented：此为标识符，标识该类是否出现在Javadoc中 附录：注解的自定义和使用 "},"advanced/collection.html":{"url":"advanced/collection.html","title":"集合框架和泛型","keywords":"","body":"集合框架和泛型 集合的特点有：可以存储对象不能存储基本数据类型 ，集合的长度是可变的。 collection接口 特点：不唯一，无序号 方法： 1、增加： boolean add(E e)向末尾加 boolean addAll(Collection c) 2、删除： void clear() 清空集合 boolean remove(Object o)删第一个 boolean removeAll(Collection c)删除c中包含的 boolean retainAll(Colletion c)仅保留c中的，其他都删除，交集 3、获取： int size()元素个数 Iterator iterator()返回迭代器对象 4、查找： boolean contains(Object o) contains方法是通过equals判断的。 boolean containsAll(Collection c) boolean isEmpty() 5、转换： Object[] toArray()转换为Object数组 T[] toArray(T[] a) 把collection转换成T[]数组传出 List接口 特点：不唯一，有序号 ArrayList类 特点：和数组一样采用同样的存储方式，在内存中分配连续的空间。遍历，随机访问快，删改慢。 方法： 增加：void add(int index,E e)插入，后面的后移 删除：E remove(int index) 获取：E get(int index) 从0开始 int indexOf(Object o)返回第一个索引，没有返回-1 修改：void set(int index, E element ) LinkedList类 特点：采用链表存储方式。删改快，查找慢。 方法： 增加：void addFirst(E e) void addLast(E e) 获取：E getFirst() E getLast() 删除：E removeFirst() remove() E removeLast() Vector类 方法：Enumeration elements() 返回一个 set接口 特点：唯一，无序号,也无顺序。 HashSet类 特点：非线程安全，允许元素为null。对象需重写hashCode和equals，当equals相等时必须hashCode也相等，反之则不必然。在集合中，比如HashSet中，要求放入的对象不能重复，怎么判定呢？首先会调用hashcode，如果hashcode相等，则继续调用equals，如果equals也相等，则认为重复。 方法：1、增加：boolean add(E e) 未包含则加 不存在get方法，无法用普通for循环，只能用增强for循环遍历。 TreeSet类 特点：可以对元素进行排序，不同步的。判断唯一性的方式，是根据compareTo方法的返回值，为0即相同元素，不共存。 比较方法有二种： 1、类实现comparable 2、比较器comparator,并通过构造函数加载. 自然排序:方法一,定制排序:方法二. Iterator接口 特点：凡是Collection派生的都有iterator()方法并返回Iterator对象 方法： boolean hasNext()是否有下一个元素 E next()返回下一个元素，并下移一位 void remove()删除最后返回的一个元素 Map接口 特点：key-value映射存储，key不要求有序，不允许重复，value不要求有序，允许重复 方法： 1、增加：V put(K key,V value)若key有旧value则被替代 2、删除：V remove(Object key)返回value，没有则返回null void clear() 3、获取：V get(Object key) Set(K) keySet() Collection(V) values() 4、查找：boolean containsKey(Object key) boolean containsValue(Objet value) boolean isEmpty() Set> entrySet() 获得Map内部的Entry接口对象的Set集合 内部接口：Interface Map.Entry K getKey() V getValue() V setValue(V value) default V replace(K key, V value) 当K不存在时,返回Null boolean replace(K key, V oldValue, V newValue) 当K和V匹配时,才会执行替换 HashMap类 特点：内部结构是哈希表，不同步，允许null作为键，可以作为值。 查询指定元素效率高,键自然排序 Hashtable类 特点：内部结构是哈希表，同步，不允许null作为键，可以作为值。 Properties类 特点：键和值都为字符串类型，集合中的数据可以在流中传输。 方法： Set StringPropertyNames() 返回一个key值的set集合 String getProperty(String key) 返回指定键所对应的属性 String getProperty(String key， String default) 返回指定键所对应的属性,如果没有则返回default void list(PrintStream out) 将属性列表输出到指定的输出流 void store(OutputStream out,String comments) 把properties写入到流中,comments文件属性信息可以为空 void store(Writer writer,String comments) void load(InputStream inStream) 把流的数据写入到properties void load(Reader reader) TreeMap类 特点：内部结构是二叉树，不同步，可以对键进行排序。 comparable\\接口 方法： int compareTo(T o) 返回一个负数，0，正数来表示小于，等于，大于 comparator\\接口 方法： int compare(T o1,T o2) 根据第一个参数小于，等于，大于第二个参数返回负数，零，正数。 boolean equals(Object obj) 不用重写的原因是实现类都会继承Object的equals()方法 collections类 方法： static void> sort(List list) // 对实现了comparable接口的元素的list集合进行排序 static Comparator reverseOrder() // 返回一个逆转了实现comparable的对象的自然顺序的比较器 static Comparator reverseOrder(Comparator cmp) // 返回一个指定比较器的逆转后的比较器 static int binarySearch(List> list, T key) // 查找返回索引 static void fill(List list, T obj) // 用T替换list中的所有元素 static Enumeration enumeration(Collection c) // 把Collection转换成枚举 static > T max(Collection coll) // 返回最大值(最小值换成min) static T max(Collection coll, Comparator comp) // 通过比较器返回最大值(最小值换成min) static boolean replaceAll(List list, T oldVal, T newVal) // 使用另一个值替换列表中所有的指定值 其他 对于集合内存储null List 集合可以存储null，添加几个，存储几个； Set集合也可以存储null，但只能存储一个，即使添加多个也只能存储一个； HashMap可以存储null键值对，键和值都可以是null，但如果添加的键值对的键相同，则后面添加的键值对会覆盖前面的键值对，即之后存储后添加的键值对； Hashtable不能碰null，不管是值还是键，一见null就报空指针。 线程安全的同步的类： vector：就比arraylist多了个同步化机制（线程安全） statck：堆栈类，先进后出 hashtable：就比hashmap多了个线程安全 enumeration：枚举，相当于迭代器 静态导入 在 import 后加 static 可以导入类中的静态成员. import static 包名.类名.静态成员变量; import static 包名.类名.静态成员函数; "},"advanced/generics.html":{"url":"advanced/generics.html","title":"泛型(generics)","keywords":"","body":"泛型(generics) 泛型就是把类型参数化，<>即存放类型参数的位置，T，E，K，V即变量名.泛型的实例化即类似于变量的赋值，把具体的类型名填入<>中，即相应位置处的T变成这种类型。 泛型的设计目的是用T代替Object来传入未知类型对象，而?是为了能使泛型达到协变和逆变这种关系而存在的，即使泛型类型间建立关系. 泛型类 定义泛型类的语法： 访问修饰符class className TypeList表示类型变量列表，每个类型变量之间以逗号隔开。 例如：Interface Collection 或者 Interface Map 其中E,K,V为类型变量(参数)，和变量一样，名称可以自定义。 创建泛型类的语法： className =new className(argList); argList表示实际传递的类型参数列表，同样以逗号隔开。 例如：ArrayList =new ArrayList(); 泛型的声明必写,后面可以只写<>,因为有类型推断机制。 即：ArrayList =new ArrayList<>() 泛型方法 定义泛型方法的语法： 访问修饰符 返回值 方法名 (类型参数列表) 类型参数放在访问修饰符的后面，返回类型的前面.泛型类的静态方法如果想用泛型，必须重新定义成泛型方法。 例如：public void showName (T t){ } 泛型方法的使用: 例如:对象.showNam(name) 写在方法名前面,这样编译器可以判断name是否为String 有足够条件判断时,泛型方法前的<>可以省略. 泛型方法使用时如果加<>前面必须要有对象.或者类名.或this.super.无论是否在同一个类里 泛型参数 泛型参数 泛型直接放在方法的参数列表里,(静态方法必须定义成泛型方法) 例如: public void show(List list) 任意情况都可用 public void show(List list) 必须在泛型类里使用 public static void show(List list) 可以不定义成泛型方法 public static void show(List list) 必须定义成泛型方法,不管是否在泛型类里 泛型的限定： 上限：extends表示继承或实现或两者皆有，后面可以有一个类和多个接口，类必须在前。 语法： 下限： 没有T super XXX的写法,只能用? super XXX 通配符类型： 例如：public static void printBuddies(Pair p) 如何理解 Java 中的 > 泛型的擦除，不用泛型时，用的是原始类型，无限定类型用Object，详见P534. 方法参数重写 public static void getData(List data) public static void getData(List data) public static void getData(List data) 这三种方法是同一个方法,即参数视为一致,无法看做重载. 泛型T和?的差别 T只能在泛型类或泛型方法中使用,而和其上下限可以在任何情况下使用,即普通方法和类的任意位置使用. 这种情况下的List list 中,由于list存在不确定性,不能用list.add()添加任意元素.只能用list =new ArrayList();给其赋值. T是用在定义泛型的,而?是在定以后的泛型使用时对其T参数进行范围限制的存在.即先有T后有? T extends 是对T进行必要的属性解释, 而T super没有意义所以不存在. 泛型无法向上转型 Info i1 = new Info() ; // 泛型类型为String Info i2 = null ; i2 = i1 ; //这句会出错 incompatible types 通配符 即等效于用于拓展用的情况,使其能兼容更多类型 List是List的父类 协变 List是List的父类 逆变 通配符上限写入的情况 public class Wildcard { public static void main(String[] args) { List list = new ArrayList(); getData(list); } public static void getData(List list){ System.out.println(\"data:\" + list.get(0)); list.add(12); 不能写入 list.add(new Object()); 不能写入 } } 因为List可能是List或List,所以为避免出现不能写入所以一律不能写入任意对象,在里适用这个规则 通配符下限写入的情况 public class Wildcard { public static void main(String[] args) { List list = new ArrayList(); getData(list); } public static void getData(List list){ System.out.println(\"data:\" + list.get(0)); list.add(12); 可以写入 list.add(new Object()); 可以写入 } 由于有下限,所以下限及其子类都能写入而不用担心因为不确定性而产生错误. 通配符讲解很详细. “捕获助手” 方法 public void rebox(Box box) { reboxHelper(box); } private void reboxHelper(Box box) { box.put(box.get()); } 解析:Box返回的是一个Object,而Box返回的是V 存取原则和PECS法则 总结 ? extends 和 the ? super 通配符的特征，我们可以得出以下结论： 如果你想从一个数据类型里获取数据，使用 ? extends 通配符 如果你想把对象写入一个数据结构里，使用 ? super 通配符 如果你既想存，又想取，那就别用通配符。 PECS是指”Producer Extends, Consumer Super” 参考： 协变逆变 java泛型简明教程 泛型代码 通配符 "},"advanced/IO.html":{"url":"advanced/IO.html","title":"输入输出流","keywords":"","body":"输入输出流 字节流 特点：最小操作单位为字节(byte) InputStream抽象类 方法： int read()从输入流读取下一个字节，返回0~255的值 int read(byte[] b)从输入流读取一堆字节，存储在b中,返回值为数组的长度。 int read(byte[] b, int off, int len)off为开始存储字节的数组下标，len为读到的字节个数。 void close()关闭流 int available() 可以从输入流中读取的剩余字节长度。while(dis.available()>0) BufferedInputStream类 构造方法： BufferedInputStream(InputStream in) FileInputStream类 构造方法：FileInputStream(File file) FileInputStream(String pathname) SequenceInputStream类 特点：按顺序合并若干个流。 构造函数： SequenceInputStream( Enumeration e) SequenceInputStream(InputStream s1,InputSteam s2) ObjectInputStream类 构造方法：ObjectInputStream(InputStream in) PipedInputStream类 特点：配合PipedOutputStream使用，避免两者在同一线程，会死锁。 构造方法：PipedInputStream(PipedOutputStream src) 方法： void connect(PipedOutputStream src) 联系两者 DataInputStream类 特点：写入基本数据类型 构造方法： DataInputStream(InputStream in) 方法：String readUTF() 修改版UTF-8格式读取 OutputStream抽象类 方法： void write(int c) void write(byte[] buf) void write(byte[] b, int of, int len) void close() void flush()强制把缓冲区的数据写到输出流中,写入得时候只是把数据写入到当前流类的缓冲区内,而没有写入到流所指向的文件或者其他流中,所以需要flush以写入到目标源 FileOutputStream类 构造方法： FileOutputStream(File file) FileOutputStream(String name) FileOutputStream(String name, boolean append) 前两种构造方法在向文件写数据的时将覆盖文件中原有的内容，FileOutputStream实例时， 如果文件不存在，则自动生成一个空的文件。如果路径不存在则报异常 PrintStream类 特点：永远不会抛出IOException 构造函数： PrintStream(File file) PrintStream(OutputStream out) PrintStream(String fileName) 方法： void print(基础数据类型) // 包括：boolean,char,char[],double,float,int,long,String,Object,保持数据的表现形式。 void write(int b) //写入字节码为b的值，只保留int的后8位。 BufferedOutputStream类 构造方法： BufferedOutputStream(OutputStream out) 方法： void flush() ObjectOutputStream类 构造：ObjectOutputStream(OutputStream) 方法：void writeObject(Object obj) 对象必须实现Serializable接口 PipedOutputStraem类 构造方法：PipedOutputStream(PipedInputStream snk) 方法： void connect(PipedInputStream snk) DataOutputStream类 构造方法：DataOutputStream(OutputStream out) 方法：void writeUTF(String str) 修改版UTF-8格式写入 字符流 特点：最小处理单元为2个字节的Unicode字符。有缓冲区。处理文字意外的数据会出错。 Writer抽象类 方法： abstract void flush() 刷新流，把缓冲区的内容写入到目标文件 abstract void close() 关闭流，会先执行flush后关闭流。 void writer(char[] cbuf) void write(char[] cbuf, int off, int len) off为起始位置，len为长度。 void write(int c) 写入编号为c的字符。 void write(String str) void write(String str, int off, int len) 写入字符串，off为起始下标，len为长度。 BufferedWriter类 构造函数：BufferedWriter(Write out) 创建一个缓冲输入流，效率高 方法： void newLine() 新建一个依据系统的换行 void close() Writer也会被关闭 OutputStreamWriter类 构造方法： OutputStreamWriter(OutputStream out) OutputStreamReader(OutputStream in, Charset cs) Charset为编码表,如\"GBK\",\"gbk\",\"utf-8\" FileWriter类 构造方法： FileWriter(File file) FileWriter(String fileName) 如果不存在则自动创建，如果存在则会被覆盖。 FileWriter(String fileName, boolean append) append为true时，可以续写。 PrintWriter类 构造方法： PrintWriter(File file) PrintWriter(OutputStream out) 可选项boolean autoFlush.printf,println,format方法将自动刷新 PrintWriter(String fileName) PrintWriter(Writer out) 可选项boolean autoFlush.printf,println,format方法将自动刷新 reader抽象类 方法： int read() 返回一个字符的号码0~65535，当到达末尾时返回-1 int read(char[] cbuf) 返回读取的个数，没有读取到或末尾则返回-1 // 例：条件:文件为\"abcde\",buf为char[3]. int num = fr.read(buf); System.out.println(num + \":\"+new String(buf)): //输出3:abc 读取了三个字符，分别写入buf数组 int num1 = fr.read(buf); System.out.println(num1 + \":\"+new String(buf)): //输出2:dec 读取了两个字符，覆盖了buf[0]和buf[1] int num2 = fr.read(buf); System.out.println(num2 + \":\"+new String(buf)): //输出-1:dec 没读取到字符，返回-1 BufferedReader类 构造函数： BufferedReader(Reader in) 方法： String readLine()读取一行文本，不包括换行符。没有下一行返回null,若没有换行符则会阻塞 InputStreamReader类 构造函数： InputStreamReader(InputStream in) InputStreamReader(InputStream in, Charset cs) Charset为编码表,如\"GBK\",\"gbk\",\"utf-8\" FileReader类 构造方法： FileReader(File file) 如果不存在，抛出异常 FileReader(String fileName) LineNumberReader类 构造方法： LineNumberReader(Reader in) 方法： int getLineNumber() 获取行号++ void setLineNumber(int lineNumber) 设置行号 String readLine() 读一行 Serializable接口 默认会计算出一个序号用以判断序列化反序列化时对象是否有改变。 建议显式声明一个Static final long的序列号，以避免默认生成高敏感性带来的问题。 序列化和反序列化 把对象转换为字节序列的过程称为对象的序列化。 把字节序列恢复为对象的过程称为对象的反序列化。 RandomAccessFile类 特点：只能对文件进行操作。综合了输入和输出流。如果文件不存在，则创建，如果存在，不创建，使用原文件。用于多线程输出。 构造方法： RandomAccessFile(File file,String mode) mode为r只读，rw读写 RandomAccessFile(String name ,String mode) 以name为路径的文件名 方法： long getFilePointer() 返回当前指针的位置 void seek(long pos) 设置指针的位置 装饰设计思想 BufferedWriter就是一种装饰类，运用的是装饰设计，与继承的差别在于，对于同一个功能的拓展，继承需要对每个子类都进行继承，会使体系越来越臃肿。而装饰只需要对父类或接口进行关联，就可以应用于所有子类，更灵活。 总结：装饰类比继承灵活。装饰类和被装饰类都必须所属同一个接口或父类。 阻塞式方法：必须等待输入数据可用或者检测到输入结束或者抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。 将Iterator和Enumeration转换 ArrayList a1 = new ArrayList(); Iterator it = a1.iterator(); //匿名类重写方法。用Iterator的方法来实现。 Enumeration = new Enumeration(){ public boolean hasMoreElements(){ return it.hasNext(); } public FileInputStream nextElement(){ return it.next(); } } ; Java 8更加智能：如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰。 流的read方法都是阻塞的:即流内没有内容时会一直等待. "},"advanced/string.html":{"url":"advanced/string.html","title":"String类","keywords":"","body":"String类 String类 字符串对象一旦被初始化就不会被改变。 String s = \"abc\";//创建一个字符串对象在常量池中。 String s1 = new String(\"abc\");//创建两个对象一个new一个字符串对象在堆内存中。 System.out.println(s.equals(s1)); //string类中的equals复写Object中的equals建立了string类自己的判断字符串对象是否相同的依据。 //其实就是比较字符串内容。 获取 // 获取字符串中字符的个数(长度). int length(); // 根据位置获取字符。 char charAt(int index); // 根据字符获取在字符串中的第一次出现的位置 int indexOf(int ch) int indexOf(int ch,int fromIndex) // 从指定位置进行ch的查找第一次出现位置 int indexOf(String str); int indexOf(String str,int fromIndex); // 根据字符串获取在字符串中的第一次出现的位置. int lastIndexOf(int ch) int lastIndexOf(int ch,int fromIndex) // 从指定位置进行ch的反向查找第一次出现位置 int lastIndexOf(String str); int lastIndexOf(String str,int fromIndex); // 获取字符串中一部分字符串。也叫子串. String substring(int beginIndex, int endIndex) //包含begin 不包含end 。 String substring(int beginIndex); 转换 // 将字符串变成字符串数组(字符串的切割) String[] split(String regex):涉及到正则表达式. \"\\\\s+ \"可以切割多个空格 // 将字符串变成字符数组。 char[] toCharArray(); // 将字符串变成字节数组。 byte[] getBytes(); // 将字符串中的字母转成大小写。 String toUpperCase():大写 String toLowerCase():小写 // 将字符串中的内容进行替换 String replace(char oldch,char newch); String replace(String s1,String s2); // 将字符串两端的空格去除。 String trim(); // 将字符串进行连接 。 String concat(string); 判断 // 两个字符串内容是否相同啊？ boolean equals(Object obj); boolean equalsIgnoreCase(string str); // 忽略大写比较字符串内容。 // 字符串中是否包含指定字符串？ boolean contains(string str); // 字符串是否以指定字符串开头。是否以指定字符串结尾。 boolean startsWith(string); boolean endsWith(string); 比较 int compareTo(string) // 逐个比较字符的Unicode值，短的比长的小。小返回负数，大返回正数，相同返回0 String s2 = s1.intern(); // 返回一个和s1相同的池中的字符串，如果没有则在池中创建并返回 连接 String concat(String str) // 返回一个连接的字符串。 // String 虽然是引用类型，但在参数传递时，都是创建新的String对象，对原对象的引用不会造成改变。 public String replaceAll(String regex,String replacement) // $引用已捕获的序列例子引用已捕获的序列,例如: str.replaceAll(\"(.)\\\\1+\", \"$1\"); // \"\\\\1\" 是对于(.)的引用 StringBuffer 就是字符串缓冲区。用于存储数据的容器。 特点 长度的可变的。 可以存储不同类型数据。 最终要转成字符串进行使用。 可以对字符串进行修改。 方法 // 添加： StringBuffer append(data); StringBuffer insert(index,data); //（插入，不会覆盖该位置的原有数据） // 删除： StringBuffer delete(start,end) // 包含头，不包含尾。 StringBuffer deleteCharAt(int index) // 删除指定位置的元素 // 查找： char charAt(index); int indexOf(string); int lastIndexOf(string); // 修改： StringBuffer replace(start,end,string); void setCharAt(index,char); jdk1.5以后出现了功能和StringBuffer一模一样的对象。就是StringBuilder 不同的是： StringBuffer是线程同步的。通常用于多线程。 StringBuilder是线程不同步的。通常用于单线程。 它的出现是为了提高效率。 unicode编码范围： 汉字：[0x4e00,0x9fa5]（或十进制[19968,40869]） 数字：[0x30,0x39]（或十进制[48, 57]） 小写字母：[0x61,0x7a]（或十进制[97, 122]） 大写字母：[0x41,0x5a]（或十进制[65, 90]） "},"advanced/thread.html":{"url":"advanced/thread.html","title":"多线程","keywords":"","body":"多线程 Runnable接口 方法：void run() 重写该抽象方法来实现多线程 Thread类 构造函数： Thread() Thread(String name) Thread(Runnable target) Thread(Runnable target, String name) 方法： void run() void start() 运行该线程 String getName() 获取线程的名字，Thread-编号(从0开始) ，主线程名字为main int getPriority() 获取优先级 void setPriority(int newPriority) 设置优先级1~10，默认为5 void join() 直到用该方法的线程死亡前一直等待。(在A的线程中间调用B.join()，则直到B结束A才会运行) static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠（代码所在的线程休眠，实例调用也一样） boolean isAlive() 当前线程是否处于活跃状态(线程执行结束后的状态返回false) Thread.State getState() 返回一个State枚举常量 static Thread currentThread() 返回一个当前线程对象。 void interrupt() 把当前线程从阻塞状态中恢复到可执行状态 static void yield() 当前线程释放执行权限,进行新一轮的权限争夺 同步代码块的格式： synchronized(对象) { 需要被同步的代码； } 同步函数的锁是this，静态同步函数的锁是字节码对象(*.class/this.getClass) Object类里的线程通信方法: void wait() 让当前线程冻结,并释放锁 void wait(long timeout,) void wait(long timeout,int nanos)分别是毫秒和纳秒,(当纳秒>500,000时,timeout++) void notify() 唤醒一个当前对象线程池中的线程(任意) void notifyAll() 唤醒当前对象线程池中所有的线程 java.util.concurrent.locks Lock接口 方法: void lock() 当前线程获取锁, void unlock() 当前线程释放锁. Condition newCondition() 返回监视器对象 ReentrantLock类 ReentrantLock() Condition接口 方法: void await() void signal() void signalAll() "},"advanced/usefulClass.html":{"url":"advanced/usefulClass.html","title":"实用类","keywords":"","body":"实用类 枚举类 方法： boolean hasMoreElements() E nextElement() 枚举 枚举是定义的类，{}里的是它的实例，所以比较值时应该用==，不要用equals public enum Size {SMALL,MEDIUM,LARGE,EXTRA_LARGE}; 枚举里也可以有构造函数和方法和域。当有这些时，枚举常量列表用豆号隔开，最后一定要有分号。 public enum Size{ SMALL(\"S\"),MEDIUM(\"M\"),LARGE(\"L\"),EXTRA_LARGE(\"XL\"); private String abbreviation; private Size(String abbrevation) {this.abbrevation = abbrevation;} 构造必为私有 publc String getAbbrecvation() {return abbrevation; } } 枚举值可以看成是 public static final Size SMALL = new Size(\"S\"); System类 成员变量： static InputStream in static PrintStream out 方法： static long currentTimeMillis() 获取当前时间的毫秒值 static Properties getProperties() 获取当前系统的属性信息 static String getProperty(String key) 返回键值对应的属性信息。 Runtime类 特点：没有构造方法，只能通过getRuntime()获得实例，且只有一个，是一个单例设计。 方法： static Runtime getRuntime() 返回与当前运行java程序相关的Runtime对象。 Process exec(String command) 执行指定的字符串命令，并返回进程。 举例： Runtime r = Runtime.getRuntime(); Process p = r.exec(\"notepad.exe c:\\\\RuntimeDemo.java\"); Thread.sleep(5000); p.destory(); 关闭进程 Math类 方法： static int abs(int a) 绝对值，输入什么类型返回什么类型，同样的还有double,float,long static double ceil(double a) 返回大于或等于参数的最小整数(进1) static double floor(double a) 返回小于或等于参数的最小整数(去尾) static long round(double a) static int round(float a) 四舍五入 max和min为比较两个数的大小，支持double,float,in,long static double pow(doube a, double b)a的b次幂 static double random()返回一个0.0~1.0的数 Random类 特点：用同一个种子值来初始化两个Random 对象，然后用每个对象调用相同的方法，得到的随机数也是相同的。 构造方法：Random() 或 Random(long seed) 用种子生成随机对象。 方法： int nextInt(int bound) 返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值bound（不包括）之间均匀分布的 int 值。 int nextInt() 返回一个伪随机数，-2^31~2^31 Math.abs(new Random().nextInt()) % 52 表示取0~51的随机数。 date类 构造方法： Date date = new Date();//将当前日期和时间封装成Date对象。空参构造 Date date2 = new Date(1335664696656l);//将指定毫秒值封装成Date对象 long型带参构造 方法: long getTime() 返回毫秒值 void setTime(long time) 设置Date对象的时间 String toString() 格式：dow mon dd hh:mm:ss zzz yyyy dow星期 zzz时区 DateFormat类 方法： static DateFormat getDateInstance(int style)返回日期格式器 static DateFormat getDateTimmeInstance(int style)返回日期时间格式器，风格FULL,LONG,MEDIUM,SHORT. String format(Date date)格式化并返回字符串 Date parse(String source)按DateFormat对象格式，解析成date对象。 SimpleDateFormat类 特点：可以自定义风格 构造方法：SimpleDateFormat(String pattern) 自定义格式规则 年y月M日d 时H分m秒s Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year (context sensitive) Month July; Jul; 07 L Month in year (standalone form) Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, ..., 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST;GMT-08:00 Z Time zone RFC 822 time zone -800 X Time zone ISO 8601 time zone -08; -0800; -08:00 Calendar类 方法： int get(int field)返回对应成员变量的值。 static Calendar getInstance()无法通过构造函数创建对象，只能用此方法。 void set(int field, int value) void set(int year, int month, int date) void set(int year, int month, int date, int hourOfDay, int minute) void set(int year, int month, int date, int hourOfDay, int minute, int second) abstract void add(int field, int amount) 偏移相应field的时间,用+-表示前后 Calendar 的 month 从 0 开始，也就是全年 12 个月由 0 ~ 11 进行表示。 而 Calendar.DAY_OF_WEEK 定义和值如下： Calendar.SUNDAY = 1 Calendar.MONDAY = 2 Calendar.TUESDAY = 3 Calendar.WEDNESDAY = 4 Calendar.THURSDAY = 5 Calendar.FRIDAY = 6 Calendar.SATURDAY = 7 包装类 装箱：基本类型转换为包装类的对象 拆箱：包装类对象转换为基本类型的值 Type：Byte，Boolean，Short，Character，Integer，Long，Float，Double 构造方法： Type(type value) Type(String value) Boolean类时，若该字符串内容为true(不考虑每个字母的大小写)，则该Boolean对象表示true。否则都表示false. 当Number包装类构造方法参数为String 类型时，字符串不能为null，且该字符串必须可解析为相应的基本数据类型的数据，否则编译通过，运行时NumberFormatException异常。 方法： type typeValue() type换成对应的基本数据类型 String toString() 返回对象的字符串形式 public static String toString(type i) 返回i的字符串形式 public static type parseType(String type) 把字符串转换成对应的基本数据类型，(Character除外)不匹配会抛NumberFormatException异常 public static Type valueOf(type value) 所有类都有，基本类型转换为包装类 public static Type valueOf(String s) 除Character外都有，匹配的字符串转换为包装类 基本类型和包装类的自动转换 //装箱 Integer intObject = 5; //拆箱 int intValue3 = intObject; File类 成员变量： static String pathSeparator 多个路径之间分隔符，UNIX为：，windows为； static char pathSeparatorChar static String separator 路径分隔符,UNIX为'/', windows为'\\\\' static char separatorChar 构造方法： // File(File parent, String child) File f = new File(\"c:\\\\\"); File f1 = new File(f,\"a.txt\"); // File(String pathname) File f2 = new File(\"c:\\\\a.txt\"); // 相对路径也可以,相对于class所在的文件夹(jvm产生的路径) File (String parent, String child) File f3 = new File(\"c:\\\\\", \"a.txt\"); // File(URI uri) 方法： 获取 String getPath() 相对路径,相对于当前路径 String getAbsolutePath() 绝对路径 String getName() long lastModified() 返回最后一次修改时间的毫秒数 long length() 返回文件长度，单位为字节，不存在则返回0L 创建与删除 boolean createNewFile() 创建名称得的空文件，不能创建文件夹，即无目录时报异常。文件存在时返回false boolean mkdir() 一级目录 boolean mkdirs() 多级目录 boolean delete() 删除文件或目录，目录内有文件时无法删除。 判断 boolean exists() 文件或目录是否存在 boolean isFile() 是否是文件，存在且是文件返回true boolean isDirectory() 是否是目录，存在且是目录返回true 重命名 boolean renameTo(File dest) // 重命名此抽象路径名表示的文件。可以重命名路径实现剪切。dest为指定文件的新抽象路径名 其他 static File[] listRoots() 获取系统根目录的File数组 long getFreeSpace() 获取此抽象路径指定的分区的剩余可用空间 long getTotalSpace() 获取此抽象路径指定的分区的总容量 long getUsableSpace() 获取此抽象路径指定的分区的可用于虚拟机的字节数 获取文件和目录 String[] list() // 获取当前目录下的文件以及文件夹名称的数组，包含隐藏文件。 // 如果抽象路径为文件或者为系统隐藏目录时，返回null。 // 如果目录内没内容，则会返回一个长度为0的数组。 String[] list(FilenameFilter filter) // 返回符合过滤器的boolean accept(File dir，String name)的文件名或目录名。 File[] listFiles() File[] listFiles(FileFilter filter) File[] listFiles(FilenameFilter filter) "},"javaWeb/ELexperssion.html":{"url":"javaWeb/ELexperssion.html","title":"EL(表达式语言)","keywords":"","body":"EL(表达式语言) EL是JSP内置的表达式语言 jsp2.0开始，不让再使用java脚本，而是使用el表达式和动态标签来替代java脚本！ EL替代的是，也就是说，EL只能做输出！ 如果希望忽略某个EL表达式，可以在EL表达式之前添加“\\”，例如：${1 + 2}。 下标写法：${initParam['a']}等效于${initParam.a},且当属性名包含\"_\"时必须用下标写法 EL内置对象 EL一共11个内置对象，无需创建即可以使用。这11个内置对象中有10个是Map类型的，最后一个是pageContext对象不是map。 四大域相关内置对象 ${xxx}，全域查找名为xxx的属性(顺序为page,request,session,application)，如果不存在，输出空字符串，而不是null。 ${pageScope.xxx}、${requestScope.xxx}、${sessionScope.xxx}、${applicationScope.xxx}，指定域获取属性 请求参数和头相关内置对象 param：Map类型,适用于单值的参数。 paramValues：Map类型,适用于多值的参数。 header： Map类型，适用于单值请求头 headerValues：Map类型，适用于多值请求头 initParam：Map类型,获取内的参数！ xxx XXX yyy YYY 例如：${initParam.xxx} 其他内置对象 cookie：Map类型，其中key是cookie的name，value是cookie对象。${cookie.username.value} pageContext：它是PageContext类型！${pageContext.request.contextPath} javaBean导航 使用el获取request域的emp ${requestScope.emp.address.street }等效于request.getAttribute(\"emp\").getAddress().getStreet() request的emp(对象)属性的address(对象)属性的street(对象)属性,这里指的是javaBean里的属性,用get方法实现 EL函数库（由JSTL提供的） 导入标签库： String toUpperCase(String input)：把参数转换成大写 String toLowerCase(String input)：把参数转换成小写 int indexOf(String input, String substring)：从大串，输出小串的位置！ boolean contains(String input, String substring)：查看大串中是否包含小串 boolean containsIgnoreCase(String input, String substring)：忽略大小写的，是否包含 boolean startsWith(String input, String substring)：是否以小串为前缀 boolean endsWith(String input, String substring)：是否以小串为后缀 String substring(String input, int beginIndex, int endIndex)：截取子串 String substringAfter(String input, String substring)：获取大串中，小串所在位置后面的字符串 substringBefore(String input, String substring)：获取大串中，小串所在位置前面的字符串 String escapeXml(String input)：把input中“\"、\"&\"、\"'\"、\"\"\"，进行转义 String trim(String input)：去除前后空格 String replace(String input, String substringBefore, String substringAfter)：替换 String[] split(String input, String delimiters)：分割字符串，得到字符串数组 int length(Object obj)：可以获取字符串、数组、各种集合的长度！ String join(String array[], String separator)：联合字符串数组！ 自定义函数库 写一个java类，类中可以定义0~N个方法，但必须是static，而且有返回值的 在WEB-INF目录下创建一个tld文件 fun //方法名 cn.itcast.fn.MyFunction //方法所在类 java.lang.String fun() //方法签名 在jsp页面中导入标签库 在jsp页面中使用自定义的函数：${it:fun() } EL中的基础操作符 EL表达式支持大部分Java所提供的算术和逻辑操作符： 操作符 描述 . 访问一个Bean属性或者一个映射条目 [] 访问一个数组或者链表的元素 ( ) 组织一个子表达式以改变优先级 + 加 - 减或负 * 乘 / or div 除 % or mod 取模 == or eq 测试是否相等 != or ne 测试是否不等 测试是否小于 > or gt 测试是否大于 测试是否小于等于 >= or ge 测试是否大于等于 && or and 测试逻辑与 \\ \\ or or 测试逻辑或 ! or not 测试取反 empty 测试是否空值 "},"javaWeb/JDBC.html":{"url":"javaWeb/JDBC.html","title":"JDBC(Java数据库连接）","keywords":"","body":"JDBC(Java数据库连接） JDBC 编程步骤 加载驱动程序： Class.forName(driverClass) //加载MySql驱动 Class.forName(\"com.mysql.jdbc.Driver\") //加载Oracle驱动 Class.forName(\"oracle.jdbc.driver.OracleDriver\") 原理： 利用加载class文件执行static代码 所有的java.sql.Driver实现类，都提供了static块，块内的代码就是把自己的对象传给DriverManager.registerDriver(对象)方法来注册. jdbc4.0后每个驱动jar包中，在META-INF/services目录下提供了一个名为java.sql.Driver的文件,内容就是该接口的实现类名称.会自动获取该实现类并加载,所以可以省略第一步. 获得数据库连接： //方法Connection getConnection(URL,username,password) Connection con=DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb3\", \"root\", \"root\"); //MySQL的URL格式 jdbc:mysql://主机名或IP地址：端口号/数据库名?useUnicode=true&characterEncoding =UTF-8 创建Statement/PreparedStatement对象： //创建Statement Statement stat = con.createStatement(); //发送DML或者DDL的sql语句 String sql =\"INSERT INTO stu VALUES('ITCAST_003','zhangsan',88,'male')\" //不加; int r = stat.executeUpdate(sql) //r为影响的行数 //发送DQL语句 ResultSet rs = stmt.executeQuery(\"SELECT * FROM stu\"); //解析ResultSet while(rs.next()) {//把光标向下移动一行，并判断下一行是否存在(初始在beforeFirst) int empno = rs.getInt(1);//通过列编号来获取该列的值！ String ename = rs.getString(\"ename\");//通过列名称来获取该列的值 double sal = rs.getDouble(\"sal\"); System.out.println(empno + \", \" + ename + \", \" + sal); } 关闭资源： rs.close(); stmt.close(); con.close(); 例子 public void fun3() throws Exception { Connection con = null;// 定义引用 Statement stmt = null; ResultSet rs = null; try { /* * 一、得到连接 */ String driverClassName = \"com.mysql.jdbc.Driver\"; String url = \"jdbc:mysql://localhost:3306/exam\"; String username = \"root\"; String password = \"123\"; Class.forName(driverClassName); con = DriverManager.getConnection(url, username, password);// 实例化 /* * 二、创建Statement */ stmt = con.createStatement(); String sql = \"select * from emp\"; rs = stmt.executeQuery(sql); rs.last();// 把光标移动到最后一行 System.out.println(rs.getRow()); rs.beforeFirst(); /* * 三、循环遍历rs，打印其中数据 * * getString()和getObject()是通用的！ */ // while(rs.next()) { // System.out.println(rs.getObject(1) + \", \" // + rs.getString(\"ename\") + \", \" + rs.getDouble(\"sal\")); // } int count = rs.getMetaData().getColumnCount(); while (rs.next()) {// 遍历行 for (int i = 1; i JDBC对象 DriverManager类 方法： Class.forName(“com.mysql.jdbc.Driver”);//注册驱动 String url = “jdbc:mysql://localhost:3306/mydb1”; String username = “root”; String password = “123”; Connection con = DriverManager.getConnection(url, username, password); 注意，上面代码可能出现的两种异常： ClassNotFoundException：在第1句上出现，原因可能有两个： 你没有给出mysql的jar包； 你把类名称打错了，查看类名是不是com.mysql.jdbc.Driver。 SQLException：出现在第5句，出现这个异常就是三个参数的问题，往往username和password一般不是出错，所以需要认真查看url是否打错。 对于DriverManager.registerDriver()方法了解即可，因为我们今后注册驱动只会Class.forName()，而不会使用这个方法。 Connection接口 方法: Statement stmt = con.createStatement(); 获取Statement Statement stmt = con.createStatement(int,int); Statement接口 方法： int executeUpdate(String sql)：执行更新操作，即执行insert、update、delete语句，其实这个方法也可以执行create table、alter table，以及drop table等语句，但我们很少会使用JDBC来执行这些语句； ResultSet executeQuery(String sql)：执行查询操作，执行查询操作会返回ResultSet，即结果集。 boolean execute() 这个方法可以用来执行增、删、改、查所有SQL语句。该方法返回的是boolean类型，表示SQL语句是否有结果集。 如果使用execute()方法执行的是更新语句，那么还要调用int getUpdateCount()来获取insert、update、delete语句所影响的行数。 如果使用execute()方法执行的是查询语句，那么还要调用ResultSet getResultSet()来获取select语句的查询结果。 ResultSet接口 ResultSet表示结果集，它是一个二维的表格。ResultSet内部维护一个行光标（游标） 游标控制判断方法 void beforeFirst()：把光标放到第一行的前面，这也是光标默认的位置； void afterLast()：把光标放到最后一行的后面； boolean first()：把光标放到第一行的位置上，返回值表示调控光标是否成功； boolean last()：把光标放到最后一行的位置上； boolean isBeforeFirst()：当前光标位置是否在第一行前面； boolean isAfterLast()：当前光标位置是否在最后一行的后面； boolean isFirst()：当前光标位置是否在第一行上； boolean isLast()：当前光标位置是否在最后一行上； boolean previous()：把光标向上挪一行； boolean next()：把光标向下挪一行； boolean relative(int row)：相对位移，当row为正数时，表示向下移动row行，为负数时表示向上移动row行； boolean absolute(int row)：绝对位移，把光标移动到指定的行上,正数第一行(1)开始,负数最后一行(-1)开始,超出范围分别为afterLast和beforeFirst,这两者返回false int getRow()：返回当前光标所在行。beforeFirst为0 获取结果集元数据 得到元数据：rs.getMetaData()，返回值为ResultSetMetaData,其方法有: 获取结果集列数：int getColumnCount() 获取指定列的列名：String getColumnName(int colIndex) 第一列为1 结果集特性 con.createStatement()：生成的结果集：不滚动、不敏感、不可更新！(mysql默认可滚动) Statement createStatement(int resultSetType, int resultSetConcurrency) 第一个参数： ResultSet.TYPE_FORWARD_ONLY：不滚动结果集； ResultSet.TYPE_SCROLL_INSENSITIVE：滚动结果集，但结果集数据不会再跟随数据库而变化； ResultSet.TYPE_SCROLL_SENSITIVE：滚动结果集，但结果集数据不会再跟随数据库而变化； 第二个参数： CONCUR_READ_ONLY：结果集是只读的，不能通过修改结果集而反向影响数据库； CONCUR_UPDATABLE：结果集是可更新的，对结果集的更新可以反向影响数据库。 上面方法分为两类，一类用来判断游标位置的，另一类是用来移动游标的。如果结果集是不可滚动的，那么只能使用next()方法来移动游标，而beforeFirst()、afterLast()、first()、last()、previous()、relative()方法都不能使用。 获取列数据方法 可以通过next()方法使ResultSet的游标向下移动，当游标移动到你需要的行时，就需要来获取该行的数据了，ResultSet提供了一系列的获取列数据的方法： String getString(int columnIndex)：获取指定列的String类型数据； int getInt(int columnIndex)：获取指定列的int类型数据； double getDouble(int columnIndex)：获取指定列的double类型数据； boolean getBoolean(int columnIndex)：获取指定列的boolean类型数据； Object getObject(int columnIndex)：获取指定列的Object类型的数据,不确定列类型时 上面方法中，参数columnIndex表示列的索引，列索引从1开始，而不是0 ResultSet还提供了一套通过列名称来获取列数据的方法： String getString(String columnName)：获取指定名称的列的String数据； int getInt(String columnName)：获取指定名称的列的int数据； double getDouble(String columnName)：获取指定名称的列的double数据； boolean getBoolean(String columnName)：获取指定名称的列的boolean数据； Object getObject(String columnName)：获取指定名称的列的Object数据； PreparedStatement预编译声明 它是Statement接口的子接口。 优点：1,防SQL攻击 2,提高代码的可读性、可维护性 3,提高效率 获得PreparedStatement对象： 给出SQL模板,即有“?”的SQL语句 调用Connection的PreparedStatement prepareStatement(String sql模板)； 调用pstmt的setXxx(int index,值)给sql模板中的第index个?赋值 调用pstmt的executeUpdate()或executeQuery()，但它们的方法都没有参数。 预处理的原理 服务器的工作： 校验sql语句的语法 编译：一个与函数相似的东西 执行：调用函数 PreparedStatement： 前提：连接的数据库必须支持预处理，几乎没有不支持的。 每个pstmt都与一个sql模板绑定在一起，先把sql模板给数据库，数据库先进行校验，再进行编译。执行时只是把参数传递过去而已。 若二次执行时，就不用再次校验语法，也不用再次编译，直接执行。 防止SQL攻击 过滤用户输入的数据中是否包含非法字符。 分步交验！先使用用户名来查询用户，如果查找到了，再比较密码。 使用PreparedStatement。 MySQL默认预处理关闭,需在URL里添加下列参数?属性1&属性2 useServerPrepStmts=true 开启预编译功能 cachePrepStmts=true 缓存编译后函数的key,避免不同pstmt执行相同sql语句产生的二次编译 rewriteBatchedStatements=true MySQL的批处理也需要通过参数来打开 批处理 Statement批处理 批处理就是把几条sql存在一批里,一次性执行,批处理只针对更新（增、删、改）语句，批处理没有查询 方法: void addBatch(String sql)：添加一条语句到“批”中； int[] executeBatch()：执行“批”中所有语句。返回值表示每条语句所影响的行数据； void clearBatch()：清空“批”中的所有语句。 注意：当执行了executeBatch()之后，“批”中的SQL语句就会被清空。还可以在执行“批”之前，调用Statement的clearBatch()方法来清空“批”。 PreparedStatement批处理 PreparedStatement的批处理有所不同，因为每个PreparedStatement对象都绑定一条SQL模板。所以向PreparedStatement中添加的不是SQL语句，而是给“?”赋值。 方法: void addBatch()：添加一组?值到“批”中； int[] executeBatch()：执行“批”中所有语句。返回值表示每条语句所影响的行数据； JdbcUtils工具类 JdbcUtils的作用 连接数据库的四大参数是：驱动类、url、用户名，以及密码。这些参数都与特定数据库关联，如果将来想更改数据库，那么就要去修改这四大参数，那么为了不去修改代码，写一个JdbcUtils类，让它从配置文件中读取配置参数，然后创建连接对象。 JdbcUtils.java public class JdbcUtils { private static final String dbconfig = \"dbconfig.properties\"; private static Properties prop = new Properties(); static { try { InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(dbconfig); prop.load(in); Class.forName(prop.getProperty(\"driverClassName\")); } catch (IOException e) { throw new RuntimeException(e); } } public static Connection getConnection() { try { return DriverManager.getConnection(prop.getProperty(\"url\"), prop.getProperty(\"username\"), prop.getProperty(\"password\")); } catch (Exception e) { throw new RuntimeException(e); } } } dbconfig.properties文件 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mydb1?useUnicode=true&characterEncoding=UTF8 username=root password=123 连接池 tomcat的conf文件夹下context.xml文件里 //最大等待时间(毫秒) 数据源(DataSource) javax.sql.DataSource接口 Context ct = new InitialContext();//构造一个初始上下文。 得到一个上下文对象 DataSource d = (DataSource)ct.lookup(\"java:comp/env/jdbc/suo\"); //检索指定的对象。 得到一个数据源对象,参数为JNDI地址:java:comp/env/JNDI名称 conn=d.getConnection(); "},"javaWeb/jsp.html":{"url":"javaWeb/jsp.html","title":"JSP(Java Server Pages)","keywords":"","body":"JSP(Java Server Pages) 运行在服务器端的Java页面.使用HTML嵌套Java代码实现。其本质是把JSP页面解析为对应的Servlet，然后通过Servlet返回静态页面。 语法 注释和写法 ：相当于写在方法内 ：相当于写在response.getWriter().print( ... )里 ：相当于写在类里,与成员变量或方法同级 ,jsp内可以使用Java注释 声明和使用 变量 类成员声明和方法内声明 等效于print(\"变量名\") 方法 只能在中声明 JSP隐式对象 request对象 客户端的请求信息被封装在request对象 方法 String getParameter(String name) 返回name指定参数的参数值 String[] getparameterValues(String name) 返回包含参数name的所有值的数组 void setCharacterEncoding(\"gb2312\") 设置接受参数的字符集 RequestDispatcher getRequestDispatcher(String path) 返回一个RequestDispatcher对象，该对象的forward(request,response)方法用于转发请求 object getAttribute(String name) 返回指定属性的属性值 void setAttribute(String key , Object obj) 设置属性的属性值 Cookie[] getCookies() 获取Cookie数组 String getProtocol() 返回请求用的协议类型及版本号 response对象 服务端的响应信息被封装在response对象 方法 sendRedirect(String location) 重新定向客户端的请求,跳转到location的页面 addCookie(Cookie cookie) 添加Cookie数据 application对象 即servletContext，整个项目共享的使用数据,服务器开启时创建,服务器关闭消失. 方法 Object getAttribute(String name) 返回给定名的属性值 void setAttribute(String name,Object obj) 设定属性的属性值 session对象 范围: 指的是客户端与服务器的一次会话,从首次访问服务器开始，到该用户关闭浏览器结束(存储在服务器) 生命周期: 当不在被需要时,从服务器中销毁,分为于主动调用销毁和过期自动销毁 其实服务器是不会知道浏览器关闭了没有，所以关闭浏览器时服务器是不会删除Session的，也正是这个原因服务器才会设置一个Session失效时间的 session靠的是浏览器cookie里的sessionId区分的,不同sessionId对应不同session,相互之间数据不共享 方法 获取session对象 Jsp中得到session对象：session是jsp内置对象之下，不用创建就可以直接使用！ Servlet中得到session对象：HttpSession session = request.getSession(); 该方法还有个可选boolean参数,默认为true 为false时:如果session缓存中(如果cookie不存在)，不存在session，那么返回null，而不会创建session对象。 实现原理 request.getSession()方法：不调用则不创建Session,jsp本身调用这个方法所以一定有Session 获取Cookie中的JSESSIONID： 如果sessionId不存在，创建session，把session保存起来，把新创建的sessionId保存到Cookie中 如果sessionId存在，通过sessionId查找session对象，如果没有查找到，创建session，把session保存起来，把新创建的sessionId保存到Cookie中 如果sessionId存在，通过sessionId查找到了session对象，那么就不会再创建session对象了。 返回session 如果创建了新的session，浏览器会得到一个包含了sessionId的Cookie，这个Cookie的生命为-1，即只在浏览器内存中存在，如果不关闭浏览器，那么Cookie就一直存在。 下次请求时，再次执行request.getSession()方法时，因为可以通过Cookie中的sessionId找到session对象，所以与上一次请求使用的是同一session对象 服务器不会马上给你创建session，在第一次获取session时，才会创建，即调用request.getSession()时 request.getSession(false)、request.getSession(true)、request.getSession()，后两个方法效果相同， 第一个方法：如果session缓存中(如果cookie不存在)，不存在session，那么返回null，而不会创建session对象。 session域相关方法 void setAttribute(String key,Object obj) 设置Session的属性 Object getAttribute(String name) 返回session的属性，不存在则返回null void removeAttribute(String name) 移除session中指定名称的对象 String getId() 返回session对象的ID void invalidate() 将session无效化，解绑任何与该session绑定的对象,再次请求会新建一个替代它 void setMaxInactiveInterval(int interval) 最大活动时间，以秒为单位，默认30分钟 boolean isNew()：查看session是否为新。当客户端第一次请求时，服务器为客户端创建session，但这时服务器还没有响应客户端，也就是还没有把sessionId响应给客户端时，这时session的状态为新 设置session自动清除时间(单位分钟)web.xml中 30 Cookie对象 存储在客户机的文本文件,保存了大量轨迹信息 方法 该方法设置 cookie 过期的时间（以秒为单位）。 public void setMaxAge(int expiry) 如果不设置，cookie 只会在当前 session 会话中持续有效。 expiry>0：浏览器会把Cookie保存到客户机硬盘上，有效时长为maxAge的值决定。 expiry expiry=0：浏览器会马上删除这个Cookie！ public String getName() 返回 cookie的名称，名称创建后将不能被修改 public String getValue() 获取cookie的值 JavaWeb中使用Cookie 原始方式： 使用response发送Set-Cookie响应头:response.addHeader(\"Set-Cookie\", \"bbb=BBB\") 使用request获取Cookie请求头:request.getHeader(\"Set-Cookie\") 便捷方式： 使用repsonse.addCookie()方法向浏览器保存Cookie 使用request.getCookies()方法获取浏览器归还的Cookie Cookie中存中文需要编码和解码 URLEncoder.encode(String s,String enc) 以enc编码字符串s URLDecoder.decode(String s,String enc) 以enc解码字符串s Cookie的path： Cookie的path由服务器创建Cookie时设置,并不是设置这个Cookie在客户端的保存路径 浏览器访问服务器的路径，如果包含某个Cookie的路径，那么就会归还这个Cookie。 例如： aCookie.path=/day11_1/; bCookie.path=/day11_1/jsps/; cCookie.path=/day11_1/jsps/cookie/; 访问：/day11_1/index.jsp时，归还：aCookie 访问：/day11_1/jsps/a.jsp时，归还：aCookie、bCookie 访问：/day11_1/jsps/cookie/b.jsp时，归还：aCookie、bCookie、cCookie Cookie的path默认值：当前访问路径的父路径。例如在访问/day11_1/jsps/a.jsp时，响应的cookie，那么这个cookie的默认path为/day11_1/jsps/ Cookie的domain domain用来指定Cookie的域名！当多个二级域中共享Cookie时才有用。 例如；www.baidu.com、zhidao.baidu.com、news.baidu.com、tieba.baidu.com之间共享Cookie时可以使用domain 设置domain为：cookie.setDomain(\".baidu.com\"); 匹配域名的就会共享cookie. 设置path为：cookie.setPath(\"/\"); 为了可以共享,必须为\"/\" Http协议规定（保证不给浏览器太大压力）： 1个Cookie最大4KB 1个服务器最多向1个浏览器保存20个Cookie 1个浏览器最多可以保存300个Cookie pageContext对象 JSP的第四大域对象,主要作用是获取并代理其他域对象. 作用范围：为当前页面,这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据, 生命周期：是当对JSP的请求时开始，当响应结束时销毁。即response不存在时结束. 主要方法 代理其他域对象 void setAttribute(String name, Object value, int scope)：在指定范围中添加数据； Object getAttribute(String name, int scope)：获取指定范围的数据； void removeAttribute(String name, int scope)：移除指定范围的数据； scope为SESSION_SCOPE/REQUEST_SCOPE/APPLICATION_SCOPE 全域查找 Object findAttribute(String name)：依次在pageContext、request、session、application范围查找名称为name的数据，如果找到就停止查找。这说明在这个范围内有相同名称的数据，那么page范围的优先级最高！ 获取其他8个内置对象： JspWriter getOut()：获取out内置对象； ServletConfig getServletConfig()：获取config内置对象； Object getPage()：获取page内置对象； ServletRequest getRequest()：获取request内置对象； ServletResponse getResponse()：获取response内置对象； HttpSession getSession()：获取session内置对象； ServletContext getServletContext()：获取application内置对象； Exception getException()：获取exception内置对象； page对象 final java.lang.Object page = this; page（当前JSP的真身类型）：当前JSP页面的“this”，即当前对象 config对象 config（ServletConfig）：对应“真身”中的ServletConfig exception对象 out对象 out（JspWriter）：等同与response.getWriter()，用来向客户端发送文本数据 public abstract void print() 显示各种数据类型的内容。 三大指令标签 一个jsp页面中，可以有0~N个指令的定义。 page指令标签 用来设置jsp页面的属性 pageEncoding是设置的JSP页面源代码的字符编码格式 charset是请求服务器以后返回过来的内容的字符编码(当浏览器得到此文件时以什么方式解码) contentType：它表示添加一个响应头：Content-Type！等效于response.setContentType(\"text/html;charset=utf-8\"); 如果两个属性只提供一个，那么另一个的默认值为设置那一个。 如果两个属性都没有设置，那么默认为iso import后更需要导入的包,可多个 errorPage和isErrorPage errorPage：当前页面如果抛出异常，那么要转发到哪一个页面，由errorPage来指定 isErrorPage：它指定当前页面是否为处理错误的页面！当该属性为true时，这个页面会设置状态码为500！(不写状态码为200)而且只有这个页面可以使用9大内置对象中的exception! web.xml里设置错误页面 404 /error/errorPage.jsp 500 /error/errorPage.jsp java.lang.RuntimeException /index.jsp autoFlush和buffer autoFlush：指定jsp的输出流缓冲区满时，是否自动刷新！默认为true，如果为false，那么在缓冲区满时抛出异常！ buffer：指定缓冲区大小，默认为8kb，通常不需要修改！指定out对象的缓存区 其他属性： isELIgnored：是否忽略el表达式，默认值为false，不忽略，即支持！ language：指定当前jsp编译后的语言类型，默认值为java。 info：信息！ isThreadSafe：当前的jsp是否支持并发访问！ session：当前页面是否支持session，如果为false，那么当前页面就没有session这个内置对象！ extends：让jsp生成的servlet去继承该属性指定的类！ include静态包含 与RequestDispatcher的include()方法的功能相似。 它是在jsp编译成java文件时完成的！他们共同生成一个java(就是一个servlet)文件，然后再生成一个class！ RequestDispatcher的include()是一个方法，包含和被包含的是两个servlet，即两个.class！他们只是把响应的内容在运行时合并了！ 作用：把页面分解了，使用包含的方式组合在一起，这样一个页面中不变的部分，就是一个独立jsp，而我们只需要处理变化的页面。 taglib导入标签库 两个属性： prefix：指定标签库在本页面中的前缀！由我们自己来起名称！ uri: 相对于项目目录的路径,指向tld文件 前缀的用法 JSP的动作标签 这些jsp的动作标签，与html提供的标签有本质的区别，是由tomcat(服务器)来解释执行。都有id和scope属性。 ：转发！它与RequestDispatcher的forward方法是一样的 }\" flush=\"true\">：包含：它与RequestDispatcher的include方法是一样的,本质上只是调用另一个Servlet 编译级别(同一个Servlet)运行级别(不同Servlet) \">：它用来作为forward和include的子标签！用来给转发或包含的页面传递参数！ 嵌入Applet JavaBean javaBean的规范 必须要有一个无参构造器 提供get/set方法，如果只有get方法，那么这个属性是只读属性,如果只有set方法,为只写属性. 属性：有get/set方法的成员，还可以没有成员，只有get/set方法。属性名称由get/set方法来决定！而不是成员名称！ 方法名称满足一定的规范，那么它就是属性！boolean类型的属性，它的读方法可以是is开头，也可以是get开头！ JavaBean属性名要求：一般小写开头,特殊时需前两个字母要么都大写，要么都小写 内省 // 通过java.beans.Introspector的getBeanInfo()方法来获取java.beans.BeanInfo实例。 BeanInfo beanInfo = Introspector.getBeanInfo(User.class); // 通过BeanInfo可以得到这个类的所有JavaBean属性的PropertyDescriptor(属性描述符)对象。 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); // 每个PropertyDescriptor对象对应一个JavaBean属性： String getName()：获取JavaBean属性名称； Method getReadMethod：获取属性的读方法； Method getWriteMethod：获取属性的写方法。 commons-beanutils，它是依赖内省完成 导包：commons-beanutils.jar，commons-logging.jar 方法 BeanUtils.getProperty(Object bean, String propertyName) 获取JavaBean属性 BeanUtils.setProperty(Object bean, String propertyName, String propertyValue) 设置JavaBean属性 BeanUtils.populate(Map map, Object bean) 封装Map数据到JavaBean对象中 CommontUtils.toBean(Map map, Class class) 返回封装了Map数据的JavaBean对象 jsp中与javaBean相关的标签 创建或查询bean 在session域中查找名为user1的bean，如果不存在，创建之 设置属性 设置名为user1的这个javabean的username属性值为admin 获取属性 获取名为user1的javabean的名为username属性值 "},"javaWeb/JSTL.html":{"url":"javaWeb/JSTL.html","title":"JSTL(JSP标准标签库)","keywords":"","body":"JSTL(JSP标准标签库) 导包：JSTL.jar，standard.jar(1.2后不需要这个包了) core标签库(c标签) 在需要使用的JSP页面引用标签库 out和set标签 ：输出 value：可以是字符串常量，也可以是EL表达式 default：当要输出的内容为null时，会输出default指定的值 escapeXml：默认值为true，当为false时解析XML ：设置(创建域的属性) var：变量名 value：变量值，可以是EL表达式 scope：域，默认为page，可选值：page、request、session、application remove标签 ：删除域变量 var：变量名 scope：如果不给出scope，表示删除所有域中的该名称的变量；如果指定了域，那么只删除该域的变量。 url标签 ：输出url value：指定一个路径！它会在路径前面自动添加项目名。 ，它会输出/day13_1/index.jsp var：指定变量名，一旦添加了这个属性，那么url标签就不会再输出到页面，而是把生成url保存到域中。 scope：它与var一起使用，用来保存url。 子标签：，用来给url后面添加参数，例如： 结果为：/day13_1/index.jsp?username=%ED%2C%3F%ED%2C%3F if标签 对应java中的if语句 ...，当test为true时，执行标签体内容 var用于存储条件结果的变量，scope为var所在域 choose标签 它对应java中的if/else if/ ... /else,更接近switch 例如： ... ... ... ... ... forEach标签 属性： var：循环变量 begin：设置循环变量从几开始。 end：设置循环变量到几结束。 step：设置步长！等同与java中的i++，或i+=2。step默认为1 status：代表循环状态的变量名称,有属性 ${status.current}当前这次迭代的（集合中的）项 ${status.index}当前这次迭代从 0 开始的迭代索引 ${status.count} 当前这次迭代从 1 开始的迭代计数 ${status.first} 用来表明当前这轮迭代是否为第一次迭代的标志 ${status.last} 用来表明当前这轮迭代是否为最后一次迭代的标志 items：指定要循环谁，它可以是一个数组或一个集合 a)循环变量方式： ${i} b)遍历数组、集合 ${str } items：指定要循环谁，它可以是一个数组或一个集合 var：把数组或集合中的每个元素赋值给var指定的变量。 当遍历map时,用${str.key}和${str.value}输出 forTokens标签 和foreach相似，指定分隔符，分隔字符串为数组，然后循环 独有属性：delims分隔符 fmt库,格式化库 格式化时间 value：指定一个Date类型的变量 pattern：用来指定输出的模板！例如：yyyy-MM-dd HH:mm:ss type：time，date，both dateStyle：short，medium，long，full，default timeStyle：short，medium，long，full，default 格式化数字 保留小数点后2位，它会四舍五入！如果不足2位，以0补位！ 保留小数点后2位，它会四舍五入！如果不足2位，不补位！ value 要显示的数字 是 无 type NUMBER，CURRENCY，或 PERCENT类型 否 Number pattern 指定一个自定义的格式化模式用与输出 否 无 currencyCode 货币码（当type=\"currency\"时） 否 取决于默认区域 currencySymbol 货币符号 (当 type=\"currency\"时) 否 取决于默认区域 groupingUsed 是否对数字分组 (TRUE 或 FALSE) 否 true maxIntegerDigits 整型数最大的位数 否 无 minIntegerDigits 整型数最小的位数 否 无 maxFractionDigits 小数点后最大的位数 否 无 minFractionDigits 小数点后最小的位数 否 无 var 存储格式化数字的变量 否 Print to page scope var属性的作用域 否 page SQL标签 JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下： 标签 描述 指定数据源 运行SQL查询语句 运行SQL更新语句 将SQL语句中的参数设为指定值 将SQL语句中的日期参数设为指定的java.util.Date 对象值 在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行 自定义标签 步骤 定义标签处理类（必须是Tag或SimpleTag的实现类,继承SimpleTagSupport更方便） 编写tld文件，它是一个xml 页面中使用来指定tld文件的位置 标签处理类 SimpleTag接口： void doTag()：每次执行标签时都会调用这个方法； JspTag getParent()：返回父标签（非生命周期方法） void setParent(JspTag)：设置父标签 void setJspBody(JspFragment)：设置标签体对象 void seetJspContext(JspContext)：设置jsp上下文对象，其实传入的是子类PageContext 在执行doTag()之前，其他三个set方法会被tomcat调用，所以可以在doTag中使用三个成员变量 可以在标签处理类中的doTag()中抛出SkipPageException，当Tomcat调用doTag()方法，并捕获到SkipPageException时，它会跳过本页面其他内容，结束处理。 package my.tag; import java.io.IOException; import java.io.StringWriter; import javax.servlet.jsp.JspContext; import javax.servlet.jsp.JspException; import javax.servlet.jsp.tagext.SimpleTagSupport; public class HelloTag extends SimpleTagSupport{ // 标签属性设置为同名的bean属性，并配上get/set方法 private String who = \"\"; StringWriter sw = new StringWriter(); @Override public void doTag() throws JspException, IOException { // 获取标签体内容传给sw getJspBody().invoke(sw); JspContext jctx = this.getJspContext(); jctx.getOut().write(\"hello \"+this.who+\"!\"+sw.toString()); } public String getWho() { return who; } public void setWho(String who) { this.who = who; } } 配置tld文件 tld文件一般都放到WEB-INF之下，这样保证客户端访问不到 This is my tag library MY Tag 1.0 my my.tag print \"hello my tag\" hello my.tag.HelloTag scriptless the name of a person who false true java.lang.String false 标签体取值： empty：无标签体,即忽略标签体。 JSP：可以包含所有类型的JSP语法 scriptless：接受文本，EL表达式和JSP动作标签，如JSP脚本元素()就不行 getjspbody().invoke(Writer out) 处理标签体内容,并输出到指定out。参数为null是输出到pageContext.getOut()得到的JspWriter对象中。 tagdependent：标签体原封不动转交由标签处理类处理 JSP页面中指定tld文件位置 然后使用标签 How are you? 运行结果 hello john!How are you? "},"javaWeb/Listener&Fiter.html":{"url":"javaWeb/Listener&Fiter.html","title":"过滤器和监视器","keywords":"","body":"过滤器和监视器 过滤器 javax.servlet.Filter接口 它会在一组资源（jsp、servlet、.css、.html等等）的前面执行，它可以让请求得到目标资源，也可以不让请求达到，过滤器有拦截请求的能力 过滤器如何编写 实现javax.servlet.Filter接口(单例) 方法: void init(FilterConfig) // 创建之后，马上执行；Filter会在服务器启动时就创建！ void destory() // 销毁之前执行！在服务器关闭时销毁 void doFilter(ServletRequest,ServletResponse,FilterChain) // 每次过滤时都会执行 配置web.xml xxx cn.itcast.web.filter.AFitler xxx /* myservlet 配置servlet为目标资源 --> FilterConfig-->与ServletConfig相似 获取初始化参数：getInitParameter() 获取过滤器名称：getFilterName() 获取appliction：getServletContext() 获取所有初始化参数的名称: Enumeration getInitParameterNames() FilterChain(链条) doFilter(ServletRequest, ServletResponse)：放行，执行目标资源，或是执行下一个过滤器 多过滤器 过滤器的四种拦截方式 REQUEST默认的,请求(直接访问) FORWARD转发 INCLUDE包含(动态包含时才触发即) ERROR通过这种方式指定的页面 在中的最后进行配置。 多个过滤器的执行顺序 的配置先后顺序决定了过滤器的执行顺序！ 监视器 事件源：三大域 ServletContext 生命周期监听：ServletContextListener void contextInitialized(ServletContextEvent sce)：创建Servletcontext(后)时 void contextDestroyed(ServletContextEvent sce)：销毁Servletcontext(前)时 属性监听：ServletContextAttributeListener void attributeAdded(ServletContextAttributeEvent event)：添加属性时； void attributeReplaced(ServletContextAttributeEvent event)：替换属性时； void attributeRemoved(ServletContextAttributeEvent event)：移除属性时； HttpSession 生命周期监听：HttpSessionListener void sessionCreated(HttpSessionEvent se)：创建session(后)时 void sessionDestroyed(HttpSessionEvent se)：销毁session(前)时 属性监听：HttpSessioniAttributeListener void attributeAdded(HttpSessionBindingEvent event)：添加属性时； void attributeReplaced(HttpSessionBindingEvent event)：替换属性时 void attributeRemoved(HttpSessionBindingEvent event)：移除属性时 ServletRequest 生命周期监听：ServletRequestListener void requestInitialized(ServletRequestEvent sre)：创建request(后)时 void requestDestroyed(ServletRequestEvent sre)：销毁request(前)时 属性监听：ServletRequestAttributeListener void attributeAdded(ServletRequestAttributeEvent srae)：添加属性时 void attributeReplaced(ServletRequestAttributeEvent srae)：替换属性时 void attributeRemoved(ServletRequestAttributeEvent srae)：移除属性时 事件对象 ServletContextEvent：ServletContext getServletContext() HttpSessionEvent：HttpSession getSession() ServletRequest： ServletContext getServletContext()； ServletReques getServletRequest()； ServletContextAttributeEvent： ServletContext getServletContext()； String getName()：获取当前操作的属性名 Object getValue()：获取当前操作的属性值 HttpSessionBindingEvent： String getName()：获取当前操作的属性名； Object getValue()：获取当前操作的属性值； HttpSession getSession()：获取当前操作的session对象。 ServletRequestAttributeEvent ： String getName()：获取当前操作的属性名； Object getValue()：获取当前操作的属性值； ServletContext getServletContext()：获取ServletContext对象； ServletRequest getServletRequest()：获取当前操作的ServletRequest对象。 关于属性监听中event的getValue的结果的分析: 添加:getValue获取这次添加的值 替换:getValue获取替换前的值,两次值相同也当成是替换 移除:getValue获取移除的值 感知监听（都与HttpSession相关） 它用来添加到JavaBean上，而不是添加到三大域上，这两个监听器都不需要在web.xml中注册。 HttpSessionBindingListener接口 javabean实现该接口，javabean就知道自己是否添加到session中了。 public void valueBound(HttpSessionBindingEvent event)：当把监听器对象添加到session中会调用监听器对象的本方法； public void valueUnbound(HttpSessionBindingEvent event)：当把监听器对象从session中移除时会调用监听器对象的本方法； HttpSessionActivationListener接口 javabean实现该接口，javabean就知道自己是否随session钝化活化了.且要实现serializable接口,否则无法序列化,将会被从session中移除 public void sessionWillPassivate(HttpSessionEvent se)：当对象感知被活化时调用本方法； public void sessionDidActivate(HttpSessionEvent se)：当对象感知被钝化时调用本方法； 注意：标签一般配置在标签前面,多个时按配置顺序执行 "},"javaWeb/servlet.html":{"url":"javaWeb/servlet.html","title":"servlet","keywords":"","body":"servlet javax.servlet.Servlet 接口 servlet都是单例 方法: public void init(ServletConfig config) throws ServletException; 初始化操作,只在创建Servlet对象之后执行一次 public void destroy(); 在Servlet销毁之前执行一次,本身不执行销毁 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; 每次处理请求时调用 public ServletConfig getServletConfig(); 获取Servlet配置信息 public String getServletInfo(); 获取Servlet信息 1.在web.xml里配置Servlet hello cn.itcast.servlet.HelloServlet //随服务器启动,值为大于等于0的整数,小的先执行 0 hello /helloworld 通过相同的servlet-name把servlet的实现类与url路径关联起来. 2.ServletConfig接口 ServletConfig对象封装了Servlet在web.xml中的配置信息，它对应元素。ServletConfig类的功能有： String getServletName()：获取Servlet配置名，即的值； ServletContext getServletContext()：获取ServletContext对象，这个对象稍后介绍 String getInitParameter(String name)：获取Servlet自己的初始化参数 Enumeration getInitParameterNames()：获取Servlet自己的所有初始化参数的名称 在web.xml文件中，配置时可以为配置0~N个初始化参数，例如： xxx cn.itcast.servlet.MyServlet p1 v1 p2 v2 GenericServlet抽象类 GenericServlet是Servlet接口的实现类，但它是一个抽象类，它唯一的抽象方法就是service()方法 GenericServlet实现了Servlet接口： 实现了String getServletInfo()方法 实现了void destory()方法，空实现 实现了void init(ServletConfig)方法，用来保存ServletConfig参数 实现了ServletConfig getServletConfig()方法 GenericServlet实现了ServletConfig接口： 实现了ServletContext getServletContext()方法 实现了String getInitParameter()方法 实现了String getServletName()方法 实现了Enumeration getInitParameterNames()方法 GenericServlet添加了init()方法： 该方法会被init(ServletConfig)方法调用 如果希望对Servlet进行初始化，那么应该覆盖init()方法，而不是init(ServletConfig)方法 HttpServlet类 HttpServlet是GenericServlet的子类，它专注HTTP请求 HttpServlet类的方法： 实现了void service(ServletRequest,ServletResponse)方法，实现内容是： 把ServletRequest强转成HttpServletRequest 把ServletResponse强转成HttpServletResponse 调用本类添加的void service(HttpServletRequest,HttpServletResponse)方法 添加了void service(HttpServletRequest,HttpServletResponse)方法，内容是： 调用request的getMethod()获取请求方式 如果请求方式为GET，那么调用本类添加的doGet(HttpServletRequest,HttpServletResponse)方法 如果请求方式为POST，那么调用本类添加的doPost(HttpServletRequest,HttpServletResponse)方法 添加了doGet(HttpServletRequest,HttpServletResponse)方法，内容是响应405，表示错误，所以我们应该去覆盖这个方法 添加了doPost(HttpServletRequest,HttpServletResponse)方法，内容是响应405，表示错误，所以我们应用去覆盖这个方法 如果是通过继承HttpServlet类来自定义Sevlet的话，那么： 不要去覆盖void service(ServletRequest,ServletResponse) 不要去覆盖void service(HttpServletRequest, HttpServletResponse) 而应该去覆盖doGet()或doPost()方法。 配置 url-pattern是一种匹配,匹配的是项目路径后的url部分,匹配到则跳转相应的Servlet 是的子元素，用来绑定Servlet的访问路径 可以在一个中给出多个，也就是说一个Servlet可以有 多个访问路径： xxx /helo1 /hello2 还可以在中使用通配符，即“*”。 /*：表示匹配任何路径(全匹配) /do/*：表示匹配以/do开头的任何路径(路径匹配) *.do：表示匹配任何以“.do”结尾的路径(拓展名匹配) 同时匹配多个Servlet时,匹配越多优先级越低 注意： 通配符要么在开头，要么在结尾，不能在中间，例如：/*.do就是错误的使用。 如果不使用通配符，那么必须以“/”开头，例如：abc就是错误的 Servlet域对象 HttpServletContext接口 ServletContext是Servlet三大域对象之一.ServletContext在服务器启动时创建，在服务器关闭时销毁，一个JavaWeb应用只创建一个ServletContext对象 获取ServletContext对象 ServletConfig getServletContext()； GenericServlet getServletContext(); HttpSession getServletContext() ServletContextEvent getServletContext() // 在HttpServlet中可以通过以下方法来获取ServletContext对象 ServletContext sc = this.getServletContext() ServletContext sc = this.getServletConfig().getServletContext() 存取数据 因为在一个JavaWeb应用中，只有一个ServletContext对象，所以在ServletContext中保存的数据可以共整个JavaWeb应用中的动态资源共享.ServletContext是Servlet三大域对象之一，域对象内部有一个Map，用来保存数据 void setAttribute(String name, Object value)：用来添加或替换ServletContext域数据 Object getAttribute(String name)：通过名称来获取域数据 void removeAttribute(String name)：通过名称移除域数据 Enumeration getAttributeNames()：获取所有ServletContext域数据的名称 读取web.xml中配置的应用初始化参数 p1 v1 p2 v2 servletContext.getInitParameter(\"p1\")，返回v1 servletContext.getInitParameter(\"p2\")，返回v2 servletContext.getInitParameterNames()，返回Enumeration，包含p1和p2 获取项目资源 相对路径和/路径都是项目目录 // String getRealPath(String path)：获取资源的真实路径 String path = servletContext.getRealPath(\"/WEB-INF/a.jpg\"); 返回值为/WEB-INF/a.jpg真实路径，即磁盘路径： C:/tomcat6/wabapps/hello/WEB-INF/a.jpg // InputStream getResourceAsStream(String path)：获取资源的输入流 InputStream in = servletContext.getResourceAsStream(\"/WEB-INF/a.jpg\"); 返回的是a.jpg的输入流对象，可以从流中得到a.jpg的数据 // Set getResourcePaths(String path)：获取指定目录下的所有资源路径 Set paths = servletContext.getResourcePaths(\"/WEB-INF\"); 返回的Set中包含如下字符串： /WEB-INF/lib/ /WEB-INF/classes/ /WEB-INF/web.xml /WEB-INF/a.jpg 获取类路径资源 可以通过Class类的对象来获取类路径下的资源，对应JavaWeb应用的类路径就是classes目录下的资源， 例如： InputStream in = cn.itcast.servlet.MyServlet.class.getResourceAsStream(\"a.jpg\"); 获取的是：/WEB-INF/classes/cn/itcast/servlet/a.jpg，即与MyServlet.class同目录下的资源 例如： InputStream in = cn.itcast.servlet.MyServlet.class.getResourceAsStream(\"/a.jpg\"); 获取的是：/WEB-INF/classes/a.jpg，即类路径的根目录下的资源，类路径的根目录就是/classes目录 HttpServletRequest接口 服务器处理请求的流程： 服务器每次收到请求时，都会为这个请求开辟一个新的线程。 服务器会把客户端的请求数据封装到request对象中，request就是请求数据的载体！ 服务器还会创建response对象，这个对象与客户端连接在一起，它可以用来向客户端发送响应。 获取请求头信息 请求协议中的数据都可以通过request对象来获取 * 获取常用信息 > 获取客户端IP，案例：封IP。request.getRemoteAddr() > 请求方式，request.getMethod()，可能是POST也可能是GET * 获取HTTP请求头 > String getHeader(String name)，适用于单值头 > int getIntHeader(String name)，适用于单值int类型的请求头 > long getDateHeader(String name)，适用于单值毫秒类型的请求头 > Enumeration getHeaders(String name)，适用于多值请求头 案例： 通过User-Agent识别用户浏览器类型 防盗链：如果请求不是通过本站的超链接发出的，发送错误状态码404。Referer这个请求头，表示请求的来源。 获取请求URL http://localhost:8080/day10_2/AServlet?username=xxx&password=yyy > String getScheme()：获取协议，http > String getServerName()：获取服务器名，localhost > String getServerPort()：获取服务器端口，8080 > String getContextPath()：获取项目名，/day10_2 > String getServletPath()：获取Servlet路径，/AServlet > String getQueryString()：获取参数部分，即问号后面的部分。username=xxx&password=yyy > String getRequestURI()：获取请求URI，等于项目名+Servlet路径。/day10_2/AServlet > String getRequestURL()：获取请求URL，等于不包含参数的整个请求路径。http://localhost:8080/day10_2/AServlet > String getProtocol() 返回请求用的协议类型及版本号 获取请求参数 请求参数是由客户端发送给服务器的！有可能是在请求体中（POST），也可能是在URL之后（GET） 请求参数：有一个参数一个值的，还有一个参数多个值 String getParameter(String name)：获取指定名称的请求参数值，适用于单值请求参数 String[] getParameterValues(String name)：获取指定名称的请求参数值，适用于多值请求参数 Enumeration getParameterNames()：获取所有请求参数名称 Map getParameterMap()：获取所有请求参数，其中key为参数名，value为参数值。 请求转发和请求包含 RequestDispatcher rd = request.getRequestDispatcher(\"/MyServlet\"); 使用request获取RequestDispatcher对象，方法的参数是被转发或包含的Servlet的Servlet路径(url-pattern) 请求转发：rd.forward(request,response); 请求包含：rd.include(request,response); 有时一个请求需要多个Servlet协作才能完成，所以需要在一个Servlet跳到另一个Servlet 一个请求跨多个Servlet，需要使用转发和包含。 请求转发：由下一个Servlet完成响应体！当前Servlet可以设置响应头！（留头不留体,响应体会被后一个覆盖） 请求包含：由两个Servlet共同来完成响应体！（都留） 无论是请求转发还是请求包含，都在一个请求范围内！使用同一个request和response！ request域 Servlet中三大域对象：request、session、application(ServletContext)，都有如下三个方法： void setAttribute(String name, Object value) Object getAttribute(String name) void removeAttribute(String name); 同一请求范围内使用request.setAttribute()、request.getAttribute()来传值！前一个Servlet调用setAttribute()保存值，后一个Servlet调用getAttribute()获取值。 请求转发和重定向的区别 请求转发是一个请求一次响应，而重定向是两次请求两次响应 请求转发地址栏不变化，而重定向会显示后一个请求的地址 请求转发只能转发到本项目其他Servlet，而重定向不只能重定向到本项目的其他Servlet，还能定向到其他项目 请求转发是服务器端行为，只需给出转发的Servlet路径，而重定向需要给出requestURI，即包含项目名！ 请求转发和重定向效率是转发高！因为是一个请求！ 需要地址栏发生变化，那么必须使用重定向！ 需要在下一个Servlet中获取request域中的数据，必须要使用转发！ HttpServletResponse接口 继承自ServletResponse接口,response使用的就是其对象. 方法 sendError(int sc) --> 发送错误状态码，例如404、500 sendError(int sc, String msg) --> 也是发送错误状态码，还可以带一个错误信息！ setStatus(int sc) --> 发送成功的状态码，可以用来发送302 响应头方法(头名不区分大小写) setHeader(String name, String value)：适用于单值的响应头 addHeader(String name, String value)：适用于多值的响应头 setIntHeader(String name, int value)：适用于单值的int类型的响应头 addIntHeader(String name, int value)：适用于多值的int类型的响应头 setDateHeader(String name, long value)：适用于单值的毫秒类型的响应头 addDateHeader(String name, long value)：适用于多值的毫秒类型的响应头 案例： 发送302，设置Location头，完成重定向,值为包含项目名的/路径 定时刷新：设置Refresh头，你可以把它理解成，定时重定向！ response.setHeader(\"Refresh\", \"5;URL=/firstWeb/servlet/NewAServlet\") 禁用浏览器缓存：Cache-Control、pragma、expires 标签可以代替响应头： response的两个流： ServletOutputStream getOutputStream()用来向客户端发送字节数据。 PrintWriter getWriter()，用来向客户端发送字符数据！需要设置编码。 两个流不能同时使用！否则会抛出IllegalStateException异常 sendRedirect(String location)重定向方法,设置302，设置Location 编码 常见字符编码：iso-8859-1(不支持中文)、gb2312、gbk、gb18030(系统默认编码，中国的国标码)、utf-8(万国码，支持全世界的编码，所以我们使用这个) 响应编码 服务端字符流编码设置 response.setCharaceterEncoding() 客户端解读编码设置,且会自动执行setCharacterEncding()方法 response.setHeader(\"Content-type\",\"text/html;charset=utf-8\") setContentType(\"text/html;charset=utf-8)。 请求编码 地址栏直接给出参数编码为GBK,表单或链接则与页面编码格式相同 服务器端默认使用ISO-8859-1来解码！ // GET请求编码处理： String username = new String(request.getParameter(\"name\").getBytes(\"iso-8859-1\"), \"utf-8\"); 在server.xml中配置URIEncoding=utf-8(不推荐,不通用) // POST请求编码处理： String username = new String(request.getParameter(\"name\").getBytes(\"iso-8859-1\"), \"utf-8\"); 在获取参数之前调用request.setCharacterEncoding(\"utf-8\"); URL编码 表单的类型：Content-Type: application/x-www-form-urlencoded，就是把中文转换成%后面跟随两位的16进制。 作用：在客户端和服务器之间传递中文时需要把它转换成网络适合的方式,防止传输过程中数据丢失 URL编码需要先指定一种字符编码，把字符串解码后，得到byte[]，然后把小于0的字节+256，再转换成16进制。前面再添加一个%。 POST请求默认就使用URL编码！tomcat会自动使用URL解码！ URL编码：String username = URLEncoder.encode(username, \"utf-8\"); URL解码：String username = URLDecoder.decode(username, \"utf-8\"); 路径 web.xml中路径，（叫它Servlet路径！） 要么以“*”开头，要么为“/”开头 转发和包含路径 以“/”开头：相对当前项目路径，即http://localhost:8080/项目名/ 不以“/”开头：相对当前Servlet路径。http://localhost:8080/项目名/servlet/ 重定向路径（客户端路径） 以“/”开头：相对当前主机，例如：http://localhost:8080/，　所以需要自己手动添加项目名，例如；response.sendRedirect(\"/day10_1/Bservlet\"); 页面中超链接和表单路径 与重定向相同，都是客户端路径！需要添加项目名 如果不以“/”开头，那么相对当前页面所在路径。如果是http://localhost:8080/day10_1/html/form.html。　即：http://localhost:8080/day10_1/html/ASevlet 建立使用以“/”开头的路径，即绝对路径！ ServletContext获取资源路径 以不以\"/\"开头都是相对当前项目目录，即当然index.jsp所在目录 ClassLoader获取资源路径 相对classes目录(不能以\"/\"开头) Class获取资源路径 以“/”开头相对classes目录 不以“/”开头相对当前.class文件所在目录。 servlet细节 不要在Servlet中创建成员！创建局部变量即可！ 可以创建无状态成员！(无论谁执行都不会变化) 可以创建有状态的成员，但状态必须为只读(无法修改)的！ "},"javaWeb/xml.html":{"url":"javaWeb/xml.html","title":"XML","keywords":"","body":"XML 树结构 实例： Everyday Italian Giada De Laurentiis 2005 30.00 实例中的根元素是 。文档中的所有 元素都被包含在 中。 元素有 4 个子元素：、、、。蓝色字体为属性。 第一行为声明。 语法规则 必须要有根元素 声明为可选，如存在需放在第一行。 所有元素都必须要有一个关闭标签，如 必须正确嵌套。即关闭标签的顺序要一致。 属性值必须加引号。 实体引用，有5个预定义，用来替代这些符号，避免错误。 | &lt; | &gt; | > | greater than | | &amp; | & | ampersand | | &apos; | ' | apostrophe | | &quot; | \" | quotation mark | 当这些字符很多时可以用， 注释，格式为 空格会被保留，连续的空格不会被合并。 以LF存储换行。 在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。 在 Unix 和 Mac OSX 中，使用 LF 来存储新行。 在旧的 Mac 系统中，使用 CR 来存储新行。 XML 以 LF 存储换行。 标签对大小写敏感。 元素 概念：元素是指从（且包括）开始标签直到（且包括）结束标签的部分。一个元素可以包含：其他元素，文本，属性，或混合以上所有。 命名规则：包含字母、数字以及其他的字符。不能以数字或标点符号开始。不能以任何xml三个字组成的开始。不能包含空格。 命名习惯：避免使用“-”“.”“:” 空元素：或者 属性 属性必须加引号，单双引号均可。如果属性值本身包含双引号可以用单引号包含双引号，或者使用字符实体。 一个元素可以有多个属性，用空格隔开。 没有规定什么时候使用属性，什么时候使用元素，建议尽量避免使用属性。 下面的 id 属性仅仅是一个标识符，用于标识不同的便签。它并不是便签数据的组成部分。 在此我们极力向您传递的理念是：元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。 Tove Jani Reminder Don't forget me this weekend! Jani Tove Re: Reminder I will not 命名空间 使用前缀来避免命名冲突。 语法规则：xmlns:前缀=\"URI\",命名空间可以在他们被使用的元素中或者在XML根元素中声明。 默认命名空间如下。默认空间名不应用于属性。如下面的isbn属性没有命名空间。 取消绑定命名空间：表示purchase范围内都位于无命名空间。表示范围内lib不能使用，可以重新定义。 Sherlock Holmes - I Arthur Conan Doyle Sherlock Holmes - II Arthur Conan Doyle Sherlock Holmes - III Arthur Conan Doyle 在以上的示例中， 元素Book、 Title 和 Author 与命名空间http://www.library.com 关联，元素 purchase、 Title 和 Author 与命名空间http://www.otherlibrary.com 关联。 "},"database/function.html":{"url":"database/function.html","title":"MySQL数据库函数","keywords":"","body":"MySQL数据库函数 多行函数/聚合函数 对一组值执行计算并返回单一的值的函数,不能直接在where使用 聚合函数 支持的数据类型 描述 sum(name) 数字 对指定列中的所有非空值求和 avg(name) 数字 对指定列中的所有非空值求平均值 min(name) 数字,字符,日期 返回指定列的最小值 max(name) 数字,字符,日期 返回指定列的最大值 count([DISTINCT] name) 任意基于行的数据类型 返回匹配指定列的非空行数，*包含null，DISTINCT字段统计不重复记录。 count(expression or null) 可以统计匹配expression的行数，因为count只当参数为null时不计数，其他包括false都会计数，同理可以用count(if(expression,1,null)) 字符串函数 lower(name)/lcase() 小写 upper(name)/ucase() 大写 substr(name,off,len)/mid 截取字符串,off是第几位,len为截几个 trim(name)/LTRIM/RTRIM 去除前后的空格,删除左/右的空格 trim(s1 from s) 删除s左右两边的s1 str_to_date(str,pattern) 字符转日期pattern:%Y-%m-%d %H:%i:%s 默认日期格式为:%Y-%m-%d,会自动转型 date_format(date,pattern) 日期转字符 format(name,num) 转成千位表示,num为小数位,四舍五入 ifnull(name,value) 将null转换为指定值 char_length(name) 获取字符个数 length(name) 获取占用字节数 concat(s1,s2...) 连接多个字符串, mysql的concat函数拼接规则是 当多个拼接的字段的字段值中存在null时，返回的一定是 null。 concat_ws(x,s1,s2) 连接多个字符串以x为分隔符 insert(s1,x,len,s2) 在s1里从第x个字符开始,len个字符替换成s2 replace(s,s1,s2) 替换s中所有的s1为s2 left(s,len) 从左开始截取len个字符 right(s,len) 从右开始截取len个字符 repeat(s,len) 返回s重复len遍 LPAD(S,len,s2) 用s2填充s的左边知道总字符为len RPAD(s,len,s2) 用s2填充s的右边知道总字符为len elt(n,s1,s2...) 从后面的多个字段中返回第N个 field(s,s1,s2..) 返回s在s1,s2...中处于第几个,无返回0 日期与时间函数 now()/current_timestamp() localtime(),sysdate() 获取当前日期和时间 curdate()/current_date() 获取当前的日期,+0获得20170616类似的数值 curtime()/current_time() 获取当前的时间,+0获得时分秒拼接的数值 month(date)/monthname(date) 获取指定date的月份或月份名 dayname(date) 获取指定date的星期名 dayofweek(date) 获取指定date处于一周的第几天(周日为1) weekday(date) 获取指定date对应的星期几(一~日对应0~6) week(date) 获取指定date处于一年的第几个星期(0~) weekofyear(date) 获取指定date处于一年的第几个星期(1~) dayofyear(date) 获取指定date是一年的第几天(1~) dayofmonth(date) 获取指定date是一月的第几天(1~) year(date) 获取指定date的年份 quarter(date) 获取指定date的季度 hour(date) 获取指定date的小时 minute(date) 获取指定date的分钟 second(date) 获取指定date的秒钟 数学函数 ABS(x) 绝对值 SIGN(X) 符号函数,返回-1,0,1表示负数,零,正数 rand() 生成0~1的随机数,开区间 cell(x)/celling(x) 进一 floor(x) 去尾 round(name,num) 四舍五入,num为保留几位小数,可为负,不写取整 truncate(name,num) 保留num位小数,直接截取 MOD(x,y) 取模x%y POW(X,Y) X的Y次幂 EXP(x) e的x次幂 SQRT(X) 求x的平方根 Radians(x) x换成弧度 degrees(x) x换成角度 pi() 返回π的值 三角函数(x) 三角函数:sin,cos,tan,asin,acos,atan,cot 系统函数 version() 系统版本 connection_id() 当前用户连接数 datebase()/schema() 返回当前使用的数据库 user()/current_user() system_user()/session_user() 返回当前用户名 其他 LAST_INSERT_ID() 自动返回最后一个INSERT或 UPDATE 操作为 AUTO_INCREMENT列设置的第一个发生的值。 即一次操作产生了多行数据时,只返回第一个值 IFNULL()当为null时返回给定值 IFNULL(expression_1,expression_2); 如果expression_1不为NULL，则IFNULL函数返回expression_1; 否则返回expression_2的结果。 "},"database/MySQL.html":{"url":"database/MySQL.html","title":"MySQL","keywords":"","body":"MySQL 数据类型 日期和时间数据类型 MySQL数据类型 含义 date 3字节，日期，格式：2014-09-18 time 3字节，时间，格式：08:42:30 datetime 8字节，日期时间，格式：2014-09-18 08:42:30 timestamp 4字节，自动存储记录修改的时间 year 1字节，年份 整型 MySQL数据类型 含义（有符号） tinyint 1字节，范围（-128~127） smallint 2字节，范围（-32768~32767） mediumint 3字节，范围（-8388608~8388607） int 4字节，范围（-2147483648~2147483647） bigint 8字节，范围（+-9.22*10的18次方） 上面定义的都是有符号的，当然了，也可以加上unsigned关键字，定义成无符号的类型，那么对应的取值范围就要翻翻了，比如：tinyint unsigned的取值范围为0~255。 int(n)需配合fillzero使用,表示int的显示位数为n位,不足的左边补0,多的原样输出,不影响内存占用大小. 浮点型 MySQL数据类型 含义 float(m, d) 4字节，单精度浮点型，m总个数，d小数位 double(m, d) 8字节，双精度浮点型，m总个数，d小数位 decimal(m, d) decimal是存储为字符串的浮点数 我在MySQL中建立了一个表，有一列为float(5, 3)；做了以下试验： 插入123.45678，最后查询得到的结果为99.999； 插入123.456，最后查询结果为99.999； 插入12.34567，最后查询结果为12.346； 所以，在使用浮点型的时候，还是要注意陷阱的，要以插入数据库中的实际结果为准。 FLOAT和DOUBLE在不指 定精度时，默认会按照实际的精度来显示，而DECIMAL在不指定精度时，默认整数为10，小数为0。 字符串数据类型 MySQL数据类型 含义 char(n)效率高 固定长度，最多255个字符 varchar(n)节省内存 可变长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 char（n）和varchar（n）中括号中n代表字符的个数，并不代表字节个数，所以当使用了中文的时候(UTF8)意味着可以插入m个中文，但是实际会占用m*3个字节。 同时char和varchar最大的区别就在于char不管实际value都会占用n个字符的空间，而varchar只会占用实际字符应该占用的空间+1，并且实际空间+1 超过char和varchar的n设置后，字符串会被截断。 char的上限为255字节，varchar的上限65535字节，text的上限为65535。 char在存储的时候会截断尾部的空格，varchar和text不会。 varchar会使用1-3个字节来存储长度，text不会。 binary属性只用于char和varchar值。当为列指定了该属性时，将以区分大小写的方式排序。与之相反，忽略binary属性时，将使用不区分大小写的方式排序。 其它类型 enum(“member1″, “member2″, … “member65535″) enum数据类型就是定义了一种枚举，最多包含65535个不同的成员。当定义了一个enum的列时，该列的值限制为列定义中声明的值。如果列声明包含NULL属性，则NULL将被认为是一个有效值，并且是默认值。如果声明了NOT NULL，则列表的第一个成员是默认值。 set(“member”, “member2″, … “member64″) set数据类型为指定一组预定义值中的零个或多个值提供了一种方法，这组值最多包括64个成员。值的选择限制为列定义中声明的值。 BLOB(Binary Large OBject)二进制大对象 专门存储图片,视频(提供视频的链接地址) CLOB(Character Large OBject)字符大对象 存储比较大的文本,4G+的字符串可以储存 常用命令 mySQL使用步骤 连接数据库:mysql -h 服务器主机地址 -u 用户名 -p 用户密码 打开/关闭服务:net start/stop mysql(mysql57) 打开数据库:use database_name 展示所有表/数据库/变量/存储引擎:show tables/databeses/variables/engines 其他命令 查看版本:mysql --version/-V 或者进入后select version() 退出mysql:quit 或者 exit 或者 \\q 或ctrl+c(mysql里可能失效) show create table table_name: \\G 查看表的创建过程的语句,\\G为格式化 show tables from database_name查看其它数据库的表 describe/desc table_name 查看表结构 结果含义:Field字段名,Type字段类型,NULL是否可以为空,Key是否是主键,Default默认值,Extra附加信息 set character_set_result='GBK'设置显示编码 source 路径 运行.sql文件 mysqldump 库名 [表名]>路径 -uroot -p123 导出数据 truncate table table_name 清空表,表结构不变,速度快 use database_name 使用数据库 set @变量名=值 //设置变量 select @变量名 //查询变量值 SQL运算符 运算符是一个保留字或字符，主要用于连接WHERE后面的条件。 算数运算符 运算符 描述 + 加法 - 把运算符两边的值相加 - 减法 - 左操作数减去右操作数 * 乘法 - 把运算符两边的值相乘 / 除法 - 左操作数除以右操作数 % 取模 - 左操作数除以右操作数后得到的余数 比较运算符 运算符 描述 = 检查两个操作数的值是否相等，如果相等则条件为真 != 检查两个操作数的值是否相等，如果不相等则条件为真。 <> 检查两个操作数的值是否相等，如果不相等则条件为真 > 检查左操作数的值是否大于右操作数的值，如果是则条件为真 检查左操作数的值是否小于右操作数的值，如果是则条件为真 >= 检查左操作数的值是否大于等于右操作数的值，如果是则条件为真 检查左操作数的值是否小于等于右操作数的值，如果是则条件为真 ! 检查左操作数的值是否不小于右操作数的值，如果是则条件为真 !> 检查左操作数的值是否不大于右操作数的值，如果是则条件为真 位运算符 运算符 描述 & 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中 \\ \\ 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中 ~ 二进制补码运算符是一元运算符，具有\"翻转\"位效应 二进制左移运算符。左操作数的值向左移动右操作数指定的位数 >> 二进制右移运算符。左操作数的值向右移动右操作数指定的位数 逻辑运算符 运算符 描述 AND AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。 BETWEEN BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。用在数字闭区间,用在字符前闭后开 EXISTS EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。 IN IN 运算符用于把某个值与一系列指定列表的值进行比较。 NOT IN IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。 LIKE LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。 GLOB GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。 NOT NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。 OR OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。 IS NULL NULL 运算符用于把某个值与 NULL 值进行比较。 IS IS 运算符与 = 相似。 IS NOT IS NOT 运算符与 != 相似。 \\ \\ 连接两个不同的字符串，得到一个新的字符串。 UNIQUE UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。 AND 和OR 的顺序优先级对判断的影响 存储引擎 MyISAM(常用) 格式文件-存储表结构的定义(mytable.frm) 数据文件-存储表行的内容(mytable.MYD) 索引文件-存储表上索引(mytable.MYI) 优点：可压缩,支持只读表(节省安全控制,检索效率高) 适用：大量数据读而少量数据更新的混合操作或者使用压缩的只读表. InnoDB(默认) 优点：支持事务,级联更新和级联删除,服务器崩溃后提供自动回复 适用：查询中包含较多数据更新操作 MEMORY 表数据及索引被存储在内存中 优点：检索速度快. 缺点:不能持久化 适用：非永久需要的数据或能从基于磁盘的表中重新生成的数据. "},"database/SQL.html":{"url":"database/SQL.html","title":"结构化查询语言(SQL)","keywords":"","body":"结构化查询语言(SQL) 不区分大小写，[]可选，非数值用''包围，字段名可以用``来包围，以区别于关键字 DDL（数据定义语言) CREATE(创建表) 1,CREATE database name --创建数据库 2,CREATE table name( --创建表(每行末尾可以用回车) col_name1 col_type(len) [not null], col_name2 col_type(len) [not null], ...); 3,CREATE table t_name1 AS SELECT col_name(s) From t_name --把查询结果当成表创建 DROP(删除表) 1,DROP database name --删除数据库 2,drop table [if exists] table_name1,table_name2 [CASCADE|RESTRICT] --删除无关数据表 3,alter table f_table_name drop FOREIGN KEY con_name[CASCADE|RESTRICT] --解除外部约束 restrict: 确保只有不存在相关视图和完整性约束的表才能删除 cascade: 任何相关视图和完整性约束一并被删除 ALTER（修改表） 1,alter table old_name rename to new_name --修改表名 2,alter table table_name • change old_name new_name new_type --修改字段名 • modify col_name new_type 约束 --修改字段类型 • add new_col_name new_type --增加字段 • drop col_name --删除字段 • alter col_name set DEFAULT value --添加默认值 3,alter table table_name --修改表级约束 add CONSTRAINT con_name --增加表级约束 • PRIMARY KEY(col)_name) --增加主键约束 • FOREIGN KEY(f_col)references m_table(M_col) --增加外键约束 • CHECK(exp) --定义约束 • DROP 约束关键字 约束名 --删除约束 DML（数据操作语言） INSERT(新增数据) 1,INSERT INTO table_name values(V1,V2,...Vn) --插入一行记录,列值同数同序(不建议使用,无法修改变结构因为会导致该语句失效) 2, INSERT INTO table_name (col1,col2...coln) values(V1,V2,....Vn) --插入指定列的值,多行插入就在values后写多个()用,隔开 3,INSERT INTO table_name SELECT col_name(s) FROM table_name1 --插入查询结果 DELETE(删除数据) 1,delete from table_name --删除所有行数据(清空表) where condition_expression --删除指定行 2,on delete cascade --外键约束定义语句，级联删除 UPDATE(更新数据) update table_name set{col_name=expression}[,...n] --修改列数据,可以多列 where condition_expression --条件语句,限定范围 例： update users set user_sex='女' where user_QQ='12302' DQL（数据查询语言） SELECT格式和顺序 1,select database(); --显示当前使用的数据库,未进库时显示所有库 2,select [distinct] col1,col2,..coln --写出要显示的列,distinct消除重复,*所有列 from table1,table2,...tablen [where conditions] --显示满足conditions的数据 [group by col_name...] --根据col_name分组并分别显示结果 --多字段分组,先按第一个分组,在对这些组按第二个分组... [聚合函数在分组之后进行计算并显示结果] [having conditions] --显示满足聚合函数的conditions的分组 [显示select选择的列项] [order by col_name[asc|desc]] --按照order_list的升序或降序排序,后跟数字指第几列 多列排序:order by col_name1 asc, col_name2 desc --按1升,2降,1优先级高 [LIMIT index,count 或者 count] --指定显示从index(0开始)开始的count个数据,或从头开始的count个数据 (mysql独有) 连接查询 内连接INNER JOIN(交集) SELECT column_name(s) FROM table1 a [INNER] JOIN table2 b ON a.column_name=b.column_name; --等值连接 ON a.column_name between b.column_name1 and b.column_name2 --非等值连接 SELECT column_name(s) FROM table a [INNER] JOIN table b ON a.column_name1=b.column_name2; --自连接 外连接LEFT/RIGHT OUTER JOIN 执行步骤：先求笛卡尔积得结果集-->用on语句筛选-->把left/right表中未匹配的行以外部行的形式加到结果集上，并用null补全。 SELECT column_name(s) FROM table1 LEFT/RIGHT [OUTER] JOIN table2 ON table1.column_name=table2.column_name; 全连接FULL OUTER JOIN(mysql内没有) 可以用UNION把left和right结合起来就是full了 多表连接 前两个表的结果表和后一个表连接 注意：ON的条件再筛选完后会补上主表的剩余的数据加上填满null值得副表，要对主副两表做限制可以先用where筛选过后的表进行关联查询 内外连接图解 子查询 IN(以in里的值查询目标) SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,...); 或(SELECT column_name From…) EXISTS(子查询有返回行时执行外查询) SELECT column_name(s) FROM table_name WHERE column_name EXISTS(SELECT * From…) WHERE(用子查询来使用聚合函数) SELECT column_name(s) FROM table_name WHERE column_name >(SELECT avg(name) From table) FROM(把子查询作为临时表) SELECT column_name(s) FROM (SELECT * From…) SELECT(只适用于单行子查询) SELECT column_name(s),(SELECT column_name From…) FROM table_name 联合查询UNION UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 注意：UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 SELECT column_name(s) FROM table1 UNION [ALL] SELECT column_name(s) FROM table2**; All为允许重复，默认不允许，可以用''替代没有值的列 Like通配符 通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 'A_Z'：所有以 'A' 起头，另一个任何值的字原，且以'Z' 为结尾的字串。 'ABZ' 和 'A2Z' 都符合这一个模式，而 'AKKZ' 并不符合 (因为在 A 和 Z 之间有两个字原，而不是一个字原)。 'ABC%'：所有以 'ABC' 起头的字串。举例来说，'ABCD' 和 'ABCABC' 都符合这个套式。 '%XYZ'：所有以 'XYZ' 结尾的字串。举例来说，'WXYZ' 和 'ZZXYZ' 都符合这个套式。 '%AN%'：所有含有 'AN' 这个套式的字串。举例来说，'LOS ANGELES' 和 'SAN FRANCISCO' 都符合这个套式。 "},"database/transaction.html":{"url":"database/transaction.html","title":"事务Transaction","keywords":"","body":"事务Transaction 概念 一个最小的不可再分的工作单元 一个事务对应一个完整的业务逻辑 事务只和DML语句有关系,由批量的DML语句组成 事务的四个特性(ACID) Atomicity（原子性）:事务是不可分割的。 Consistency（一致性）:事务要求所有DML语句操作,必须保持同时成功或同时失败. Isolation（隔离性）:多个事务之间互相具有隔离 Durability（持久性）:事务一旦提交就不能回滚,会持久化数据. 隔离级别 read uncommitted（读未提交） 事务A先写数据，则事务B不允许同时进行写操作，但允许事务B读A未提交的此行数据 这里读到的数据称为脏数据,即脏读\"Dirty Read\" 底层:读不加锁,写加行级共享锁(可以读,无法修改和删除的一种数据锁,只能加共享锁)直到事务结束 read committed（读已提交） 事务A先写,事务B不能读,A提交后才能读此行数据 但可能出现不可重复读:即B前后两次读之间A修改了,导致不一致 底层:读时加行级共享锁,读完释放,写时加行级排它锁(不能加其他锁,获锁的事务可以读写)直到事务结束 repeatable read（可重复读） 事务A先写,事务B不能读写,A先读,B不能写 但可能产生幻读:即B前后两次读全表之间A插入了,导致不一致 底层:读时加行级共享锁,直到事务结束,写时加行级排他锁直到事务结束. serializable（串行化） 事务只能一个按顺序一个执行 底层:读时,加表级共享锁,直到事务结束,写时加表级排他锁直到事务结束. 隔离级别 脏读（Dirty read） 不可重复读（Non-repeatable read） 幻读（Phantom read） 第一类丢失更新 第二类丢失更新 READ UNCOMMITED 允许 允许 允许 不允许 允许 READ COMMITED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZBLE 不允许 不允许 不允许 不允许 不允许 脏读:读取缓冲池中未提交的行数据就叫脏读，违反了事务的隔离性。 不可重复读:一个事务内，多次读到了其他已经提交的事务的更改(或删除)数据.对策:添加行级锁 幻读:一个事务内，多次读到了其他已提交事务的新增数据.对策:添加表级锁 第一类丢失更新:A事务回滚时覆盖了事务B已提交的数据 第二类丢失更新:A事务提交时覆盖了事务B已提交的数据 语法 关闭/开启自动提交事务(只对当前会话有效) set autocommit = off/on; 或者 set session autocommit = off/on; 事务的使用 start transaction;或BEGIN DML语句... COMMIT; 成功时提交,持久化数据,事务终结. ROLLBACK; 失败时回滚,记录的操作都失效.事务终结 修改隔离级别 SET [无/session/global] transaction isolation level 查看隔离级别 SELECT @@[无/session/global].tx_isolation --会话/全局 "},"database/Untitled.html":{"url":"database/Untitled.html","title":"#约束,索引","keywords":"","body":"约束,索引 字段属性 NOT NULL/NULL 能否为空 UNSIGNED 无符号的 DEFAULT '非数值'/数值 默认值 ZEROFILL 不足位0填充 AUTO_INCREMENT 自增列 索引 PRIMARY KEY 主键(非空,唯一) 自然主键(自增数)荐/业务主键(字段) FOREIGN KEY/references 外键约束 可以为null,只有表级描述/ 关联的列必须唯一/推荐主键 UNIQUE 唯一,null除外 INDEX/KEY 常规索引 FULLTEXT 全文索引 创建索引 CREATE 时 跟在字段后面,或者在下方 索引名(字段名) 使用 CREATE [unique] index 索引名 on 表名(列名) ALTER table 表名 add [unique] index 索引名(列名) 删除索引 DROP index 索引名 on 表名 ALTER table 表名 drop 索引名 查看索引 SHOW INDEX/KEYS FROM 表名 什么时候加索引：字段数据庞大,字段很少用DML操作,字段经常出现在where条件中 外键约束定义语句 on update cascade 级联更新 注释 创建表的时候写注释 create table test1 ( field_name int comment '字段的注释' )comment='表的注释'; 修改表的注释 alter table test1 comment '修改后的表的注释'; 修改字段的注释 alter table test1 modify column field_name int comment '修改后的字段注释'; --注意：字段名和字段类型照写就行 "},"DesignPatterns/designPatterns.html":{"url":"DesignPatterns/designPatterns.html","title":"概念","keywords":"","body":"设计模式 面向对象的五个基本原则 1.单一职责原则（Single-Responsibility Principle） 定义: 一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。 优点:降低复杂性,可读性提高,维护性提高,变更引起的风险降低 推荐:接口和方法一定要做到单一职责,类的设计尽量做到只有一个原因引起变化 2.开放封闭原则（Open-Closed principle） ​ 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 3.里氏替换原则（Liskov Substitution Principle） 定义:所有引用基类（父类）的地方必须能透明地使用其子类的对象。(只要父类能出现的地方,子类就可以出现,替换为子类也不会产生任何错误和异常) 优点:增强程序的健壮性 含义: 子类必须完全实现父类的方法(父类可以被子类替代) 子类可以有自己的个性(子类不能被父类替代) 子类的方法的前置条件必须与超类中的被覆写的方法的前置条件相同或者更宽松. 覆写或实现父类的方法时输出结果可以被缩小 推荐: 在类中调用其他类时务必使用父类或接口. 如果子类不能完整地实现父类的方法,或者父类的某些方法在子类中已经发生了畸变,则建议断开父子继承关系,采用依赖,聚集和组合等关系代替继承. 4.接口隔离原则（Interface-Segregation Principle） 定义:使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口 优点:保证接口的纯洁性,接口细化. 5.依赖倒置原则（Dependency-Inversion Principle） 定义:抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要面向接口编程，而不是面向实现编程。 优点:减少类之间的耦合性,提高系统的稳定性,降低并行开发引起的风险,提高代码的可读性和可维护性. 推荐: 每个类都尽量有接口或者抽象类,或者都具备. 变量的表面类型尽量是接口或者是抽象 任何类都不应该从具体类派生 尽量不要覆写基类的方法 结合里式替换原则使用 设计模式的基本原则 2~5 6.迪米特法则(Law of Demeter) 定义:一个软件实体应当尽可能少地与其他实体发生相互作用.即当其中某一个模块发生修改时，就会尽量少地影响其他模块. 优点:解耦,提高复用率 缺点:会导致系统复杂度提高 推荐:类跳转超过两次要考虑重构 7.合成复用原则(Composite Reuse Principle) ​ 原则是尽量使用组合/聚合的方式，而不是使用继承。 "},"DesignPatterns/facade.html":{"url":"DesignPatterns/facade.html","title":"门面模式(facade)","keywords":"","body":"门面模式(facade) 定义：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行.门面模式提供一个高层次的接口,使得子系统更易于使用. 优点：减少系统的相互依赖,提高了灵活性,提高安全性. 缺点：不符合开闭原则,只能在源码上修改. 角色： Facade门面角色：此角色知晓子系统的所有功能和责任。会将所有从客户端发来的请求委派到相应的子系统中 subsystem子系统角色：可以有一个或多个，每个子系统是一个类的集合，子系统不知道门面的存在，门面是它们的客户端而已。 使用场景： 为一个复杂的模块或子系统提供一个供外界访问的接口. 子系统相对独立,外界对子系统的访问只要黑箱操作即可. 预防低水平人员带来的风险扩散. 注意事项： 一个子系统可以有多个门面,可以按功能拆分门面,或者按访问权限拆分门面 门面不参与子系统内的业务逻辑,具体逻辑可以通过封装类组合逻辑,门面访问封装类完成. 子系统 public class ClassA { /** * @Description 业务逻辑方法 */ public void doSomethingA() { System.out.println(\"子系统A的业务逻辑\"); } } 门面对象 public class Facade { /** 被委托的子系统对象 */ private ClassA a = new ClassA(); private ClassB b = new ClassB(); private ClassC c = new ClassC(); /** * @Description 提供给外部访问的方法 */ public void methodA() { this.a.doSomethingA(); } public void methodB() { this.b.doSomethingB(); } public void methodC() { this.c.doSomethingC(); } } "},"DesignPatterns/factory.html":{"url":"DesignPatterns/factory.html","title":"工厂模式(factory)","keywords":"","body":"工厂模式(factory) 工厂方法模式 定义:一个用于创建对象的接口,让子类决定实例化哪个类.工厂方法使一个类的实例化延迟到子类. 优点:良好的封装性,降低耦合性,扩展性优秀 简单工厂模式 建立一个工厂实体类，对实现了同一接口的产品类进行实例的创建。通过提供一个静态方法,返回实例,通过方法参数来决定。 多个工厂方法模式 建立一个工厂抽象类,通过与产品对应的工厂实现类对实现了同一个接口的产品类进行实例的创建.以此来避免单一工厂的方法过于巨大. 替代单例模式 通过工厂方法模式来实现单例,单例类私有化构造方法,工厂类通过反射创建单独的实例并返回,还可以扩展延时初始化lazy loading,通过管理一个存放实例的Map集合缓存. public class ProductFactory{ /** 产品单例实例的存放区 */ private static final Map prMap = new HashMap(); public static synchronized Product createProduct(Class type) throws Exception{ Product product = null; if(prMap.containsKey(type)){ product = prMap.get(type); }else{ product = type.newInstance(); prMap.put(type,product); } return product; } } 抽象工厂模式 工厂方法模式有一个问题就是，类的创建依赖工厂类，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，就用到抽象工厂模式，创建抽象工厂类，这样一旦需要增加新的功能，直接增加新的工厂实现类就可以了，不需要修改之前的代码。 定义:为创建一组相关或相互依赖的对象提供一个接口,而且无须指定它们的具体类. 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是CPU，其子类有AMD处理器、Intel处理器，则抽象CPU与具体品牌的CPU之间构成了一个产品等级结构 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如PC工厂生产的AMD处理器、AMD显卡，AMD处理器位于CPU产品等级结构中，AMD显卡位于显卡产品等级结构中，AMD处理器、AMD显卡构成了一个产品族。 在图3中，不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构。图3中一共有五个产品族，分属于三个不同的产品等级结构。我们只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一确定这个产品。 使用场景:在拥有同一主题的多个产品等级结构的情况下,把各个具体产品划分出一个个产品族,以具体工厂分别实现各个产品族内各个产品的产生为目的,抽象出抽象工厂,抽象工厂和具体工厂组成一个产品族等级结构. 优点:封装性,产品族内的约束为非公开状态,在工厂内实现. 缺点:对产品族的扩展非常困难,违反开闭原则 "},"DesignPatterns/flyweight.html":{"url":"DesignPatterns/flyweight.html","title":"享元模式(flyweight)","keywords":"","body":"享元模式(flyweight) 定义：使用共享对象可以有效的支持大量的细粒度的对象. 优点：减少创建对象,降低内存占用,增强程序的性能 缺点：分离出外部状态和内部状态,提高了系统的复杂性. 角色： Flyweight抽象享元角色：一个产品的抽象类,定义出对象的外部状态和内部状态的接口或实现. ConcreteFlyweight具体享元角色：实现抽象角色定义的业务,该角色中需要注意的是内部状态处理应该与环境无关,不应该出现一个操作改变了内部状态,同时修改了外部状态. unsharedConcreteFlyweight不可共享的享元角色：不存在外部状态或者安全要求(线程安全)不能够使用共享技术的对象,该对象一般不会出现在享元工厂里. FlyweightFactory享元工厂：就是一个池容器,提供获取对象的方法. 使用场景： 系统中存在大量相似的对象. 细粒度的对象都具备较接近的外部状态,而且内部状态与环境无关.也就是说对象没有特定身份. 需要缓冲池的场景. 抽象享元类 public abstract class AbstractFlyweight { /** 内部状态 */ private String intrinsic; /** 外部状态 */ protected final String EXTRINSIC; /** * @Description 设置外部状态 * @param EXTRINSIC 外部状态 */ public AbstractFlyweight(String EXTRINSIC) { this.EXTRINSIC = EXTRINSIC; } /** * @Description 业务逻辑 */ public abstract void operate(); public String getIntrinsic() { return intrinsic; } public void setIntrinsic(String intrinsic) { this.intrinsic = intrinsic; } } 具体享元类 public class ConcreteFlyweight1 extends AbstractFlyweight{ /** * @Description 设置外部状态 * @param EXTRINSIC 外部状态 */ public ConcreteFlyweight1(String EXTRINSIC) { super(EXTRINSIC); } /** * @Description 具体业务逻辑 */ @Override public void operate() { System.out.println(\"业务逻辑\"); } } 享元工厂类 public class FlyweightFactory { /** 池容器 */ private static HashMap pool = new HashMap(); /** * @Description 工厂方法 * @param EXTRINSIC 外部状态 * @return */ public static AbstractFlyweight getFlyweight(String EXTRINSIC) { AbstractFlyweight flyweight = null; if (pool.containsKey(EXTRINSIC)) { flyweight = pool.get(EXTRINSIC); } else { flyweight = new ConcreteFlyweight1(EXTRINSIC); pool.put(EXTRINSIC, flyweight); } return flyweight; } } "},"DesignPatterns/interpreter.html":{"url":"DesignPatterns/interpreter.html","title":"解释器模式(interpreter)","keywords":"","body":"解释器模式(interpreter) 定义：给定一门语言,定义它的文法的一种表示,并定义一个解释器,该解释器使用该表示来解释语言中的句子. 优点：扩展性好,只需增加非终结符类就行. 缺点：解释器模式会引起类膨胀,采用递归调用方法,效率问题. 角色： AbstractExpression抽象解释器 TerminalExpression终结符表达式：实现与文法中的元素关联的解释操作,一般只有一个,但有多个实例,对应不同的终结符. NonterminalExpression非终结符表达式：文法中的每条规则对应一个非终结表达式,根据逻辑的复杂程度而增加,原则上一个文法规则都对应一个非终结表达式. Context环境角色：具体到例子中是HashMap代替 使用场景： 重复发生的问题可以使用解释器模式 一个简单语法需要解释的场景 可以使用shell,JRuby,Groovy等脚本语言来代替解释器模式 Expression4J,MESP(Math Expression String Parser),Jep等开源解析工具包 抽象解释器 public abstract class AbstractExpression { public abstract Object interpret(Context context); } 终结符表达式 public class TerminalExpression extends AbstractExpression { public Object interpret(Context context) { return null; } } 非终结符表达式 public class NonterminalExpression extends AbstractExpression { public NonterminalExpression(AbstractExpression... Expression) { } public Object interpret(Context context) { return null; } } 客户类 public class Client { public static void main(String[] args) { Context ctx = new Context(); Stack stack = null; for(;;) { // 进行语法判断,并产生递归调用 } // 产生一个完整的语法树,由各个具体的语法分析进行解析 AbstractExpression exp = stack.pop(); // 具体元素进入场景 exp.interpret(ctx); } } "},"DesignPatterns/iterator.html":{"url":"DesignPatterns/iterator.html","title":"迭代器模式(iterator)","keywords":"","body":"迭代器模式(iterator) 定义：提供一种方法访问一个容器对象中各个元素,而又不需要暴露该对象的内部细节. 角色： 抽象迭代器Iterator：负责定义访问和遍历元素的接口 具体迭代器ConcreteIterator：实现迭代器接口,完成容器的遍历 抽象容器Aggregate：容器提供创建迭代器的方法 具体容器ConcreteAggregate：实现容器接口定义的方法,创建出容纳迭代器的方法 "},"DesignPatterns/mediator.html":{"url":"DesignPatterns/mediator.html","title":"中介者模式(mediator)","keywords":"","body":"中介者模式(mediator) 定义:用一个中介对象封装一系列的对象交互,中介者使各个对象不需要显示地相互作用,从而使其耦合松散,而且可以独立地改变他们之间的交互. 优点:减少类之间的依赖,把一对多,变成了一对一,降低了耦合性. 角色: 抽象中介者：中介者角色的统一接口 具体中介者角色：通过协调各同事角色实现协作行为,为此它必须依赖于各个同事角色 同事角色：拥有两种行为,自发行为,与其他同事类或中介者没有任何依赖.依赖行为,必须依赖中介者才能完成的行为. 实现: 同事类用构造函数注入中介者,中介者通过getter/setter方法注入同事类 中介者类 public abstract class AbstractMediator { /** 同事类1 */ protected ConcreteColleague1 c1; /** 同事类2 */ protected ConcreteColleague2 c2; public ConcreteColleague1 getC1() { return c1; } public void setC1(ConcreteColleague1 c1) { this.c1 = c1; } public ConcreteColleague2 getC2() { return c2; } public void setC2(ConcreteColleague2 c2) { this.c2 = c2; } /** * @Description 同事类之间的交互逻辑 */ public abstract void doSomething1(); /** * @Description 同事类之间的交互逻辑 */ public abstract void doSomething2(); } 同事类 public abstract class AbstractColleague { /** 同事类必须有中介者 */ protected AbstractMediator mediator; /** * @Description 通过构造函数注入中介者 * @param mediator 中介者对象 */ public AbstractColleague(AbstractMediator mediator) { this.mediator = mediator; } } 应用场景:N个对象之间产生了相互依赖的关系(N>2),类图呈现网状结构.而且依赖的行为不确定或者有可能发生改变的可能. "},"DesignPatterns/memento.html":{"url":"DesignPatterns/memento.html","title":"备忘录模式(memento)","keywords":"","body":"备忘录模式(memento) 定义：在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可将该对象恢复到原先保存的状态. 角色： Originator发起人角色：记录当前时刻的内部状态,负责定义哪些属于备份范围的状态,负责创建和恢复备忘录数据. Memento备忘录角色：负责存储发起人对象的内部状态,在需要的时候提供发起人需要的内部环境. Caretaker备忘录管理员角色：对备忘录进行管理,保存和提供备忘录. 扩展：clone方式的备忘录,多状态的备忘录,多备份的备忘录,封装备忘录 备忘录接口 public interface Memento { } 工具类 public class BeanUtils { /** * @Description 更新bean的属性并存在提供的map里 * @param bean 新的bean状态 * @param propMap 存放bean属性的Map类 */ public static void restoreProp(Object bean, HashMap propMap) { try { BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass()); PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor des:descriptors) { String fieldName = des.getName(); if (propMap.containsKey(fieldName)) { Method setter = des.getWriteMethod(); setter.invoke(bean,propMap.get(fieldName)); } } } catch (IntrospectionException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } /** * @Description 把bean的属性存放进Map并返回 * @param bean 需要处理的bean * @return 返回的Map */ public static HashMap backupProp(Object bean) { HashMap result = new HashMap(); try { BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass()); PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor des:descriptors) { String fieldName = des.getName(); Method getter = des.getReadMethod(); Object fieldValue = getter.invoke(bean); if (!fieldName.equalsIgnoreCase(\"class\")) { result.put(fieldName, fieldValue); } } } catch (IntrospectionException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } return result; } } 发起人角色(内部封装备忘录类) public class Originator { /** javaBean属性 */ private String state1 = \"\"; private String state2 = \"\"; private String state3 = \"\"; public String getState1() { return state1; } public void setState1(String state1) { this.state1 = state1; } public String getState2() { return state2; } public void setState2(String state2) { this.state2 = state2; } public String getState3() { return state3; } public void setState3(String state3) { this.state3 = state3; } /** * @Description 创建备忘录对象 */ public Memento createMemento() { return new ConcreteMemento(BeanUtils.backupProp(this)); } /** * @Description 更新备忘录对象 */ public void restoreMemento(Memento memento) { BeanUtils.restoreProp(this,((ConcreteMemento)memento).getStateMap()); } /** * @Description 转换成字符串输出 */ public String toString() { return \"state1 = \" + this.state1 + \"\\nstate2 = \" + this.state2 + \"\\nstate3 = \" + this.state3; } /** * @Description 备忘录内部类 * @author OrezWodahs * @date 2018年6月20日 下午4:08:20 * */ private class ConcreteMemento implements Memento { /** bean属性容器 */ private HashMap stateMap; /** * @Description 通过构造,保存bean的属性至map */ private ConcreteMemento(HashMap map) { this.stateMap = map; } private HashMap getStateMap() { return this.stateMap; } private void setStateMap(HashMap stateMap) { this.stateMap = stateMap; } } } 备忘录管理类 public class Caretaker { /** 备忘录容器 */ private HashMap memMap = new HashMap(); /** * @Description 获取一个备忘录 * @param idx 备忘录标识 * @return 对应备忘录 */ public Memento getMemento(String idx) { return this.memMap.get(idx); } /** * @Description 存储一个备忘录 * @param idx 备忘录标识 * @param memento 备忘录 */ public void setMemento(String idx,Memento memento) { this.memMap.put(idx, memento); } } "},"DesignPatterns/observer.html":{"url":"DesignPatterns/observer.html","title":"观察者模式(observer)","keywords":"","body":"观察者模式(observer) 定义：定义对象间一种一对多的依赖关系,使得每当一个对象改变状态,则所有依赖它的对象都会得到通知并被自动更新 优点：观察者和被观察者之间是抽象耦合,容易扩展,建立一套触发机制 缺点：开发效率和运行效率堪忧,推荐采用异步的方式. 角色 Subject被观察者：定义被观察者必须实现的职责,它必须能够动态的增加,取消观察者.一般是抽象类或实现类. Observer观察者：观察者接收到消息后,即进行update操作,对接收到的信息进行处理 ConcreteSubject具体被观察者：定义被观察者自己的逻辑,同时定义对哪些时间进行通知 ConcreteObject具体观察者：每个观察者在接收到消息后的处理反应是不同,拥有自己的处理逻辑 被观察者 public class Observable { /** Vector利用同步方法来线程安全，线程安全在多线程情况下不会造成数据混乱 */ private Vector obs = new Vector();; /** * @Description 新增一个观察者 * @param o */ public synchronized void addObserver(Observer o) { if (o == null) throw new NullPointerException(); if (!obs.contains(o)) { obs.addElement(o); } } /** * @Description 删除观察者 * @param o */ public synchronized void deleteObserver(Observer o) { obs.removeElement(o); } /** * @Description 通知观察者 */ public void notifyObservers() { for(Observer o :this.obs) { o.update(); } } } 观察者 public interface Observer { /** * @Description 更新方法 */ void update(); } "},"DesignPatterns/prototype.html":{"url":"DesignPatterns/prototype.html","title":"原型模式(prototype)","keywords":"","body":"原型模式(prototype) 定义:用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象. 优点:性能优良,逃避构造函数的约束 原理:实现Cloneable接口,并重写clone方法,如:(浅拷贝) public class Thing implements Cloneable{ /** 非基础类型的可变引用型变量,在浅拷贝时是不会被拷贝的 */ private ArrayList arrayList = new ArrayList(); /** * @Description Cloneable的接口是没有方法的,覆盖的是Object的clone方法 * @return 拷贝后的实例类 */ @Override protected Object clone() { Thing thing = null; try { // 调用Object的clone完成浅拷贝 thing = (Thing)super.clone(); // 手动拷贝arraylist来实现深拷贝 thing.arrayList = (ArrayList) this.arrayList.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return thing; } } 使用场景: 类初始化需要消耗非常多的资源,这个资源包括数据,硬件资源等. 通过new产生一个对象需要非常繁琐的数据准备或访问权限. 一个对象需要提供给其他对象访问,而且哥哥调用者都可能需要修改其值时. 注意: 构造函数不会被执行 浅拷贝:只拷贝本对象,对其内的数组,引用对象等都不拷贝,还是指向原生对象的内部元素地址. 深拷贝:所有的都拷贝.完全不会影响到原生对象. 实现:把不被拷贝的变量单独手动拷贝并添加到拷贝类里. 要使用clone就不能在成员变量上加final "},"DesignPatterns/proxy.html":{"url":"DesignPatterns/proxy.html","title":"代理模式(proxy)","keywords":"","body":"代理模式(proxy) 定义:为其他对象提供一种代理以控制对这个对象的访问. 优点:职责清晰,高扩展性,智能化 普通代理 定义:只需要访问代理类,不需要知道真实类的存在,通过代理类的构造方法来完成真实类的创建和绑定. public interface Subject { public void request(); } public class RealSubject implements Subject { @Override public void request() { // 业务处理 } } public class Proxy implements Subject { private Subject subject = null; public Proxy() { this.subject = new Proxy(); } public Proxy(Subject subject) { this.subject = subject; } public void request() { this.before(); this.subject.request(); this.after(); } private void after() { // 预处理 } private void before() { // 善后处理 } } 强制代理 定义:从真实类查找到代理类,不允许直接访问真实类,允许使用真实类管理的代理类访问真实类的方法.否则不能访问. 动态代理 定义:在实现阶段不关心代理谁,在运行阶段才指定代理哪个对象. 原理:java.lang.reflect.Proxy.newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)方法返回指定接口的代理类的实例，这些接口将调用方法调用到指定的调用处理程序。 public interface Subject { public void request(); } public class RealSubject implements Subject { @Override public void request() { // 业务处理 } } public class ProxyHandler implements InvocationHandler { private Subject subject = null; public ProxyHandler(Subject subject) { this.subject = subject; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 预处理 Objcet obj = method.invoke(this.subject,args); // 善后处理 return obj; } } public class Test { Subject subject = new RealSubject(); Subject proxy = (Subject)Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject..getClass().getInterfaces(), new ProxyHandler(subject)); proxy.request(); } "},"DesignPatterns/singleton.html":{"url":"DesignPatterns/singleton.html","title":"单例模式(singleton)","keywords":"","body":"单例模式(singleton) 定义:保证一个类仅有一个实例，而且自行实例化并提供一个访问它的全局访问点。 主要解决:一个全局使用的类频繁地创建与销毁。 关键代码:构造函数是私有的。 优点:减少内存开支,对性能都开销,在需要频繁创建销毁,而创建和销毁的性能又无法优化的时候使用. 缺点:扩展困难,不利于测试,与单一职责原则有冲突. 饿汉式 (推荐使用,不用考虑同步问题) public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 懒汉式(同步加synchronized) public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 双检锁/双重校验锁（DCL，即 double-checked locking） public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 登记式/静态内部类 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 枚举 public enum Singleton { INSTANCE; public void whateverMethod() { } } 经验之谈：一般情况下，不建议使用懒汉方式，建议使用饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用登记方式。如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。 "},"DesignPatterns/state.html":{"url":"DesignPatterns/state.html","title":"状态模式(state)","keywords":"","body":"状态模式(state) 定义：当一个对象的内在状态改变时允许其改变行为,这个对象看起来像改变了它的类型. 优点：结构清晰,遵循开闭原则和单一职责原则,封装性好 缺点：子类太多,类膨胀 角色 State抽象状态角色：接口或抽象类,负责对象状态的定义,并且封装环境角色以实现状态处理. ConcreteState具体状态角色：每个具体状态必须完成两个职责:本状态行为管理以及趋向状态处理,即本状态该做的事和状态过渡. Context环境角色：定义客户端需要的接口,并且负责具体状态的切换.(将状态对象声明为静态常量,具有状态抽象角色定义的所有行为,具体执行使用委托方式) 使用场景 行为随状态改变而改变的场景. 条件,分支判断语句的替代者. 抽象状态类 public abstract class AbstractState { /** 定义一个环境角色 */ protected Context context; /** * @Description 设置环境角色 */ public void setContext(Context context) { this.context = context; } /** * @Description 行为1 */ public abstract void handle1(); /** * @Description 行为2 */ public abstract void handle2(); } 具体状态类 public class ConcreteState1 extends AbstractState { /** * @Description 行为1 */ @Override public void handle1() { System.out.println(\"state1:状态1必须处理的逻辑\"); } /** * @Description 行为2,转为状态2,由状态2执行行为2 */ @Override public void handle2() { System.out.println(\"state1:转为状态2\"); super.context.setCurrentState(Context.STATE2); System.out.println(\"state1:委托context执行行为2\"); super.context.handle2(); } } public class ConcreteState2 extends AbstractState { /** * @Description 行为1,转为状态1,由状态1执行行为1 */ @Override public void handle1() { System.out.println(\"state2:转为状态1\"); super.context.setCurrentState(Context.STATE1); System.out.println(\"state2:委托context执行行为1\"); super.context.handle1(); } /** * @Description 行为2 */ @Override public void handle2() { System.out.println(\"state2:状态2必须处理的逻辑\"); } } 具体环境类 public class Context { /** 状态1 */ public static final AbstractState STATE1 = new ConcreteState1(); /** 状态2 */ public static final AbstractState STATE2 = new ConcreteState2(); /** 当前状态 */ private AbstractState CurrentState; /** * @Description 获得当前状态 * @return */ public AbstractState getCurrentState() { return CurrentState; } /** * @Description 设置当前状态 * @param currentState */ public void setCurrentState(AbstractState currentState) { this.CurrentState = currentState; this.CurrentState.setContext(this); } /** * @Description 委托执行行为1 */ public void handle1() { System.out.println(\"context:委托执行行为1\"); this.CurrentState.handle1(); } /** * @Description 委托执行行为2 */ public void handle2() { System.out.println(\"context:委托执行行为2\"); this.CurrentState.handle2(); } } "},"DesignPatterns/strategy.html":{"url":"DesignPatterns/strategy.html","title":"策略模式(strategy)","keywords":"","body":"策略模式(strategy) 定义：定义一组算法,将每个算法都封装起来,并且使他们之间可以互换. 优点：算法可以自由切换,避免使用多重条件判断,扩展性良好 缺点：策略类数量增多,所有的策略类都需要对外暴露 使用场景：多个类只有在算法上不同的场景,算法需要自由切换的场景,需要屏蔽算法规则的场景 角色: 封装角色：上下文角色,起承上启下封装作用,屏蔽高层模块对策略,算法的直接访问封装可能存在的变化 抽象策略角色：定义每个策略或算法必须具有的方法和属性. 具体策略角色：实现具体的算法. 策略枚举 public enum Calculator{ ADD(\"+\"){ public int exec(int a,int b){ return a + b; } }, SUB(\"-\"){ public int exec(int a,int b){ return a - b; } }; /** 存放符号标志 */ String value = \"\"; private Calculator(String value){ this.value = value; } public String getValue(){ return this.value; } /** * @Description 抽象算法 */ public abstract int exec(int a,int b); } 调用 Calculator.ADD.exec(a,b); Calculator.SUB.exec(a, b); "},"DesignPatterns/template.html":{"url":"DesignPatterns/template.html","title":"模板方法模式(template)","keywords":"","body":"模板方法模式(template) 定义一个算法中的操作框架，而将一些步骤延迟到子类中。使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。 使用了Java的继承机制，是一个非常广泛的模式。其中AbstractClass叫做抽象模板，它的方法分为三类： 基本方法 由子类实现的方法,在模板方法内被调用(尽量设计为protected类型，符合迪米特法则，不需要暴露的属性或方法尽量不要设置为protected类型。实现类若非必要，尽量不要扩大父类中的访问权限) 模板方法 可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调用，完成固定的逻辑。(一般都加上final关键字，防止被覆写） 钩子方法 由子类覆写的方法,返回一个boolean值,在模板方法中作为用来控制代码逻辑的一个标识. 代码举例 public abstract class AbstractClass { protected abstract void doAnything(); //基本方法 protected abstract void doSomething(); //基本方法 protected boolean isDoSomething(){ //钩子方法,默认父类方法返回真 return true; } public final void templateMethod(){ /* * 调用基本方法，完成相关的逻辑 */ this.doAnything(); if(this.isDoSomething()) this.doSomething(); } } public class ConcreteClass1 extends AbstractClass { private boolean isDoSth; @Override protected void doAnything() { //子类实现具体 } @Override protected void doSomething() { } protected void setDo(boolean isDo){ this.isDoSth = isDo; } protected boolean isDoSomething(){ return isDoSth; } } "},"DesignPatterns/visitor.html":{"url":"DesignPatterns/visitor.html","title":"访问者模式(visitor)","keywords":"","body":"访问者模式(visitor) 定义：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 优点：符合单一职责原则,优秀的扩展性,灵活性非常高 缺点：具体元素对访问者公布细节,具体元素变更比较困难,违背了依赖倒置原则 角色 Visitor抽象访问者： 声明访问者可以访问哪些元素,具体到程序就是visit方法的参数定义哪些对象是可以被访问的. ConcreteVisitor具体访问者：它影响访问者访问到一个类后具体该怎么干,要做什么事情. Element抽象元素： 声明接受哪一类访问者访问,程序上通过accept方法中的参数来定义. ConcreteElement具体元素： 实现accept方法,通常是visitor.visit(this). ObjectStruture结构对象：元素生产者,一般容纳在多个不同类,不同接口的容器.如List,Set,Map 使用场景： 一个对象结构包含很多类对象,它们有不同的接口,而你想对这些对象实施一些依赖于其具体类的操作,也就是说用迭代器模式已经不能胜任的场景. 需要对一个对象结构中的对象进行很多不同并且不相关的操作,而你想避免让这些操作\"污染\"这些对象的类. 业务规则要求遍历多个不同的对象,这本身也是访问者模式出发点,迭代器模式只能访问同类或同接口的数据(除非使用instanceof),而访问者模式可以遍历不同的对象,执行不同的操作,访问者模式还有一个用途,就是充当拦截器角色. 抽象访问者 public abstract class AbstractElement { /** * @Description 业务逻辑方法 */ public abstract void doSomething(); /** * @Description 访问者访问方法 * @param visitor 允许哪个访问者 */ public abstract void accept(Visitor Visitor); } 具体访问者 public class ConcreteElement1 extends AbstractElement { /** * @Description 业务逻辑方法 */ public void doSomething() { System.out.println(\"Element2业务逻辑\"); } /** * @Description 访问者访问方法 * @param visitor 允许哪个访问者 */ public void accept(Visitor visitor) { visitor.visit(this); } } 抽象访问者 public interface Visitor { /** * @Description 访问对象方法 * @param element1 可以访问哪些对象 */ void visit(ConcreteElement1 element1); /** * @Description 访问对象方法 * @param element2 可以访问哪些对象 */ void visit(ConcreteElement2 element2); } 具体访问者 public class VisitorImpl implements Visitor { /** * @Description 访问对象方法 * @param element1 可以访问哪些对象 */ @Override public void visit(ConcreteElement1 element1) { element1.doSomething(); } /** * @Description 访问对象方法 * @param element2 可以访问哪些对象 */ @Override public void visit(ConcreteElement2 element2) { element2.doSomething(); } } 结构对象 public class ObjectStructure { /** * @Description 对象生成器,通过一个工厂方法模式模拟 * @return */ public static AbstractElement createElement() { Random rand = new Random(); if (rand.nextInt(100) > 50) { return new ConcreteElement1(); } else { return new ConcreteElement2(); } } } "},"DesignPatterns/adapter.html":{"url":"DesignPatterns/adapter.html","title":"适配器模式(adapter)","keywords":"","body":"适配器模式(adapter) 定义：将一个类的接口变成客户端所期待的另一种接口,从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作. 优点：让两个没有任何联系的类一起运行,增加了类的透明性,提高了类的复用度,灵活性非常好 角色： 目标角色Target：定义把其他类转换为何种接口,也就是我们的期望接口. 源角色Adaptee：被转换的角色,它是已经存在的,运行良好的类或是对象,经过适配器包装,成为一个崭新的角色. 适配器角色Adapter：把源角色转换成目标角色,通过继承和类关联的方式. 类适配器：继承源角色类并实现目标角色接口,是类间继承. public class Adapter1 extends Adaptee1 implements Target { /** * @Description 实现Target方法,通过调用Adaptee的方法 */ @Override public void request() { super.doSomething(); } } 对象适配器：实现目标角色接口,通过类的关联,耦合源角色.是对象的合成关系.(使用的场景较多) public class Adapter2 implements Target { /** 存放源角色1 */ private Adaptee1 adaptee1 = null; /** 存放源角色2 */ private Adaptee2 adaptee2 = null; /** * @Description 通过构造函数设置源角色 * @param adaptee1 源角色1 * @param adaptee2 源角色2 */ public Adapter2(Adaptee1 adaptee1, Adaptee2 adaptee2) { this.adaptee1 = adaptee1; this.adaptee2 = adaptee2; } /** * @Description 实现Target的方法,调用源角色的方法 */ @Override public void request() { this.adaptee1.doSomething(); this.adaptee2.doSomething(); } } "},"DesignPatterns/bridge.html":{"url":"DesignPatterns/bridge.html","title":"桥梁模式(bridge)","keywords":"","body":"桥梁模式(bridge) 定义：将抽象和实现解耦，使得两者可以独立地变化。 优点：抽象和实现分离,优秀的扩充能力,实现细节对客户透明 理解： 即把不变的特性留在Abstraction内,把可变的特性提取出来单独放入Implementor。 Abstraction通过引用Implementor来具有这部分可变特性,形成一个完整地事物抽象。 而Implementor通过继承来实现这部分特性的变化.而Abstraction通过继承来实现事物整体的变化。 角色： Abstraction抽象化角色：定义出该角色的行为,同时保存一个对实现化角色的引用,该角色一般是抽象类. Implementor实现化角色：它是接口或抽象类,定义角色必须的行为和属性. RefinedAbstraction修正抽象化角色：它引用实现化角色对抽象化角色进行修正. ConcreteImplementor具体实现化角色：它实现接口或抽象类定义的方法和属性. 使用场景： 不希望或不适用使用继承的场景 接口或抽象类不稳定的场景 重用性要求较高的场景 抽象化角色 public abstract class Abstraction { /** 对实现化角色的引用 */ private Implementor imp; /** * @Description 设置实现化角色 * @param imp 实现化角色 */ public Abstraction(Implementor imp) { this.imp = imp; } /** * @Description 自身行为和属性 */ public void request() { this.imp.doSomething(); } public Implementor getImp() { return this.imp; } } 实现化角色 public interface Implementor { /** * @Description 业务逻辑 */ void doSomething(); /** * @Description 业务逻辑 */ void doAnything(); } 修正抽象化角色 public class RefinedAbstraction extends Abstraction { /** * @Description 覆写构造函数 */ public RefinedAbstraction(Implementor imp) { super(imp); } /** * @Description 修正父类行为 */ @Override public void request() { super.request(); super.getImp().doAnything(); } } 具体实现化角色 public class ConcreteImplementor1 implements Implementor { /** * @Description 业务逻辑 */ @Override public void doSomething() { System.out.println(\"ConcreteImplementor1----doSomething\"); } /** * @Description 业务逻辑 */ @Override public void doAnything() { System.out.println(\"ConcreteImplementor1----doAnything\"); } } "},"DesignPatterns/builder.html":{"url":"DesignPatterns/builder.html","title":"建造者模式(builder)","keywords":"","body":"建造者模式(builder) 定义:讲一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示. 优点:封装性,容易扩展,便于控制细节风险 注意:建造者模式关注的是顺序,而工厂方法模式更多关注创建. 角色: 产品类:通常实现了模板方法模式. 抽象建造者:规范产品的组件,即规范产品制造的流程结构. 具体建造者:实现抽象类定义的方法,并且返回一组建好的对象. 导演类:负责安排已有模块的顺序,并告知建造类开始建造. 使用场景: 1.相同方法,不同执行顺序,产生不同的事件结果时. 2.多个部件或零件都可以装配到一个对象中,但是产生的运行结果又不相同时,可以使用该类. 3.产品类非常复杂,或者产品类中的调用顺序不同产生了不同的效能,这个时候使用建造者模式非常合适. 实例 产品抽象类 public abstract class CarModel{ private ArrayList sequence = new ArrayList(); protected abstract void start(); //启动 protected abstract void stop(); //停车 protected abstract void alarm(); //喇叭 protected abstract void engineBoom(); //引擎 final public void run(){ for(String tag:sequence){ switch(tag.toLowerCase()){ case \"start\" : this.start(); break; case \"stop\" : this.stop(); break; case \"alarm\" : this.alarm(); break; case \"engineBoom\" : this.engineBoom(); break; } } } final public void setSequence(ArrayList sequence){ this.sequence = sequence; } } 产品实现类 public class BenzModel extends CarModel{ protected void start(){ system.out.println(\"奔驰启动\"); } protected void stop(){ system.out.println(\"奔驰停止\"); } protected void alarm(){ system.out.println(\"奔驰喇叭\"); } protected void engineBoom(){ system.out.println(\"奔驰引擎\"); } } public class BMWModel extends CarModel{ protected void start(){ system.out.println(\"宝马启动\"); } protected void stop(){ system.out.println(\"宝马停止\"); } protected void alarm(){ system.out.println(\"宝马喇叭\"); } protected void engineBoom(){ system.out.println(\"宝马引擎\"); } } 抽象建造者 public abstract class CarBuilder{ public abstract void setSequence(ArrayList sequence); public abstract CarModel getCarModel(); } 具体建造者 public BenzBuilder extends CarBuilder{ private BenzModel benz= new BenzModel(); public CarModel getCarModel(){ return this.benz; } public void setSequence(ArrayList sequence){ benz.setSequence(sequence); } } public BMWBuilder extends CarBuilder{ private BMWModel bmw= new BMWModel(); public CarModel getCarModel(){ return this.bmw; } public void setSequence(ArrayList sequence){ this.bmw.setSequence(sequence); } } 导演类 public class Director{ private ArrayList sequence = new ArrayList(); private BenzBuilder benzBuilder = new BenzBuilder(); private BMWBuilder bmwBuilder = new BMWBuilder(); public BenzModel getABenzModel(){ this.sequence.clear(); this.sequence.add(\"start\"); this.sequence.add(\"stop\"); this.benzBuilder.setSequence(sequence); return (BenzModel)this.benzBuilder.getCarModel(); } public BenzModel getBBenzModel(){ this.sequence.clear(); this.sequence.add(\"engineBoom\"); this.sequence.add(\"start\"); this.sequence.add(\"stop\"); this.benzBuilder.setSequence(sequence); return (BenzModel)this.benzBuilder.getCarModel(); } public BMWModel getCBMWModel(){ this.sequence.clear(); this.sequence.add(\"alarm\"); this.sequence.add(\"start\"); this.sequence.add(\"stop\"); this.bmwBuilder.setSequence(sequence); return (BMWModel)this.bmwBuilder.getCarModel(); } public BMWModel getDBMWModel(){ this.sequence.clear(); this.sequence.add(\"start\"); this.bmwBuilder.setSequence(sequence); return (BMWModel)this.bmwBuilder.getCarModel(); } } "},"DesignPatterns/chain.html":{"url":"DesignPatterns/chain.html","title":"责任链模式(Chain of Responsibility)","keywords":"","body":"责任链模式(Chain of Responsibility) 定义：使多个对象都有机会处理请求,从而避免请求的发送者和接受者之间的耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,直到有对象处理它为止. 优点：把请求和处理分开. 缺点：性能慢,调试不方便. 抽象处理者 public abstract class AbstractHandler { /** 存放下一个处理者 */ private AbstractHandler nextHandler; /** * @Description 对请求作出处理 */ public final Response handleMessage(Request request) { Response response = null; if (this.getHandlerLevel().equals(request.getRequestLevel())) { response = this.echo(request); } else { if (this.nextHandler != null) { response = this.nextHandler.handleMessage(request); } else { // 当没有适当的处理者,业务自行处理 } } return response; } /** * @Description 设置下一个处理者 */ public void setNext(AbstractHandler handler) { this.nextHandler = handler; } /** * @Description 获取处理者的处等级 * @return */ protected abstract Level getHandlerLevel(); protected abstract Response echo(Request request); } "},"DesignPatterns/command.html":{"url":"DesignPatterns/command.html","title":"命令模式(command)","keywords":"","body":"命令模式(command) 定义:将一个请求封装成一个对象,从而让你使用不同的请求把客户端参数化,对请求排队或者记录请求日志,可以提供命令的撤销和恢复功能. 优点:类间接耦合,可扩展性,命令模式结合其他模式会更优秀. 缺点:命令类会很膨胀. 角色: 接受者角色：干活的角色,命令传递到这里应该被执行的. 命令角色：需要执行的所有命令都在这里声明 调用者角色：接收到命令,并执行命令. 实现: 抽象命令类 public abstract class AbstractCommand { /** 定义一个子类全局共享变量 */ protected final AbstractReceiver receiver; /** * @Description 实现类必须传入一个接收者 */ public AbstractCommand(AbstractReceiver receiver) { this.receiver = receiver; } /** * @Description 每个命令类都必须有一个执行命令的方法 */ public abstract void execute(); } 具体命令类 public class ConcreteCommand1 extends AbstractCommand { /** * @Description 设置默认接收者 */ public ConcreteCommand1() { super(new ConcreteReceiver1()); } /** * @Description 构造函数传递接收者 * @param receiver 接收者对象 */ public ConcreteCommand1(AbstractReceiver receiver) { super(receiver); } /** * @Description 每个命令类必须实现执行命令方法 */ @Override public void execute() { // 业务逻辑 this.receiver.doSomething(); } } 接收者 public class ConcreteReceiver1 extends AbstractReceiver { /** * @Description 每个接收者都必须完成的业务逻辑 */ @Override public void doSomething() { // 业务逻辑处理 System.out.println(\"receiver1 is doing Something\"); } } 调用者 public class Invoker { /** 需要执行的命令类 */ private AbstractCommand command; /** * @Description 设置命令类 */ public void setCommand(AbstractCommand command) { this.command = command; } /** * @Description 执行命令 */ public void action() { this.command.execute(); } } "},"DesignPatterns/composite.html":{"url":"DesignPatterns/composite.html","title":"组合模式(composite)","keywords":"","body":"组合模式(composite) 定义：将对象组合成树形结构以表示\"部分-整体\"的层次结构,使得用户对单个对象和组合对象的使用具有一致性. 优点：高层模块调用简单,节点自由增加 缺点：与依赖倒置原则冲突 角色 Component抽象构件角色：参加组合对象的共有方法和属性. Leaf叶子构件：其下再也没有其他分支,遍历的最小单元 Composite树枝构件：组合树枝节点和叶子节点形成一个树形结构. 使用场景：只要是树形结构,体现局部和整体的关系的时候,这种关系还可能比较深的时候考虑组合模式 安全模式：把树枝节点和树叶节点彻底分开了,胜在安全. 抽象构件 public abstract class AbstractComponent { /** 父节点 */ private AbstractComponent parent = null; /** * @Description 个体和整体都具有的共享 */ public void doSomething() { // 编写业务逻辑 } public AbstractComponent getParent() { return parent; } public void setParent(AbstractComponent parent) { this.parent = parent; } } 树枝构件 public class Composite extends AbstractComponent { /** 构件容器 */ private ArrayList componentList = new ArrayList(); /** * @Description 增加一个构件 */ public void add(AbstractComponent component) { component.setParent(this); this.componentList.add(component); } /** * @Description 删除一个构件 */ public void remove(AbstractComponent component) { this.componentList.remove(component); } /** * @Description 获取分支下的所有构件 */ public ArrayList getChildren() { return this.componentList; } } 树叶构件 public class Leaf extends AbstractComponent { } 透明模式：遵循了依赖倒转原则,方便系统进行扩展,但是不太安全. 实现：把树枝构件的方法抽象给抽象构件,树枝构件和树叶构件都实现抽象构件. "},"DesignPatterns/decorator.html":{"url":"DesignPatterns/decorator.html","title":"装饰模式(decorator)","keywords":"","body":"装饰模式(decorator) 定义：动态的给一个对象添加一些额外的职责.就增加功能来说,装饰模式相比生成子类更为灵活. 优点：装饰类和被装饰类互相不会耦合,是继承关系的替代,动态扩展实现类. 缺点：多层装饰增加了系统的复杂度. 角色: 抽象构件：是一个接口或者抽象类,定义需要被装饰的对象. 具体构件：抽象构件的实现. 装饰角色：一般是抽象类,实现抽象构件,并属性有个private的抽象构件变量 具体装饰对象：装饰角色的实现 抽象装饰类 public abstract class AbstractDecorator extends AbstractComponent { /** 被修饰者 */ private AbstractComponent component = null; /** * @Description 通过构造函数传递被修饰者 * @param component */ public AbstractDecorator(AbstractComponent component) { this.component = component; } /** * @Description 委托被修饰者执行 */ @Override public void operate() { this.component.operate(); } } 具体装饰类 public class ConcreteDecorator1 extends AbstractDecorator { /** * @Description 定义被修饰者 */ public ConcreteDecorator1(AbstractComponent component) { super(component); } private void method1() { System.out.println(\"method1 修饰\"); } /** * @Description 重写父类方法 */ @Override public void operate() { this.method1(); super.operate(); } } "},"Typora.html":{"url":"Typora.html","title":"Typora的使用","keywords":"","body":"Typora的使用 文本修饰 Ctrl+1 ~ 6 ：一级~六级标题。（#-#######） Ctrl+=：提升标题级别。 Ctrl+-：降低标题级别。 Ctrl+0：普通文本。 Ctrl+I：斜体，效果演示。（一对*） Ctrl+B：粗体，效果演示。（一对**） Ctrl+U：下划线，效果演示。（） Shift+Alt+5：删除线，效果演示。（一对~~） Highlight：高亮，==效果演示==。（一对==） Ctrl+Shift+Q：引用。（前面加上>,个数随层级增加） 表格 Ctrl+T：插入表格。（用|分隔单元格，用---分隔表头，用:表示对齐方式） |左对齐|居中 |右对齐| |:--- |:---:|---: | | | | | 列表 Ctrl+Shift+[：有序列表。（数字接英文句号，如1.） Ctrl+Shift+]：无序列表。（*或+或-） Ctrl+[：减少列表缩进。 Ctrl+]：增加列表缩进。 代码块 Ctrl+Shift+` ：行内代码块。（用一个或两个`包起来） Ctrl+Shift+K：代码区块。（用三个`包起来） 图表（代码区块写入相应的语言即可） 流程图（flow） 时序图（sequence） 甘特图（mermaid） 图片、超链接、脚注 Ctrl+Shift+I：插入图片。（![图片名称](图片地址，本地或网络 \"悬浮名称\")） Ctrl+K：超链接，效果演示。（Ctrl+左击可以跳转到该超链接） [链接文本名称](带https://的URL地址 “链接悬浮名称”) [链接文本名称](#锚点id “链接悬浮名称”) //可以再标题后面加上锚点 ## 标题2{#title2} //另一种写法（图片也有类似的写法） [百度][2] [2]http://www.baidu.com \"baidu\" [百度][] [百度]http://www.baidu.com \"baidu\" Footnotes：脚注，效果演示。1 1. 脚注内容 ↩ [^标识] [^标识]：脚注内容 其他 Superscript：上标，效果演示X^2^。（一对^） Subscript：下标，效果演示H~2~O。（一对~） Ctrl+Shift+M：行间数学区块，内填LaTeX参考。（一对$$） Inline Math：行内数学公式，内填LaTeX参考。（一对$） 参考. https://blog.csdn.net/jyfu2_12/article/details/79207643 ↩ Todo List：复选框，只能放在行首，不能省略空格。（- [ ]或者- [X]） [ ] 效果演示 [x] 效果演示 Horizontal Line：分割线。（---或者***） emoji：表情图标，如 :happy:（:emoji名称:） Table of Contents：生成内容目录。（[toc]） 软件操作快捷键 Ctrl+Shift+V：纯文本粘贴。 Ctrl+L：选中当前行。 Ctrl+D：选中当前词。 Ctrl+/：源代码模式。 Ctrl+Shift+L：显示/隐藏侧边栏。 Ctrl+Shift+1：大纲视图。 Ctrl+Shift+3：文件树视图。 F8：专注模式，除当前行都变暗。 F9：打字机模式，当前行始终处于屏幕中央。 "},"PreviewImg.html":{"url":"PreviewImg.html","title":"图片预览总结","keywords":"","body":"图片上传预览功能的实现与坑 实现方法 FileReader 原理：把file对象转换成一段data:base64的字符串，在src插入该字符串。 上传图片预览 document.getElementById('file').onchange = function(){ var file = this.files[0]; var reader = new FileReader(); // 监听reader对象的的onload事件，当图片加载完成时，把base64编码賦值给预览图片 reader.onload = function(event){ document.getElementById('img').src = event.target.result; } // 调用reader.readAsDataURL()方法，把图片转成base64 reader.readAsDataURL(file); } URL.createObjectURL 原理：创建一个 File 对象或 Blob 对象的内存URL。该URL 的生命周期和创建它的窗口中的 document 绑定。 document.getElementById('file').onchange = function(){ var file = this.files[0]; document.getElementById('img').src = URL.createObjectURL(file); } 以上两种方法也都适用于视频，区别在于需要传值到标签的src。 IE8兼容 但是！但是！但是！以上方法IE8都不支持，所以只能用ajax把图片上传到服务器，然后返回图片在服务器上的地址，把地址塞到src里去。然而接下来还有如下的这些坑： 由于ie8不支持label的for属性，考虑使用js触发input[file]控件。 但是IE下 input[file]表单控件，不能用js控制打开文件选择器，必须要手动点击才可以，否则提交表单时会报 “拒绝访问”。无奈考虑把input[file]变透明，遮住设计好的按钮。 ie8不支持opacity属性，用滤镜实现 filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0); 应用实例 身份证图片上传预览 上传图片预览 .imglabel{ width: 200px; height: 120px; line-height: 120px; text-align: center; border: 1px solid #ddd; border-radius: 3px; background-color: #f8f8f8; cursor: pointer; display: block; margin: 8px; } .imgdiv{ position: relative; width: 200px; height: 120px; border: 1px solid #ddd; border-radius: 3px; display: none; margin: 8px; } .imgdiv img{ width: 100%; height: 100%; } .imgdiv span{ position: absolute; left: 0; bottom: 0; width: 100%; color: #fff; background-color: #000; opacity: 0.5; } .imgdiv label{ display: inline-block; width: 48%; text-align: center; cursor: pointer; } + 添加正面（人像面） 重新选择 删除 + 添加反面（非人像面） 重新选择 删除 // 删除方法，清空并触发onchange function cancel(id) { document.getElementById(id).value = \"\"; document.getElementById(id).onchange(); } // 切换隐藏方法 function triggerImg(index){ if(document.getElementById('file'+index).value == \"\"){ document.getElementById('imgdiv'+index).style=\"display:none;\" document.getElementById('imglabel'+index).style=\"display:block;\" } else { document.getElementById('imgdiv'+index).style=\"display:block;\" document.getElementById('imglabel'+index).style=\"display:none;\" } } //URL.createObjectURL方式实现 document.getElementById('file1').onchange = function(){ triggerImg(\"1\"); if(this.value != \"\"){ var file = this.files[0]; document.getElementById('img1').src = URL.createObjectURL(file); } } // FileReader方式实现 document.getElementById('file2').onchange = function(){ triggerImg(\"2\"); if(this.value != \"\"){ var file = this.files[0]; var reader = new FileReader(); // 监听reader对象的的onload事件，当图片加载完成时，把base64编码賦值给预览图片 reader.onload = function(event){ document.getElementById('img2').src = event.target.result; } // 调用reader.readAsDataURL()方法，把图片转成base64 reader.readAsDataURL(file); } } "}}