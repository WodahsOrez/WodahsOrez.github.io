{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介 梳理了一部分记录总结的笔记。 "},"basic/class.html":{"url":"basic/class.html","title":"类，抽象类，接口，多态","keywords":"","body":"类，抽象类，接口，多态 一般类 类的声明与使用 修饰符 class 类名 { // 构造方法 修饰符 类名(参数列表) {} // 成员变量 修饰符 变量类型 变量名; // 成员方法 修饰符 返回类型 方法名(参数列表) {} } 类名 实例名 = new 类名(参数列表); // 创建对象实例，通过参数列表选择不同的构造方法进行初始化 实例名.变量名; // 调用成员变量 实例名.方法名(); // 调用成员方法 若不写构造方法则默认有个隐式的无参构造方法，若自定义了一个有参构造方法，则需自己定义无参构造方法。 继承 子类会继承父类可继承（看权限控制修饰符）的成员变量和成员方法。 class 子类 extends 父类 {} 单继承：extends后只能跟一个类，即一个子类只能继承一个父类。 多重继承：A继承B，B继承C，A和C是在一个继承体系中，即多重继承。 super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用，可以用this.成员变量名来避免同名。 覆盖override 子类中出现一个和父类相同的方法（参数列表，方法名）时，称子类的这个方法覆盖了父类的方法。 子类覆盖父类时，子类权限必须要大于等于父类的权限。 返回类型必须和被覆盖方法的返回类型相同或者是返回类型的子类型。 final方法不能被覆盖，static方法只能被static方法覆盖。 覆盖方法不能抛出新的检查异常，或者是抛出比被覆盖方法声明的检查异常更广泛的检查异常。 构造方法 子类不会继承父类的构造方法 如果子类没有构造方法，默认会写一个无参构造方法其内部隐式调用父类的无参构造方法。 子类的构造方法内部默认第一句是隐式的super()，除非显示的定义了super(参数)来调用父类的构造函数。 子类要使用父类有参的构造器，使用super（参数）形式，且super只能是子类构造方法内部的第一条语句。除非是第一句是this()，调用了本类的其他构造方法，且该方法第一句是super。 如果父类没有不带参数的构造方法，且子类的构造方法中又没显示的调用父类的有参构造方法，则Java编译器将报告错误。 抽象类 public abstract class Demo { public Demo() { name = \"demo\"; } private String name; public abstract String showName(); } 抽象类不可以被实例化。继承抽象类的子类必须覆盖了所有的抽象方法后，该子类才可以实例化。 抽象方法：被abstract修饰，没有具体实现，如public abstract void fn(int a);。 抽象类中有构造函数。抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象关键字不可以和那些关键字共存? private 不行 (私有后不能被子类继承) static 不行 (没有具体内容不能被创建) final 不行 (不能被覆盖) 接口 接口即是只有抽象方法和全局静态常量的特殊抽象类。 访问修饰符 interface 接口名称 [extends 其他的接口名] { // 声明变量，不写修饰符也是默认为全局静态常量 [public static final] String name; // 抽象方法，不写也是默认为public abstract [public abstract] void show(); } // 接口可以继承多个接口，如 public 接口A extends 接口B,接口C {} // 一个类可以继承一个类并实现多个接口 public class 子类 extends 父类 implements 接口A，接口B 接口不可以实例化。实现了接口的子类，覆盖了接口中所有的抽象方法后，该子类才可以实例化。否则，这个子类就是一个抽象类。 多态 简单说就是一个对象对应着不同类型。体现就是父类或者接口的引用指向其子类的对象。 多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容。 多态的弊端：前期定义的内容不能使用(调用)后期子类的特有内容。 多态的前提：1，必须有关系，继承，实现。2，要有覆盖方法。 Animal a = new Cat(); 向上转型：自动类型提升，Cat对象提升为Animal类型。但是不能使用子类的特有方法。 Cat c = (Cat)a; 向下转型：为了使用子类中的特有方法。 注意：对于转型，自始自终都是子类对象在做着类型的变化。 instanceof：用于判断对象的具体类型。只能用于引用数据类型判断。对象 instanceof 类名判断对象是否属于该类型，结果为布尔值。 多态时创建对象的执行顺序 如果静态代码块内引用了静态变量，则静态变量必须写在静态代码块之前，否则编译失败。非静态变量和构造代码块也一样。 1、父类静态变量和静态代码块（先声明的先执行）； 2、子类静态变量和静态代码块（先声明的先执行）； 3、父类的变量和代码块（先声明的先执行）； 4、父类的构造函数； 5、子类的变量和代码块（先声明的先执行）； 6、子类的构造函数。 public class Test { public static int a = 0; static {// Step 1 a = 10; System.out.println(\"静态代码块在执行a=\" + a); } {// Step 4 a = 8; System.out.println(\"非静态代码块（构造代码块）在执行a=\" + a); } public Test() { this(\"调用带参构造方法1，a=\" + a); // Step 2 System.out.println(\"无参构造方法在执行a=\" + a);// Step 7 } public Test(String n) { this(n, \"调用带参构造方法2，a=\" + a); // Step 3 System.out.println(\"带参构造方法1在执行a=\" + a); // Step 6 } public Test(String s1, String s2) { System.out.println(s1 + \"；\" + s2);// Step 5 } public static void main(String[] args) { Test t = null;// JVM加载Test类，静态代码块执行 System.out.println(\"下面new一个Test实例：\"); t = new Test(); } } 执行结果： 静态代码块在执行a=10 下面new一个Test实例： 非静态代码块（构造代码块）在执行a=8 调用带参构造方法1，a=10；调用带参构造方法2，a=10 带参构造方法1在执行a=8 无参构造方法在执行a=8 "},"basic/controlStatement.html":{"url":"basic/controlStatement.html","title":"流程控制语句","keywords":"","body":"流程控制语句 选择判断语句 if…else语句 if (布尔表达式) { 执行语句; } else if (布尔表达式) { 执行语句; …… } else { 执行语句; } switch语句 switch(expression){ case value1 : //语句 break; //可选 case value2 : //语句 break; //可选 …… default : //可选 //语句 break; //可选 } expression支持类型为int，String和枚举.(byte,short,char是通过自动转成int实现的 ) case 后的值必须与expression的数据类型相同，而且只能是常量或者字面常量。 当expression的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。 如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。 default 在没有 case 语句的值和变量值相等的时候执行。推荐写在末尾 循环结构 while语句 while( 布尔表达式 ) { //循环内容 } 当满足布尔表达式时，进入循环，执行语句，再次判断，直到不满足布尔表达式，退出循环。 do while语句 do { //代码语句 }while(布尔表达式); 先执行循环语句，然后判断布尔表达式，满足后就再次执行，反之，退出循环。 for循环语句 for(初始化; 布尔表达式; 更新) { //代码语句 } 执行顺序：初始化→布尔表达式→代码语句→更新→布尔表达式…… 初始化可以声明一个或多个循环控制变量，也可以为空 for each语句 for(声明语句 : 表达式){ //代码句子 } 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与当前循环到的数组元素的值相等。 表达式：要访问的数组名，或者是返回值为数组的方法。 continue 关键字 continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 break 关键字 break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 嵌套循环结构中，break 跳出最里层的循环结构，并且继续执行外层循环接下来的语句。 break和continue带label的用法 标签（label）：用标识符和：给代码块或是条件控制语句命名。 a:{ b: while(true) { c: for(;;) { d: if (true) { break c; } } continue b; } } break label：跳出label命名的代码块，继续执行外部的代码。 continue label：跳过label命名的循环代码块的本次循环，进入下一次循环。 注意：以上两种语句的label命名的代码块只能是包含该语句的代码块。 a: do { b: switch(1){ default: break c; //不被c包含，无法跳出 } continue c; //不被c包含，无法跳过 }while(true); c: for(;;){} "},"basic/datatype.html":{"url":"basic/datatype.html","title":"数据类型和运算符","keywords":"","body":"数据类型和运算符 标识符 由大小写字母，数字，_$组成的自定义名称，其中不能以数字开头，且不能和关键词重名。 正则表达式：^[A-Za-z_$][A-Za-z0-9_$]*$ 基础数据类型 类型 范围 备注 byte 8位(-2^7^~ 2^7^-1) short 16位(-2^15^~2^15^-1) int 32位(-2^31^~2^31^-1) long 64位(-2^63^~2^63^-1) 末尾加L float 32位(1符号8指数23尾数) 末尾加f double 64位(1符号11指数52尾数) char 16位(0~2^16^-1) boolean true/false 运算符 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + + - ！〜 从右到左 乘性 * /％ 左到右 加性 + - 左到右 移位 >> >>> 左到右 关系 >>= 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 \\ 左到右 逻辑与 && 左到右 逻辑或 \\ \\ 左到右 条件 ？： 从右到左 赋值 = + = - = * = / =％= >> = = 从右到左 逗号 ， 左到右 = > 只支持数值类型数据比较 /两个整型相除,结果强制转换为整形，正负跟随被除数。 3+\"2\"结果为\"32\"(任何和字符串相加为连接) ++在前和在后的差别: j = i++ ,j为i j = ++i,j为i+1 取余运算符 对于整数： a%b=a-(a/b)*b 操作数中有浮点数： a%b=a-(b*q),这里q=int(a/b) 例如：5%-2结果为1(5-(-2*（5/-2）)) 逻辑运算符 &和&&的差别是当&&左边判定为假时,会跳过右边判断语句,直接输出假.同理||和|. 位运算 位运算的操作数是整形数，包括int、short、long、byte和char。位运算的结果只能是int、long。 左移位： 右移位：>>，有符号的移位操作 右移操作是将运算数的二进制码整体右移指定位数，右移之后的空位用符号位补充，如果是正数用0补充，负数用1补充。 按位右移补零操作符:>>>,左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 如果操作数是char、byte、short，位运算其值自动晋升为int。 例题：对两个整数变量的值进行互换 (不需要第三方变量) ​ a = a ^ b; //a = 3 ^ 5; ​ b = a ^ b; //b = (3^5)^5; b = 3; ​ a = a ^ b; //a = (3^5)^3; a = 5; ​ （a&1） = 0 偶数 ​ （a&1） = 1 奇数 三元运算符 (条件表达式)?表达式1:表达式2 ()不是必须的 当条件表达式为true时,执行表达式1,反之,执行表达式2. 数据类型自动转换及溢出问题 规则1：低字节向高字节自动转换 byte->short->int->long->float->double 不涉及运算，例如赋值时使用。 char不可与byte，short自动转换，只能往int转，原因是char范围为正，没负，转换和被转换都会溢出 规则2：运算时，统一向涉及运算的最高字节的类型转换。byte,short,char一律转换成int。 (即同类型相加也会强制转换成int，导致赋值时报错。如： byte a = 1; byte b = 2; a = a + b;报错 a+=b不报) short s = 3; s+=4; s = s + 4; 差别是+=是赋值运算会自动判断并强制转换类型,赋值运算会直接判断后面输入数字是否溢出来报错 s = s + 4为short和int相加，结果自动转成int，int不能赋给byte所以报错。通过强制类型转换解决：s = (short)(s+4); 规则3：常量不溢出可以自动转换，溢出则不行。涉及变量，有溢出可能性就不行。 注释 注释不会被编译到class文件内 // 单行注释 /* 多行注释 */ /** *文档注释,可以使用javadoc命令导出API帮助文档 */ 标签 描述 示例 @author 标识一个类的作者 @author name @deprecated 指名一个过期的类或成员 @deprecated description @param 说明一个方法的参数 @param parameter-name explanation @return 说明返回值类型 @return explanation @see 指定一个到另一个主题的链接 @see anchor @serial 说明一个序列化属性 @serial description @serialData 说明通过writeObject( ) 和 writeExternal( )方法写的数据 @serialData description @serialField 说明一个ObjectStreamField组件 @serialField name type description @since 标记当引入一个特定的变化时 @since release @exception 标志一个类抛出的异常 @exception exception-name explanation @throws 和 @exception标签一样. The @throws tag has the same meaning as the @exception tag. @version 指定类的版本 @version 1.2 {@docRoot} 指明当前文档根目录的路径 Directory Path {@inheritDoc} 从直接父类继承的注释 Inherits a comment from the immediate surperclass. {@link} 插入一个到另一个主题的链接 {@link name text} {@linkplain} 插入一个到另一个主题的链接，但是该链接显示纯文本字体 Inserts an in-line link to another topic. {@value} 显示常量的值，该常量必须是static属性。 Displays the value of a constant, which must be a static field. "},"basic/function.html":{"url":"basic/function.html","title":"方法和数组","keywords":"","body":"方法和数组 方法 方法的定义 修饰符 返回值类型 方法名(参数类型1 参数名1，参数类型2 参数名2){ ... 方法体 ... return 返回值; } 返回值类型：如果没有返回值则写void，return后面可以不加返回值，也可是直接不写return。 参数：可以是一个或多个，也可没有。 方法的调用 方法名（实参1，实参2）; int result = sum(2,3); // 可以这样把方法有的返回值赋值给变量 方法的调用时填写的参数，必须与定义时的参数类型和顺序和个数相匹配。 方法的重载 同一个类中，相同方法名，不同参数列表（参数类型，个数，顺序不同）的方法叫做重载方法。 public class A{ public int fn(int a,double b){...} public void fn(int a,double b){...} // 返回类型不同不算重载，看做是重复定义。 public int fn(double a,int b){...} // 只是顺序不同也算重载 public int fn(double a,long b,char c){...} // 个数，类型都不同的重载 } 可变参数 适用于参数个数不确定，类型确定的情况，java把可变参数当做数组处理。 格式：变量类型... 变量名 public int fn(int x, int... args) { int sum = 0; for (int i = 0; i 可变参数的特点： 只能出现在参数列表的末尾，一个方法只能有一个可变参数。 ...位于变量类型和变量名之间，前后有无空格都可以。 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。 语义逻辑： 因为参数个数不定，所以当其后边还有相同类型参数时，java无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数必须位于最后一项。 当可变参数个数多余一个时，必将有一个不是最后一项，所以只支持有一个可变参数。 数组 // 声明数组 变量类型[] 数组名； // 常用 变量类型 数组名[]； // 也符合语法，但不常用。 // 创建数组 变量类型[] 数组名 = new 变量类型[数组大小]； // 创建空数组 变量类型[] 数组名 = new 变量类型[]{值1，值2，……}； // 根据值创建数组 变量类型[] 数组名 = {值1，值2，……}； // 根据值创建数组 数组名.length // 获得数组的大小 数组名[index] // 获取数组内对应索引的值，index为0,1，2…… // 多维数组，以二维为例，多维类推 变量类型[][] 数组名 = new 变量类型[外维大小][內维大小]; // 即每个外维元素都是一个內维大小的数组，內维大小给定就每个外维元素都一样大，也可以不写。 // 可以通过给每个外维元素单独赋值来分配不同的內维大小，如： int[][] arr = new int[2][]; arr[0] = {2,3,4}; arr[1] = {7,0,10,23,5}; "},"basic/innerClass.html":{"url":"basic/innerClass.html","title":"内部类","keywords":"","body":"内部类 成员内部类 实例内部类 创建实力内部类的实例时.外部类的实例必须已经存在. 实例内部类的实例自动持有外部类的实例的引用.可以访问外部类的所有成员变量和方法.多重嵌套中,内部类可以访问所有外部类的成员. 在外部类中不能直接访问内部类的成员,必须通过内部类的实例去访问. 实例内部类不能定义静态成员. 如果实力内部类B与外部类A包含同名的成员(如变量v),那么在类B中,this.v表示类B的成员, A.this.v表示类A的实例成员,A.v表示类A的静态成员 静态内部类 静态内部类的实例不会自动持有外部类的特定实例的引用.创建外内部类实例时可以不必创建外部类实例.如:new A.B(); 静态内部类可以直接访问外部类的静态成员,访问外部类的实例成员需通过外部类的实例去访问 静态内部类中可以定义静态成员和实例成员 可以通过A.B.v2直接访问静态内部类B的静态成员变量v2,不能通过A.B.v1访问静态内部类的实例变量v1. 局部内部类(方法内部类) 局部内部类及其内部类不能被public,private,protected和static修饰 局部内部类只能在当前方法中使用. 局部内部类不能包含静态成员 局部内部类可以访问外部类的所有成员.可以访问所在方法的final类型变量和参数,不能访问非final修饰的变量和参数(原因:局部变量的生命周期与局部内部类的对象的生命周期的不一致性!解决办法:通过将final局部变量\"复制\"一份,复制品直接作为局部内部中的数据成员,通过构造方法注入) 匿名类 匿名类本身没有构造方法，但会调用父类的构造方法。如new A（v）{}，若参数v是局部变量，则v必须为final类型 匿名类可以通过写构造代码块来实现自定义的初始化。 匿名类除了定义在方法内外还可以用在成员变量的显示初始化上。 匿名类除了可以继承类还可以实现接口 匿名类和局部内部类一样可以访问外部类的所有成员和方法内的final变量和参数。 内部类的特性 不允许内部类与外部类重名 内部类的继承 public class Sample extends Outer.Inner{ public Sample(Outer o){ o.super; } } 因为构建一个内部类的实例需要外部类的实例,所以,Sample继承Inner类时需在构造时传入一个Outer实例的引用,o.super()指的是执行o的inner内部类的构造方法. 子父类的内部类同名 和子父类的同名成员变量一样,子父类的同名内部类都是独立的,互相不影响.java编译器不会检查子类中的Inner类是否缩小了父类中的Inner类的访问权限. 内部接口 一个类中可以定义内部接口（静态非静态都可以）。 接口的静态内部类 接口中可以定义静态内部类，实现了接口的类对内部类可见（可直接调用） 非实现类必须通过接口.内部类来调用。 命名规则 内部类的class文件命名是：包名.外部类名$内部类名 匿名类的class文件命名是：包名.外部类名$由1开始的正整数-按照类装载顺序依次排列 局部内部类class文件命名是：包名.外部类名$由1开始的正整数后跟局部类名-其中数字部分是局部类在外部类上下文出现的先后顺序 "},"basic/modifier.html":{"url":"basic/modifier.html","title":"修饰符","keywords":"","body":"修饰符 修饰对象 可用修饰符（及书写顺序） 类的修饰符 public、abstract、final 构造方法 public、protected、private 方法 public、protected、private、abstract、static、final、synchronized、native 成员变量 public、protected、private、static、final、transient、volatile 局部变量 final 访问控制修饰符 访问修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N（说明） N default(friendly/包访问权限) Y Y Y N N private Y N N N N 访问控制修饰符控制的是访问被修饰者的代码所写的位置，即影响其可见范围。 访问继承的方法或成员时，其可见性范围取决于被继承的方法或成员 对于protected，不同包的子类中，只能由子类实例或子类的子类实例对象访问，不能由父类或父类的其他分支的子孙类实例对象访问。但是可以在非静态方法内由super来访问。 package p1; import P2.Son2; public class Father1 { // 可见范围为同包P1或子类中。 protected void f() {} // Father继承自Object的clone（）的可见范围为同包java.lang和Object的子类。 public static void main(String[] args) { Son2 son = new Son2(); son2.clone(); // 来源Object,不同包子类，由Father的子类实例访问，可见。 } } package p1; import P2.Son2; public class Son1 extends Father1 { public static void main(String[] args) { Son2 son = new Son2(); //son.clone(); // 来源父类，同包子类不可见。 } } package P2; import p1.Father1; public class Son2 extends Father1 { public void f() { super.f(); // 不同包子类，super访问可见。 } public static void main(String[] args) { Father1 father1 = new Father1(); //father1.f(); // 不同包子类，父类实例调用不可见。 } } package p1; import P2.Son2; public class Test { public static void main(String[] args) { Son1 son1 = new Son1(); son1.f(); // 来源Father,同包可见。 //son1.clone(); // 来源Object,不同包子类，父类其他分支子类调用不可见。 Son2 son2 = new Son2(); son2.f(); // 来源Father,同包可见。 //son2.clone(); // Compile Error，因为访问的是继承的clone(),可见性等同Object的clone()，因为不同包且非子类不可见 // 同包非子类，不可见。 } } 其他修饰符 static 静态变量：对于同一对象类型的不同对象实例，共用一个静态变量。 静态方法：内部不能使用非静态变量，不需要对象实例就能使用。 两者可以直接用类名访问，如classname.variablename 和 classname.methodname final 修饰变量：即常量，不能被重新赋值，所以必须在声明时定义初始值。 修饰方法：可以被子类继承，但不能被override。 修饰类：不能被继承。 abstract 抽象方法：没有实现内容的方法，不能被final和static修饰。子类继承后必须实现该方法，除非子类也是抽象类。拥有抽象方法的类必须声明为抽象类。 抽象类：抽象类不能实例化对象，不能被final修饰，可以同时包含抽象方法和非抽象方法，或只有其一。 "},"advanced/annotation.html":{"url":"advanced/annotation.html","title":"注解(annotation)","keywords":"","body":"注解(annotation) 内建注解 // java.lang @Override 在重写的子类方法前加上即可 @Deprecated 在已过时的程序元素前标识 @SuppressWarnings 关闭编译器对该程序元素和其所有子元素的警告 // 例: @SuppressWarnings(value =\"unchecked\"); @SuppressWarnings(value ={\"unchecked\",\"fallthrough\"});其中value =可以省略 value的常用参数有: deprecation:使用了过时程序元素 unchecked:执行了未检查的转换 unused:有程序元素未被使用 fallthrough:switch程序块直接通往下一种情况而没有break path:在类路径,源文件路径等中有不存在的路径 serial:在可序列化的类上缺少serialVersionUID定义 finally:任何finally子句不能正常完成 all:所有情况 自定义注解 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型。可以通过default来声明参数的默认值。 定义注解格式： public @interface 注解名 { 成员类型 成员名() [default 默认值]; } 成员的可支持数据类型： 所有基本数据类型（int,float,boolean,byte,double,char,long,short)及其封装类 String类型 Class类型 enum类型 Annotation类型 以上所有类型的数组(赋值时用{}) Annotation类型里面的参数该怎么设定: 只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；　 　 如果只有一个参数成员,必须把参数名称设为\"value\",后加小括号.只对value成员赋值时可以省略成员名和赋值号=,同时对多个成员赋值时,必须使用赋值号. 注解成员的默认值： 总结：成员必须有值(默认指定，使用指定)，用负数或空字符串表示成员缺失。　　 注解成员必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解成员的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个成员的存在或缺失的状态，因为每个注解的声明中，所有成员都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，以此表示某个成员不存在，在定义注解时，这已经成为一个习惯用法。 元注解 java.lang.annotation 元注解,是给注解的注解. @Target　　 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 取值(ElementType)有： CONSTRUCTOR:用于描述构造器 FIELD:用于描述域,类成员变量或常量 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） 取值（RetentionPoicy）有： SOURCE:在源文件中有效（即源文件保留）,字节码中不会有 CLASS:在class文件中有效（即class保留）,JVM中不会有 RUNTIME:在运行时有效（即运行时保留）,可以通过反射机制读取注解信息 @Inherited 作用：@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。 @Documented：此为标识符，标识该类是否出现在Javadoc中 附录：注解的自定义和使用 "},"advanced/collection.html":{"url":"advanced/collection.html","title":"集合框架和泛型","keywords":"","body":"集合框架和泛型 集合的特点有：可以存储对象不能存储基本数据类型 ，集合的长度是可变的。 collection接口 特点：不唯一，无序号 方法： 1、增加： boolean add(E e)向末尾加 boolean addAll(Collection c) 2、删除： void clear() 清空集合 boolean remove(Object o)删第一个 boolean removeAll(Collection c)删除c中包含的 boolean retainAll(Colletion c)仅保留c中的，其他都删除，交集 3、获取： int size()元素个数 Iterator iterator()返回迭代器对象 4、查找： boolean contains(Object o) contains方法是通过equals判断的。 boolean containsAll(Collection c) boolean isEmpty() 5、转换： Object[] toArray()转换为Object数组 T[] toArray(T[] a) 把collection转换成T[]数组传出 List接口 特点：不唯一，有序号 ArrayList类 特点：和数组一样采用同样的存储方式，在内存中分配连续的空间。遍历，随机访问快，删改慢。 方法： 增加：void add(int index,E e)插入，后面的后移 删除：E remove(int index) 获取：E get(int index) 从0开始 int indexOf(Object o)返回第一个索引，没有返回-1 修改：void set(int index, E element ) LinkedList类 特点：采用链表存储方式。删改快，查找慢。 方法： 增加：void addFirst(E e) void addLast(E e) 获取：E getFirst() E getLast() 删除：E removeFirst() remove() E removeLast() Vector类 方法：Enumeration elements() 返回一个 set接口 特点：唯一，无序号,也无顺序。 HashSet类 特点：非线程安全，允许元素为null。对象需重写hashCode和equals，当equals相等时必须hashCode也相等，反之则不必然。在集合中，比如HashSet中，要求放入的对象不能重复，怎么判定呢？首先会调用hashcode，如果hashcode相等，则继续调用equals，如果equals也相等，则认为重复。 方法：1、增加：boolean add(E e) 未包含则加 不存在get方法，无法用普通for循环，只能用增强for循环遍历。 TreeSet类 特点：可以对元素进行排序，不同步的。判断唯一性的方式，是根据compareTo方法的返回值，为0即相同元素，不共存。 比较方法有二种： 1、类实现comparable 2、比较器comparator,并通过构造函数加载. 自然排序:方法一,定制排序:方法二. Iterator接口 特点：凡是Collection派生的都有iterator()方法并返回Iterator对象 方法： boolean hasNext()是否有下一个元素 E next()返回下一个元素，并下移一位 void remove()删除最后返回的一个元素 Map接口 特点：key-value映射存储，key不要求有序，不允许重复，value不要求有序，允许重复 方法： 1、增加：V put(K key,V value)若key有旧value则被替代 2、删除：V remove(Object key)返回value，没有则返回null void clear() 3、获取：V get(Object key) Set(K) keySet() Collection(V) values() 4、查找：boolean containsKey(Object key) boolean containsValue(Objet value) boolean isEmpty() Set> entrySet() 获得Map内部的Entry接口对象的Set集合 内部接口：Interface Map.Entry K getKey() V getValue() V setValue(V value) default V replace(K key, V value) 当K不存在时,返回Null boolean replace(K key, V oldValue, V newValue) 当K和V匹配时,才会执行替换 HashMap类 特点：内部结构是哈希表，不同步，允许null作为键，可以作为值。 查询指定元素效率高,键自然排序 Hashtable类 特点：内部结构是哈希表，同步，不允许null作为键，可以作为值。 Properties类 特点：键和值都为字符串类型，集合中的数据可以在流中传输。 方法： Set StringPropertyNames() 返回一个key值的set集合 String getProperty(String key) 返回指定键所对应的属性 String getProperty(String key， String default) 返回指定键所对应的属性,如果没有则返回default void list(PrintStream out) 将属性列表输出到指定的输出流 void store(OutputStream out,String comments) 把properties写入到流中,comments文件属性信息可以为空 void store(Writer writer,String comments) void load(InputStream inStream) 把流的数据写入到properties void load(Reader reader) TreeMap类 特点：内部结构是二叉树，不同步，可以对键进行排序。 comparable\\接口 方法： int compareTo(T o) 返回一个负数，0，正数来表示小于，等于，大于 comparator\\接口 方法： int compare(T o1,T o2) 根据第一个参数小于，等于，大于第二个参数返回负数，零，正数。 boolean equals(Object obj) 不用重写的原因是实现类都会继承Object的equals()方法 collections类 方法： static void> sort(List list) // 对实现了comparable接口的元素的list集合进行排序 static Comparator reverseOrder() // 返回一个逆转了实现comparable的对象的自然顺序的比较器 static Comparator reverseOrder(Comparator cmp) // 返回一个指定比较器的逆转后的比较器 static int binarySearch(List> list, T key) // 查找返回索引 static void fill(List list, T obj) // 用T替换list中的所有元素 static Enumeration enumeration(Collection c) // 把Collection转换成枚举 static > T max(Collection coll) // 返回最大值(最小值换成min) static T max(Collection coll, Comparator comp) // 通过比较器返回最大值(最小值换成min) static boolean replaceAll(List list, T oldVal, T newVal) // 使用另一个值替换列表中所有的指定值 其他 对于集合内存储null List 集合可以存储null，添加几个，存储几个； Set集合也可以存储null，但只能存储一个，即使添加多个也只能存储一个； HashMap可以存储null键值对，键和值都可以是null，但如果添加的键值对的键相同，则后面添加的键值对会覆盖前面的键值对，即之后存储后添加的键值对； Hashtable不能碰null，不管是值还是键，一见null就报空指针。 线程安全的同步的类： vector：就比arraylist多了个同步化机制（线程安全） statck：堆栈类，先进后出 hashtable：就比hashmap多了个线程安全 enumeration：枚举，相当于迭代器 静态导入 在 import 后加 static 可以导入类中的静态成员. import static 包名.类名.静态成员变量; import static 包名.类名.静态成员函数; "},"advanced/generics.html":{"url":"advanced/generics.html","title":"泛型(generics)","keywords":"","body":"泛型(generics) 泛型就是把类型参数化，<>即存放类型参数的位置，T，E，K，V即变量名.泛型的实例化即类似于变量的赋值，把具体的类型名填入<>中，即相应位置处的T变成这种类型。 泛型的设计目的是用T代替Object来传入未知类型对象，而?是为了能使泛型达到协变和逆变这种关系而存在的，即使泛型类型间建立关系. 泛型类 定义泛型类的语法： 访问修饰符class className TypeList表示类型变量列表，每个类型变量之间以逗号隔开。 例如：Interface Collection 或者 Interface Map 其中E,K,V为类型变量(参数)，和变量一样，名称可以自定义。 创建泛型类的语法： className =new className(argList); argList表示实际传递的类型参数列表，同样以逗号隔开。 例如：ArrayList =new ArrayList(); 泛型的声明必写,后面可以只写<>,因为有类型推断机制。 即：ArrayList =new ArrayList<>() 泛型方法 定义泛型方法的语法： 访问修饰符 返回值 方法名 (类型参数列表) 类型参数放在访问修饰符的后面，返回类型的前面.泛型类的静态方法如果想用泛型，必须重新定义成泛型方法。 例如：public void showName (T t){ } 泛型方法的使用: 例如:对象.showNam(name) 写在方法名前面,这样编译器可以判断name是否为String 有足够条件判断时,泛型方法前的<>可以省略. 泛型方法使用时如果加<>前面必须要有对象.或者类名.或this.super.无论是否在同一个类里 泛型参数 泛型参数 泛型直接放在方法的参数列表里,(静态方法必须定义成泛型方法) 例如: public void show(List list) 任意情况都可用 public void show(List list) 必须在泛型类里使用 public static void show(List list) 可以不定义成泛型方法 public static void show(List list) 必须定义成泛型方法,不管是否在泛型类里 泛型的限定： 上限：extends表示继承或实现或两者皆有，后面可以有一个类和多个接口，类必须在前。 语法： 下限： 没有T super XXX的写法,只能用? super XXX 通配符类型： 例如：public static void printBuddies(Pair p) 如何理解 Java 中的 > 泛型的擦除，不用泛型时，用的是原始类型，无限定类型用Object，详见P534. 方法参数重写 public static void getData(List data) public static void getData(List data) public static void getData(List data) 这三种方法是同一个方法,即参数视为一致,无法看做重载. 泛型T和?的差别 T只能在泛型类或泛型方法中使用,而和其上下限可以在任何情况下使用,即普通方法和类的任意位置使用. 这种情况下的List list 中,由于list存在不确定性,不能用list.add()添加任意元素.只能用list =new ArrayList();给其赋值. T是用在定义泛型的,而?是在定以后的泛型使用时对其T参数进行范围限制的存在.即先有T后有? T extends 是对T进行必要的属性解释, 而T super没有意义所以不存在. 泛型无法向上转型 Info i1 = new Info() ; // 泛型类型为String Info i2 = null ; i2 = i1 ; //这句会出错 incompatible types 通配符 即等效于用于拓展用的情况,使其能兼容更多类型 List是List的父类 协变 List是List的父类 逆变 通配符上限写入的情况 public class Wildcard { public static void main(String[] args) { List list = new ArrayList(); getData(list); } public static void getData(List list){ System.out.println(\"data:\" + list.get(0)); list.add(12); 不能写入 list.add(new Object()); 不能写入 } } 因为List可能是List或List,所以为避免出现不能写入所以一律不能写入任意对象,在里适用这个规则 通配符下限写入的情况 public class Wildcard { public static void main(String[] args) { List list = new ArrayList(); getData(list); } public static void getData(List list){ System.out.println(\"data:\" + list.get(0)); list.add(12); 可以写入 list.add(new Object()); 可以写入 } 由于有下限,所以下限及其子类都能写入而不用担心因为不确定性而产生错误. 通配符讲解很详细. “捕获助手” 方法 public void rebox(Box box) { reboxHelper(box); } private void reboxHelper(Box box) { box.put(box.get()); } 解析:Box返回的是一个Object,而Box返回的是V 存取原则和PECS法则 总结 ? extends 和 the ? super 通配符的特征，我们可以得出以下结论： 如果你想从一个数据类型里获取数据，使用 ? extends 通配符 如果你想把对象写入一个数据结构里，使用 ? super 通配符 如果你既想存，又想取，那就别用通配符。 PECS是指”Producer Extends, Consumer Super” 参考： 协变逆变 java泛型简明教程 泛型代码 通配符 "},"advanced/IO.html":{"url":"advanced/IO.html","title":"输入输出流","keywords":"","body":"输入输出流 字节流 特点：最小操作单位为字节(byte) InputStream抽象类 方法： int read()从输入流读取下一个字节，返回0~255的值 int read(byte[] b)从输入流读取一堆字节，存储在b中,返回值为数组的长度。 int read(byte[] b, int off, int len)off为开始存储字节的数组下标，len为读到的字节个数。 void close()关闭流 int available() 可以从输入流中读取的剩余字节长度。while(dis.available()>0) BufferedInputStream类 构造方法： BufferedInputStream(InputStream in) FileInputStream类 构造方法：FileInputStream(File file) FileInputStream(String pathname) SequenceInputStream类 特点：按顺序合并若干个流。 构造函数： SequenceInputStream( Enumeration e) SequenceInputStream(InputStream s1,InputSteam s2) ObjectInputStream类 构造方法：ObjectInputStream(InputStream in) PipedInputStream类 特点：配合PipedOutputStream使用，避免两者在同一线程，会死锁。 构造方法：PipedInputStream(PipedOutputStream src) 方法： void connect(PipedOutputStream src) 联系两者 DataInputStream类 特点：写入基本数据类型 构造方法： DataInputStream(InputStream in) 方法：String readUTF() 修改版UTF-8格式读取 OutputStream抽象类 方法： void write(int c) void write(byte[] buf) void write(byte[] b, int of, int len) void close() void flush()强制把缓冲区的数据写到输出流中,写入得时候只是把数据写入到当前流类的缓冲区内,而没有写入到流所指向的文件或者其他流中,所以需要flush以写入到目标源 FileOutputStream类 构造方法： FileOutputStream(File file) FileOutputStream(String name) FileOutputStream(String name, boolean append) 前两种构造方法在向文件写数据的时将覆盖文件中原有的内容，FileOutputStream实例时， 如果文件不存在，则自动生成一个空的文件。如果路径不存在则报异常 PrintStream类 特点：永远不会抛出IOException 构造函数： PrintStream(File file) PrintStream(OutputStream out) PrintStream(String fileName) 方法： void print(基础数据类型) // 包括：boolean,char,char[],double,float,int,long,String,Object,保持数据的表现形式。 void write(int b) //写入字节码为b的值，只保留int的后8位。 BufferedOutputStream类 构造方法： BufferedOutputStream(OutputStream out) 方法： void flush() ObjectOutputStream类 构造：ObjectOutputStream(OutputStream) 方法：void writeObject(Object obj) 对象必须实现Serializable接口 PipedOutputStraem类 构造方法：PipedOutputStream(PipedInputStream snk) 方法： void connect(PipedInputStream snk) DataOutputStream类 构造方法：DataOutputStream(OutputStream out) 方法：void writeUTF(String str) 修改版UTF-8格式写入 字符流 特点：最小处理单元为2个字节的Unicode字符。有缓冲区。处理文字意外的数据会出错。 Writer抽象类 方法： abstract void flush() 刷新流，把缓冲区的内容写入到目标文件 abstract void close() 关闭流，会先执行flush后关闭流。 void writer(char[] cbuf) void write(char[] cbuf, int off, int len) off为起始位置，len为长度。 void write(int c) 写入编号为c的字符。 void write(String str) void write(String str, int off, int len) 写入字符串，off为起始下标，len为长度。 BufferedWriter类 构造函数：BufferedWriter(Write out) 创建一个缓冲输入流，效率高 方法： void newLine() 新建一个依据系统的换行 void close() Writer也会被关闭 OutputStreamWriter类 构造方法： OutputStreamWriter(OutputStream out) OutputStreamReader(OutputStream in, Charset cs) Charset为编码表,如\"GBK\",\"gbk\",\"utf-8\" FileWriter类 构造方法： FileWriter(File file) FileWriter(String fileName) 如果不存在则自动创建，如果存在则会被覆盖。 FileWriter(String fileName, boolean append) append为true时，可以续写。 PrintWriter类 构造方法： PrintWriter(File file) PrintWriter(OutputStream out) 可选项boolean autoFlush.printf,println,format方法将自动刷新 PrintWriter(String fileName) PrintWriter(Writer out) 可选项boolean autoFlush.printf,println,format方法将自动刷新 reader抽象类 方法： int read() 返回一个字符的号码0~65535，当到达末尾时返回-1 int read(char[] cbuf) 返回读取的个数，没有读取到或末尾则返回-1 // 例：条件:文件为\"abcde\",buf为char[3]. int num = fr.read(buf); System.out.println(num + \":\"+new String(buf)): //输出3:abc 读取了三个字符，分别写入buf数组 int num1 = fr.read(buf); System.out.println(num1 + \":\"+new String(buf)): //输出2:dec 读取了两个字符，覆盖了buf[0]和buf[1] int num2 = fr.read(buf); System.out.println(num2 + \":\"+new String(buf)): //输出-1:dec 没读取到字符，返回-1 BufferedReader类 构造函数： BufferedReader(Reader in) 方法： String readLine()读取一行文本，不包括换行符。没有下一行返回null,若没有换行符则会阻塞 InputStreamReader类 构造函数： InputStreamReader(InputStream in) InputStreamReader(InputStream in, Charset cs) Charset为编码表,如\"GBK\",\"gbk\",\"utf-8\" FileReader类 构造方法： FileReader(File file) 如果不存在，抛出异常 FileReader(String fileName) LineNumberReader类 构造方法： LineNumberReader(Reader in) 方法： int getLineNumber() 获取行号++ void setLineNumber(int lineNumber) 设置行号 String readLine() 读一行 Serializable接口 默认会计算出一个序号用以判断序列化反序列化时对象是否有改变。 建议显式声明一个Static final long的序列号，以避免默认生成高敏感性带来的问题。 序列化和反序列化 把对象转换为字节序列的过程称为对象的序列化。 把字节序列恢复为对象的过程称为对象的反序列化。 RandomAccessFile类 特点：只能对文件进行操作。综合了输入和输出流。如果文件不存在，则创建，如果存在，不创建，使用原文件。用于多线程输出。 构造方法： RandomAccessFile(File file,String mode) mode为r只读，rw读写 RandomAccessFile(String name ,String mode) 以name为路径的文件名 方法： long getFilePointer() 返回当前指针的位置 void seek(long pos) 设置指针的位置 装饰设计思想 BufferedWriter就是一种装饰类，运用的是装饰设计，与继承的差别在于，对于同一个功能的拓展，继承需要对每个子类都进行继承，会使体系越来越臃肿。而装饰只需要对父类或接口进行关联，就可以应用于所有子类，更灵活。 总结：装饰类比继承灵活。装饰类和被装饰类都必须所属同一个接口或父类。 阻塞式方法：必须等待输入数据可用或者检测到输入结束或者抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。 将Iterator和Enumeration转换 ArrayList a1 = new ArrayList(); Iterator it = a1.iterator(); //匿名类重写方法。用Iterator的方法来实现。 Enumeration = new Enumeration(){ public boolean hasMoreElements(){ return it.hasNext(); } public FileInputStream nextElement(){ return it.next(); } } ; Java 8更加智能：如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰。 流的read方法都是阻塞的:即流内没有内容时会一直等待. "},"advanced/string.html":{"url":"advanced/string.html","title":"String类","keywords":"","body":"String类 String类 字符串对象一旦被初始化就不会被改变。 String s = \"abc\";//创建一个字符串对象在常量池中。 String s1 = new String(\"abc\");//创建两个对象一个new一个字符串对象在堆内存中。 System.out.println(s.equals(s1)); //string类中的equals复写Object中的equals建立了string类自己的判断字符串对象是否相同的依据。 //其实就是比较字符串内容。 获取 // 获取字符串中字符的个数(长度). int length(); // 根据位置获取字符。 char charAt(int index); // 根据字符获取在字符串中的第一次出现的位置 int indexOf(int ch) int indexOf(int ch,int fromIndex) // 从指定位置进行ch的查找第一次出现位置 int indexOf(String str); int indexOf(String str,int fromIndex); // 根据字符串获取在字符串中的第一次出现的位置. int lastIndexOf(int ch) int lastIndexOf(int ch,int fromIndex) // 从指定位置进行ch的反向查找第一次出现位置 int lastIndexOf(String str); int lastIndexOf(String str,int fromIndex); // 获取字符串中一部分字符串。也叫子串. String substring(int beginIndex, int endIndex) //包含begin 不包含end 。 String substring(int beginIndex); 转换 // 将字符串变成字符串数组(字符串的切割) String[] split(String regex):涉及到正则表达式. \"\\\\s+ \"可以切割多个空格 // 将字符串变成字符数组。 char[] toCharArray(); // 将字符串变成字节数组。 byte[] getBytes(); // 将字符串中的字母转成大小写。 String toUpperCase():大写 String toLowerCase():小写 // 将字符串中的内容进行替换 String replace(char oldch,char newch); String replace(String s1,String s2); // 将字符串两端的空格去除。 String trim(); // 将字符串进行连接 。 String concat(string); 判断 // 两个字符串内容是否相同啊？ boolean equals(Object obj); boolean equalsIgnoreCase(string str); // 忽略大写比较字符串内容。 // 字符串中是否包含指定字符串？ boolean contains(string str); // 字符串是否以指定字符串开头。是否以指定字符串结尾。 boolean startsWith(string); boolean endsWith(string); 比较 int compareTo(string) // 逐个比较字符的Unicode值，短的比长的小。小返回负数，大返回正数，相同返回0 String s2 = s1.intern(); // 返回一个和s1相同的池中的字符串，如果没有则在池中创建并返回 连接 String concat(String str) // 返回一个连接的字符串。 // String 虽然是引用类型，但在参数传递时，都是创建新的String对象，对原对象的引用不会造成改变。 public String replaceAll(String regex,String replacement) // $引用已捕获的序列例子引用已捕获的序列,例如: str.replaceAll(\"(.)\\\\1+\", \"$1\"); // \"\\\\1\" 是对于(.)的引用 StringBuffer 就是字符串缓冲区。用于存储数据的容器。 特点 长度的可变的。 可以存储不同类型数据。 最终要转成字符串进行使用。 可以对字符串进行修改。 方法 // 添加： StringBuffer append(data); StringBuffer insert(index,data); //（插入，不会覆盖该位置的原有数据） // 删除： StringBuffer delete(start,end) // 包含头，不包含尾。 StringBuffer deleteCharAt(int index) // 删除指定位置的元素 // 查找： char charAt(index); int indexOf(string); int lastIndexOf(string); // 修改： StringBuffer replace(start,end,string); void setCharAt(index,char); jdk1.5以后出现了功能和StringBuffer一模一样的对象。就是StringBuilder 不同的是： StringBuffer是线程同步的。通常用于多线程。 StringBuilder是线程不同步的。通常用于单线程。 它的出现是为了提高效率。 unicode编码范围： 汉字：[0x4e00,0x9fa5]（或十进制[19968,40869]） 数字：[0x30,0x39]（或十进制[48, 57]） 小写字母：[0x61,0x7a]（或十进制[97, 122]） 大写字母：[0x41,0x5a]（或十进制[65, 90]） "},"advanced/thread.html":{"url":"advanced/thread.html","title":"多线程","keywords":"","body":"多线程 Runnable接口 方法：void run() 重写该抽象方法来实现多线程 Thread类 构造函数： Thread() Thread(String name) Thread(Runnable target) Thread(Runnable target, String name) 方法： void run() void start() 运行该线程 String getName() 获取线程的名字，Thread-编号(从0开始) ，主线程名字为main int getPriority() 获取优先级 void setPriority(int newPriority) 设置优先级1~10，默认为5 void join() 直到用该方法的线程死亡前一直等待。(在A的线程中间调用B.join()，则直到B结束A才会运行) static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠（代码所在的线程休眠，实例调用也一样） boolean isAlive() 当前线程是否处于活跃状态(线程执行结束后的状态返回false) Thread.State getState() 返回一个State枚举常量 static Thread currentThread() 返回一个当前线程对象。 void interrupt() 把当前线程从阻塞状态中恢复到可执行状态 static void yield() 当前线程释放执行权限,进行新一轮的权限争夺 同步代码块的格式： synchronized(对象) { 需要被同步的代码； } 同步函数的锁是this，静态同步函数的锁是字节码对象(*.class/this.getClass) Object类里的线程通信方法: void wait() 让当前线程冻结,并释放锁 void wait(long timeout,) void wait(long timeout,int nanos)分别是毫秒和纳秒,(当纳秒>500,000时,timeout++) void notify() 唤醒一个当前对象线程池中的线程(任意) void notifyAll() 唤醒当前对象线程池中所有的线程 java.util.concurrent.locks Lock接口 方法: void lock() 当前线程获取锁, void unlock() 当前线程释放锁. Condition newCondition() 返回监视器对象 ReentrantLock类 ReentrantLock() Condition接口 方法: void await() void signal() void signalAll() "},"advanced/usefulClass.html":{"url":"advanced/usefulClass.html","title":"实用类","keywords":"","body":"实用类 枚举类 方法： boolean hasMoreElements() E nextElement() 枚举 枚举是定义的类，{}里的是它的实例，所以比较值时应该用==，不要用equals public enum Size {SMALL,MEDIUM,LARGE,EXTRA_LARGE}; 枚举里也可以有构造函数和方法和域。当有这些时，枚举常量列表用豆号隔开，最后一定要有分号。 public enum Size{ SMALL(\"S\"),MEDIUM(\"M\"),LARGE(\"L\"),EXTRA_LARGE(\"XL\"); private String abbreviation; private Size(String abbrevation) {this.abbrevation = abbrevation;} 构造必为私有 publc String getAbbrecvation() {return abbrevation; } } 枚举值可以看成是 public static final Size SMALL = new Size(\"S\"); System类 成员变量： static InputStream in static PrintStream out 方法： static long currentTimeMillis() 获取当前时间的毫秒值 static Properties getProperties() 获取当前系统的属性信息 static String getProperty(String key) 返回键值对应的属性信息。 Runtime类 特点：没有构造方法，只能通过getRuntime()获得实例，且只有一个，是一个单例设计。 方法： static Runtime getRuntime() 返回与当前运行java程序相关的Runtime对象。 Process exec(String command) 执行指定的字符串命令，并返回进程。 举例： Runtime r = Runtime.getRuntime(); Process p = r.exec(\"notepad.exe c:\\\\RuntimeDemo.java\"); Thread.sleep(5000); p.destory(); 关闭进程 Math类 方法： static int abs(int a) 绝对值，输入什么类型返回什么类型，同样的还有double,float,long static double ceil(double a) 返回大于或等于参数的最小整数(进1) static double floor(double a) 返回小于或等于参数的最小整数(去尾) static long round(double a) static int round(float a) 四舍五入 max和min为比较两个数的大小，支持double,float,in,long static double pow(doube a, double b)a的b次幂 static double random()返回一个0.0~1.0的数 Random类 特点：用同一个种子值来初始化两个Random 对象，然后用每个对象调用相同的方法，得到的随机数也是相同的。 构造方法：Random() 或 Random(long seed) 用种子生成随机对象。 方法： int nextInt(int bound) 返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值bound（不包括）之间均匀分布的 int 值。 int nextInt() 返回一个伪随机数，-2^31~2^31 Math.abs(new Random().nextInt()) % 52 表示取0~51的随机数。 date类 构造方法： Date date = new Date();//将当前日期和时间封装成Date对象。空参构造 Date date2 = new Date(1335664696656l);//将指定毫秒值封装成Date对象 long型带参构造 方法: long getTime() 返回毫秒值 void setTime(long time) 设置Date对象的时间 String toString() 格式：dow mon dd hh:mm:ss zzz yyyy dow星期 zzz时区 DateFormat类 方法： static DateFormat getDateInstance(int style)返回日期格式器 static DateFormat getDateTimmeInstance(int style)返回日期时间格式器，风格FULL,LONG,MEDIUM,SHORT. String format(Date date)格式化并返回字符串 Date parse(String source)按DateFormat对象格式，解析成date对象。 SimpleDateFormat类 特点：可以自定义风格 构造方法：SimpleDateFormat(String pattern) 自定义格式规则 年y月M日d 时H分m秒s Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year (context sensitive) Month July; Jul; 07 L Month in year (standalone form) Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, ..., 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST;GMT-08:00 Z Time zone RFC 822 time zone -800 X Time zone ISO 8601 time zone -08; -0800; -08:00 Calendar类 方法： int get(int field)返回对应成员变量的值。 static Calendar getInstance()无法通过构造函数创建对象，只能用此方法。 void set(int field, int value) void set(int year, int month, int date) void set(int year, int month, int date, int hourOfDay, int minute) void set(int year, int month, int date, int hourOfDay, int minute, int second) abstract void add(int field, int amount) 偏移相应field的时间,用+-表示前后 Calendar 的 month 从 0 开始，也就是全年 12 个月由 0 ~ 11 进行表示。 而 Calendar.DAY_OF_WEEK 定义和值如下： Calendar.SUNDAY = 1 Calendar.MONDAY = 2 Calendar.TUESDAY = 3 Calendar.WEDNESDAY = 4 Calendar.THURSDAY = 5 Calendar.FRIDAY = 6 Calendar.SATURDAY = 7 包装类 装箱：基本类型转换为包装类的对象 拆箱：包装类对象转换为基本类型的值 Type：Byte，Boolean，Short，Character，Integer，Long，Float，Double 构造方法： Type(type value) Type(String value) Boolean类时，若该字符串内容为true(不考虑每个字母的大小写)，则该Boolean对象表示true。否则都表示false. 当Number包装类构造方法参数为String 类型时，字符串不能为null，且该字符串必须可解析为相应的基本数据类型的数据，否则编译通过，运行时NumberFormatException异常。 方法： type typeValue() type换成对应的基本数据类型 String toString() 返回对象的字符串形式 public static String toString(type i) 返回i的字符串形式 public static type parseType(String type) 把字符串转换成对应的基本数据类型，(Character除外)不匹配会抛NumberFormatException异常 public static Type valueOf(type value) 所有类都有，基本类型转换为包装类 public static Type valueOf(String s) 除Character外都有，匹配的字符串转换为包装类 基本类型和包装类的自动转换 //装箱 Integer intObject = 5; //拆箱 int intValue3 = intObject; File类 成员变量： static String pathSeparator 多个路径之间分隔符，UNIX为：，windows为； static char pathSeparatorChar static String separator 路径分隔符,UNIX为'/', windows为'\\\\' static char separatorChar 构造方法： // File(File parent, String child) File f = new File(\"c:\\\\\"); File f1 = new File(f,\"a.txt\"); // File(String pathname) File f2 = new File(\"c:\\\\a.txt\"); // 相对路径也可以,相对于class所在的文件夹(jvm产生的路径) File (String parent, String child) File f3 = new File(\"c:\\\\\", \"a.txt\"); // File(URI uri) 方法： 获取 String getPath() 相对路径,相对于当前路径 String getAbsolutePath() 绝对路径 String getName() long lastModified() 返回最后一次修改时间的毫秒数 long length() 返回文件长度，单位为字节，不存在则返回0L 创建与删除 boolean createNewFile() 创建名称得的空文件，不能创建文件夹，即无目录时报异常。文件存在时返回false boolean mkdir() 一级目录 boolean mkdirs() 多级目录 boolean delete() 删除文件或目录，目录内有文件时无法删除。 判断 boolean exists() 文件或目录是否存在 boolean isFile() 是否是文件，存在且是文件返回true boolean isDirectory() 是否是目录，存在且是目录返回true 重命名 boolean renameTo(File dest) // 重命名此抽象路径名表示的文件。可以重命名路径实现剪切。dest为指定文件的新抽象路径名 其他 static File[] listRoots() 获取系统根目录的File数组 long getFreeSpace() 获取此抽象路径指定的分区的剩余可用空间 long getTotalSpace() 获取此抽象路径指定的分区的总容量 long getUsableSpace() 获取此抽象路径指定的分区的可用于虚拟机的字节数 获取文件和目录 String[] list() // 获取当前目录下的文件以及文件夹名称的数组，包含隐藏文件。 // 如果抽象路径为文件或者为系统隐藏目录时，返回null。 // 如果目录内没内容，则会返回一个长度为0的数组。 String[] list(FilenameFilter filter) // 返回符合过滤器的boolean accept(File dir，String name)的文件名或目录名。 File[] listFiles() File[] listFiles(FileFilter filter) File[] listFiles(FilenameFilter filter) "},"javaWeb/ELexperssion.html":{"url":"javaWeb/ELexperssion.html","title":"EL(表达式语言)","keywords":"","body":"EL(表达式语言) EL是JSP内置的表达式语言 jsp2.0开始，不让再使用java脚本，而是使用el表达式和动态标签来替代java脚本！ EL替代的是，也就是说，EL只能做输出！ 如果希望忽略某个EL表达式，可以在EL表达式之前添加“\\”，例如：${1 + 2}。 下标写法：${initParam['a']}等效于${initParam.a},且当属性名包含\"_\"时必须用下标写法 EL内置对象 EL一共11个内置对象，无需创建即可以使用。这11个内置对象中有10个是Map类型的，最后一个是pageContext对象不是map。 四大域相关内置对象 ${xxx}，全域查找名为xxx的属性(顺序为page,request,session,application)，如果不存在，输出空字符串，而不是null。 ${pageScope.xxx}、${requestScope.xxx}、${sessionScope.xxx}、${applicationScope.xxx}，指定域获取属性 请求参数和头相关内置对象 param：Map类型,适用于单值的参数。 paramValues：Map类型,适用于多值的参数。 header： Map类型，适用于单值请求头 headerValues：Map类型，适用于多值请求头 initParam：Map类型,获取内的参数！ xxx XXX yyy YYY 例如：${initParam.xxx} 其他内置对象 cookie：Map类型，其中key是cookie的name，value是cookie对象。${cookie.username.value} pageContext：它是PageContext类型！${pageContext.request.contextPath} javaBean导航 使用el获取request域的emp ${requestScope.emp.address.street }等效于request.getAttribute(\"emp\").getAddress().getStreet() request的emp(对象)属性的address(对象)属性的street(对象)属性,这里指的是javaBean里的属性,用get方法实现 EL函数库（由JSTL提供的） 导入标签库： String toUpperCase(String input)：把参数转换成大写 String toLowerCase(String input)：把参数转换成小写 int indexOf(String input, String substring)：从大串，输出小串的位置！ boolean contains(String input, String substring)：查看大串中是否包含小串 boolean containsIgnoreCase(String input, String substring)：忽略大小写的，是否包含 boolean startsWith(String input, String substring)：是否以小串为前缀 boolean endsWith(String input, String substring)：是否以小串为后缀 String substring(String input, int beginIndex, int endIndex)：截取子串 String substringAfter(String input, String substring)：获取大串中，小串所在位置后面的字符串 substringBefore(String input, String substring)：获取大串中，小串所在位置前面的字符串 String escapeXml(String input)：把input中“\"、\"&\"、\"'\"、\"\"\"，进行转义 String trim(String input)：去除前后空格 String replace(String input, String substringBefore, String substringAfter)：替换 String[] split(String input, String delimiters)：分割字符串，得到字符串数组 int length(Object obj)：可以获取字符串、数组、各种集合的长度！ String join(String array[], String separator)：联合字符串数组！ 自定义函数库 写一个java类，类中可以定义0~N个方法，但必须是static，而且有返回值的 在WEB-INF目录下创建一个tld文件 fun //方法名 cn.itcast.fn.MyFunction //方法所在类 java.lang.String fun() //方法签名 在jsp页面中导入标签库 在jsp页面中使用自定义的函数：${it:fun() } EL中的基础操作符 EL表达式支持大部分Java所提供的算术和逻辑操作符： 操作符 描述 . 访问一个Bean属性或者一个映射条目 [] 访问一个数组或者链表的元素 ( ) 组织一个子表达式以改变优先级 + 加 - 减或负 * 乘 / or div 除 % or mod 取模 == or eq 测试是否相等 != or ne 测试是否不等 测试是否小于 > or gt 测试是否大于 测试是否小于等于 >= or ge 测试是否大于等于 && or and 测试逻辑与 \\ \\ or or 测试逻辑或 ! or not 测试取反 empty 测试是否空值 "},"javaWeb/JDBC.html":{"url":"javaWeb/JDBC.html","title":"JDBC(Java数据库连接）","keywords":"","body":"JDBC(Java数据库连接） JDBC 编程步骤 加载驱动程序： Class.forName(driverClass) //加载MySql驱动 Class.forName(\"com.mysql.jdbc.Driver\") //加载Oracle驱动 Class.forName(\"oracle.jdbc.driver.OracleDriver\") 原理： 利用加载class文件执行static代码 所有的java.sql.Driver实现类，都提供了static块，块内的代码就是把自己的对象传给DriverManager.registerDriver(对象)方法来注册. jdbc4.0后每个驱动jar包中，在META-INF/services目录下提供了一个名为java.sql.Driver的文件,内容就是该接口的实现类名称.会自动获取该实现类并加载,所以可以省略第一步. 获得数据库连接： //方法Connection getConnection(URL,username,password) Connection con=DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb3\", \"root\", \"root\"); //MySQL的URL格式 jdbc:mysql://主机名或IP地址：端口号/数据库名?useUnicode=true&characterEncoding =UTF-8 创建Statement/PreparedStatement对象： //创建Statement Statement stat = con.createStatement(); //发送DML或者DDL的sql语句 String sql =\"INSERT INTO stu VALUES('ITCAST_003','zhangsan',88,'male')\" //不加; int r = stat.executeUpdate(sql) //r为影响的行数 //发送DQL语句 ResultSet rs = stmt.executeQuery(\"SELECT * FROM stu\"); //解析ResultSet while(rs.next()) {//把光标向下移动一行，并判断下一行是否存在(初始在beforeFirst) int empno = rs.getInt(1);//通过列编号来获取该列的值！ String ename = rs.getString(\"ename\");//通过列名称来获取该列的值 double sal = rs.getDouble(\"sal\"); System.out.println(empno + \", \" + ename + \", \" + sal); } 关闭资源： rs.close(); stmt.close(); con.close(); 例子 public void fun3() throws Exception { Connection con = null;// 定义引用 Statement stmt = null; ResultSet rs = null; try { /* * 一、得到连接 */ String driverClassName = \"com.mysql.jdbc.Driver\"; String url = \"jdbc:mysql://localhost:3306/exam\"; String username = \"root\"; String password = \"123\"; Class.forName(driverClassName); con = DriverManager.getConnection(url, username, password);// 实例化 /* * 二、创建Statement */ stmt = con.createStatement(); String sql = \"select * from emp\"; rs = stmt.executeQuery(sql); rs.last();// 把光标移动到最后一行 System.out.println(rs.getRow()); rs.beforeFirst(); /* * 三、循环遍历rs，打印其中数据 * * getString()和getObject()是通用的！ */ // while(rs.next()) { // System.out.println(rs.getObject(1) + \", \" // + rs.getString(\"ename\") + \", \" + rs.getDouble(\"sal\")); // } int count = rs.getMetaData().getColumnCount(); while (rs.next()) {// 遍历行 for (int i = 1; i JDBC对象 DriverManager类 方法： Class.forName(“com.mysql.jdbc.Driver”);//注册驱动 String url = “jdbc:mysql://localhost:3306/mydb1”; String username = “root”; String password = “123”; Connection con = DriverManager.getConnection(url, username, password); 注意，上面代码可能出现的两种异常： ClassNotFoundException：在第1句上出现，原因可能有两个： 你没有给出mysql的jar包； 你把类名称打错了，查看类名是不是com.mysql.jdbc.Driver。 SQLException：出现在第5句，出现这个异常就是三个参数的问题，往往username和password一般不是出错，所以需要认真查看url是否打错。 对于DriverManager.registerDriver()方法了解即可，因为我们今后注册驱动只会Class.forName()，而不会使用这个方法。 Connection接口 方法: Statement stmt = con.createStatement(); 获取Statement Statement stmt = con.createStatement(int,int); Statement接口 方法： int executeUpdate(String sql)：执行更新操作，即执行insert、update、delete语句，其实这个方法也可以执行create table、alter table，以及drop table等语句，但我们很少会使用JDBC来执行这些语句； ResultSet executeQuery(String sql)：执行查询操作，执行查询操作会返回ResultSet，即结果集。 boolean execute() 这个方法可以用来执行增、删、改、查所有SQL语句。该方法返回的是boolean类型，表示SQL语句是否有结果集。 如果使用execute()方法执行的是更新语句，那么还要调用int getUpdateCount()来获取insert、update、delete语句所影响的行数。 如果使用execute()方法执行的是查询语句，那么还要调用ResultSet getResultSet()来获取select语句的查询结果。 ResultSet接口 ResultSet表示结果集，它是一个二维的表格。ResultSet内部维护一个行光标（游标） 游标控制判断方法 void beforeFirst()：把光标放到第一行的前面，这也是光标默认的位置； void afterLast()：把光标放到最后一行的后面； boolean first()：把光标放到第一行的位置上，返回值表示调控光标是否成功； boolean last()：把光标放到最后一行的位置上； boolean isBeforeFirst()：当前光标位置是否在第一行前面； boolean isAfterLast()：当前光标位置是否在最后一行的后面； boolean isFirst()：当前光标位置是否在第一行上； boolean isLast()：当前光标位置是否在最后一行上； boolean previous()：把光标向上挪一行； boolean next()：把光标向下挪一行； boolean relative(int row)：相对位移，当row为正数时，表示向下移动row行，为负数时表示向上移动row行； boolean absolute(int row)：绝对位移，把光标移动到指定的行上,正数第一行(1)开始,负数最后一行(-1)开始,超出范围分别为afterLast和beforeFirst,这两者返回false int getRow()：返回当前光标所在行。beforeFirst为0 获取结果集元数据 得到元数据：rs.getMetaData()，返回值为ResultSetMetaData,其方法有: 获取结果集列数：int getColumnCount() 获取指定列的列名：String getColumnName(int colIndex) 第一列为1 结果集特性 con.createStatement()：生成的结果集：不滚动、不敏感、不可更新！(mysql默认可滚动) Statement createStatement(int resultSetType, int resultSetConcurrency) 第一个参数： ResultSet.TYPE_FORWARD_ONLY：不滚动结果集； ResultSet.TYPE_SCROLL_INSENSITIVE：滚动结果集，但结果集数据不会再跟随数据库而变化； ResultSet.TYPE_SCROLL_SENSITIVE：滚动结果集，但结果集数据不会再跟随数据库而变化； 第二个参数： CONCUR_READ_ONLY：结果集是只读的，不能通过修改结果集而反向影响数据库； CONCUR_UPDATABLE：结果集是可更新的，对结果集的更新可以反向影响数据库。 上面方法分为两类，一类用来判断游标位置的，另一类是用来移动游标的。如果结果集是不可滚动的，那么只能使用next()方法来移动游标，而beforeFirst()、afterLast()、first()、last()、previous()、relative()方法都不能使用。 获取列数据方法 可以通过next()方法使ResultSet的游标向下移动，当游标移动到你需要的行时，就需要来获取该行的数据了，ResultSet提供了一系列的获取列数据的方法： String getString(int columnIndex)：获取指定列的String类型数据； int getInt(int columnIndex)：获取指定列的int类型数据； double getDouble(int columnIndex)：获取指定列的double类型数据； boolean getBoolean(int columnIndex)：获取指定列的boolean类型数据； Object getObject(int columnIndex)：获取指定列的Object类型的数据,不确定列类型时 上面方法中，参数columnIndex表示列的索引，列索引从1开始，而不是0 ResultSet还提供了一套通过列名称来获取列数据的方法： String getString(String columnName)：获取指定名称的列的String数据； int getInt(String columnName)：获取指定名称的列的int数据； double getDouble(String columnName)：获取指定名称的列的double数据； boolean getBoolean(String columnName)：获取指定名称的列的boolean数据； Object getObject(String columnName)：获取指定名称的列的Object数据； PreparedStatement预编译声明 它是Statement接口的子接口。 优点：1,防SQL攻击 2,提高代码的可读性、可维护性 3,提高效率 获得PreparedStatement对象： 给出SQL模板,即有“?”的SQL语句 调用Connection的PreparedStatement prepareStatement(String sql模板)； 调用pstmt的setXxx(int index,值)给sql模板中的第index个?赋值 调用pstmt的executeUpdate()或executeQuery()，但它们的方法都没有参数。 预处理的原理 服务器的工作： 校验sql语句的语法 编译：一个与函数相似的东西 执行：调用函数 PreparedStatement： 前提：连接的数据库必须支持预处理，几乎没有不支持的。 每个pstmt都与一个sql模板绑定在一起，先把sql模板给数据库，数据库先进行校验，再进行编译。执行时只是把参数传递过去而已。 若二次执行时，就不用再次校验语法，也不用再次编译，直接执行。 防止SQL攻击 过滤用户输入的数据中是否包含非法字符。 分步交验！先使用用户名来查询用户，如果查找到了，再比较密码。 使用PreparedStatement。 MySQL默认预处理关闭,需在URL里添加下列参数?属性1&属性2 useServerPrepStmts=true 开启预编译功能 cachePrepStmts=true 缓存编译后函数的key,避免不同pstmt执行相同sql语句产生的二次编译 rewriteBatchedStatements=true MySQL的批处理也需要通过参数来打开 批处理 Statement批处理 批处理就是把几条sql存在一批里,一次性执行,批处理只针对更新（增、删、改）语句，批处理没有查询 方法: void addBatch(String sql)：添加一条语句到“批”中； int[] executeBatch()：执行“批”中所有语句。返回值表示每条语句所影响的行数据； void clearBatch()：清空“批”中的所有语句。 注意：当执行了executeBatch()之后，“批”中的SQL语句就会被清空。还可以在执行“批”之前，调用Statement的clearBatch()方法来清空“批”。 PreparedStatement批处理 PreparedStatement的批处理有所不同，因为每个PreparedStatement对象都绑定一条SQL模板。所以向PreparedStatement中添加的不是SQL语句，而是给“?”赋值。 方法: void addBatch()：添加一组?值到“批”中； int[] executeBatch()：执行“批”中所有语句。返回值表示每条语句所影响的行数据； JdbcUtils工具类 JdbcUtils的作用 连接数据库的四大参数是：驱动类、url、用户名，以及密码。这些参数都与特定数据库关联，如果将来想更改数据库，那么就要去修改这四大参数，那么为了不去修改代码，写一个JdbcUtils类，让它从配置文件中读取配置参数，然后创建连接对象。 JdbcUtils.java public class JdbcUtils { private static final String dbconfig = \"dbconfig.properties\"; private static Properties prop = new Properties(); static { try { InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(dbconfig); prop.load(in); Class.forName(prop.getProperty(\"driverClassName\")); } catch (IOException e) { throw new RuntimeException(e); } } public static Connection getConnection() { try { return DriverManager.getConnection(prop.getProperty(\"url\"), prop.getProperty(\"username\"), prop.getProperty(\"password\")); } catch (Exception e) { throw new RuntimeException(e); } } } dbconfig.properties文件 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mydb1?useUnicode=true&characterEncoding=UTF8 username=root password=123 连接池 tomcat的conf文件夹下context.xml文件里 //最大等待时间(毫秒) 数据源(DataSource) javax.sql.DataSource接口 Context ct = new InitialContext();//构造一个初始上下文。 得到一个上下文对象 DataSource d = (DataSource)ct.lookup(\"java:comp/env/jdbc/suo\"); //检索指定的对象。 得到一个数据源对象,参数为JNDI地址:java:comp/env/JNDI名称 conn=d.getConnection(); "},"javaWeb/jsp.html":{"url":"javaWeb/jsp.html","title":"JSP(Java Server Pages)","keywords":"","body":"JSP(Java Server Pages) 运行在服务器端的Java页面.使用HTML嵌套Java代码实现。其本质是把JSP页面解析为对应的Servlet，然后通过Servlet返回静态页面。 语法 注释和写法 ：相当于写在方法内 ：相当于写在response.getWriter().print( ... )里 ：相当于写在类里,与成员变量或方法同级 ,jsp内可以使用Java注释 声明和使用 变量 类成员声明和方法内声明 等效于print(\"变量名\") 方法 只能在中声明 JSP隐式对象 request对象 客户端的请求信息被封装在request对象 方法 String getParameter(String name) 返回name指定参数的参数值 String[] getparameterValues(String name) 返回包含参数name的所有值的数组 void setCharacterEncoding(\"gb2312\") 设置接受参数的字符集 RequestDispatcher getRequestDispatcher(String path) 返回一个RequestDispatcher对象，该对象的forward(request,response)方法用于转发请求 object getAttribute(String name) 返回指定属性的属性值 void setAttribute(String key , Object obj) 设置属性的属性值 Cookie[] getCookies() 获取Cookie数组 String getProtocol() 返回请求用的协议类型及版本号 response对象 服务端的响应信息被封装在response对象 方法 sendRedirect(String location) 重新定向客户端的请求,跳转到location的页面 addCookie(Cookie cookie) 添加Cookie数据 application对象 即servletContext，整个项目共享的使用数据,服务器开启时创建,服务器关闭消失. 方法 Object getAttribute(String name) 返回给定名的属性值 void setAttribute(String name,Object obj) 设定属性的属性值 session对象 范围: 指的是客户端与服务器的一次会话,从首次访问服务器开始，到该用户关闭浏览器结束(存储在服务器) 生命周期: 当不在被需要时,从服务器中销毁,分为于主动调用销毁和过期自动销毁 其实服务器是不会知道浏览器关闭了没有，所以关闭浏览器时服务器是不会删除Session的，也正是这个原因服务器才会设置一个Session失效时间的 session靠的是浏览器cookie里的sessionId区分的,不同sessionId对应不同session,相互之间数据不共享 方法 获取session对象 Jsp中得到session对象：session是jsp内置对象之下，不用创建就可以直接使用！ Servlet中得到session对象：HttpSession session = request.getSession(); 该方法还有个可选boolean参数,默认为true 为false时:如果session缓存中(如果cookie不存在)，不存在session，那么返回null，而不会创建session对象。 实现原理 request.getSession()方法：不调用则不创建Session,jsp本身调用这个方法所以一定有Session 获取Cookie中的JSESSIONID： 如果sessionId不存在，创建session，把session保存起来，把新创建的sessionId保存到Cookie中 如果sessionId存在，通过sessionId查找session对象，如果没有查找到，创建session，把session保存起来，把新创建的sessionId保存到Cookie中 如果sessionId存在，通过sessionId查找到了session对象，那么就不会再创建session对象了。 返回session 如果创建了新的session，浏览器会得到一个包含了sessionId的Cookie，这个Cookie的生命为-1，即只在浏览器内存中存在，如果不关闭浏览器，那么Cookie就一直存在。 下次请求时，再次执行request.getSession()方法时，因为可以通过Cookie中的sessionId找到session对象，所以与上一次请求使用的是同一session对象 服务器不会马上给你创建session，在第一次获取session时，才会创建，即调用request.getSession()时 request.getSession(false)、request.getSession(true)、request.getSession()，后两个方法效果相同， 第一个方法：如果session缓存中(如果cookie不存在)，不存在session，那么返回null，而不会创建session对象。 session域相关方法 void setAttribute(String key,Object obj) 设置Session的属性 Object getAttribute(String name) 返回session的属性，不存在则返回null void removeAttribute(String name) 移除session中指定名称的对象 String getId() 返回session对象的ID void invalidate() 将session无效化，解绑任何与该session绑定的对象,再次请求会新建一个替代它 void setMaxInactiveInterval(int interval) 最大活动时间，以秒为单位，默认30分钟 boolean isNew()：查看session是否为新。当客户端第一次请求时，服务器为客户端创建session，但这时服务器还没有响应客户端，也就是还没有把sessionId响应给客户端时，这时session的状态为新 设置session自动清除时间(单位分钟)web.xml中 30 Cookie对象 存储在客户机的文本文件,保存了大量轨迹信息 方法 该方法设置 cookie 过期的时间（以秒为单位）。 public void setMaxAge(int expiry) 如果不设置，cookie 只会在当前 session 会话中持续有效。 expiry>0：浏览器会把Cookie保存到客户机硬盘上，有效时长为maxAge的值决定。 expiry expiry=0：浏览器会马上删除这个Cookie！ public String getName() 返回 cookie的名称，名称创建后将不能被修改 public String getValue() 获取cookie的值 JavaWeb中使用Cookie 原始方式： 使用response发送Set-Cookie响应头:response.addHeader(\"Set-Cookie\", \"bbb=BBB\") 使用request获取Cookie请求头:request.getHeader(\"Set-Cookie\") 便捷方式： 使用repsonse.addCookie()方法向浏览器保存Cookie 使用request.getCookies()方法获取浏览器归还的Cookie Cookie中存中文需要编码和解码 URLEncoder.encode(String s,String enc) 以enc编码字符串s URLDecoder.decode(String s,String enc) 以enc解码字符串s Cookie的path： Cookie的path由服务器创建Cookie时设置,并不是设置这个Cookie在客户端的保存路径 浏览器访问服务器的路径，如果包含某个Cookie的路径，那么就会归还这个Cookie。 例如： aCookie.path=/day11_1/; bCookie.path=/day11_1/jsps/; cCookie.path=/day11_1/jsps/cookie/; 访问：/day11_1/index.jsp时，归还：aCookie 访问：/day11_1/jsps/a.jsp时，归还：aCookie、bCookie 访问：/day11_1/jsps/cookie/b.jsp时，归还：aCookie、bCookie、cCookie Cookie的path默认值：当前访问路径的父路径。例如在访问/day11_1/jsps/a.jsp时，响应的cookie，那么这个cookie的默认path为/day11_1/jsps/ Cookie的domain domain用来指定Cookie的域名！当多个二级域中共享Cookie时才有用。 例如；www.baidu.com、zhidao.baidu.com、news.baidu.com、tieba.baidu.com之间共享Cookie时可以使用domain 设置domain为：cookie.setDomain(\".baidu.com\"); 匹配域名的就会共享cookie. 设置path为：cookie.setPath(\"/\"); 为了可以共享,必须为\"/\" Http协议规定（保证不给浏览器太大压力）： 1个Cookie最大4KB 1个服务器最多向1个浏览器保存20个Cookie 1个浏览器最多可以保存300个Cookie pageContext对象 JSP的第四大域对象,主要作用是获取并代理其他域对象. 作用范围：为当前页面,这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据, 生命周期：是当对JSP的请求时开始，当响应结束时销毁。即response不存在时结束. 主要方法 代理其他域对象 void setAttribute(String name, Object value, int scope)：在指定范围中添加数据； Object getAttribute(String name, int scope)：获取指定范围的数据； void removeAttribute(String name, int scope)：移除指定范围的数据； scope为SESSION_SCOPE/REQUEST_SCOPE/APPLICATION_SCOPE 全域查找 Object findAttribute(String name)：依次在pageContext、request、session、application范围查找名称为name的数据，如果找到就停止查找。这说明在这个范围内有相同名称的数据，那么page范围的优先级最高！ 获取其他8个内置对象： JspWriter getOut()：获取out内置对象； ServletConfig getServletConfig()：获取config内置对象； Object getPage()：获取page内置对象； ServletRequest getRequest()：获取request内置对象； ServletResponse getResponse()：获取response内置对象； HttpSession getSession()：获取session内置对象； ServletContext getServletContext()：获取application内置对象； Exception getException()：获取exception内置对象； page对象 final java.lang.Object page = this; page（当前JSP的真身类型）：当前JSP页面的“this”，即当前对象 config对象 config（ServletConfig）：对应“真身”中的ServletConfig exception对象 out对象 out（JspWriter）：等同与response.getWriter()，用来向客户端发送文本数据 public abstract void print() 显示各种数据类型的内容。 三大指令标签 一个jsp页面中，可以有0~N个指令的定义。 page指令标签 用来设置jsp页面的属性 pageEncoding是设置的JSP页面源代码的字符编码格式 charset是请求服务器以后返回过来的内容的字符编码(当浏览器得到此文件时以什么方式解码) contentType：它表示添加一个响应头：Content-Type！等效于response.setContentType(\"text/html;charset=utf-8\"); 如果两个属性只提供一个，那么另一个的默认值为设置那一个。 如果两个属性都没有设置，那么默认为iso import后更需要导入的包,可多个 errorPage和isErrorPage errorPage：当前页面如果抛出异常，那么要转发到哪一个页面，由errorPage来指定 isErrorPage：它指定当前页面是否为处理错误的页面！当该属性为true时，这个页面会设置状态码为500！(不写状态码为200)而且只有这个页面可以使用9大内置对象中的exception! web.xml里设置错误页面 404 /error/errorPage.jsp 500 /error/errorPage.jsp java.lang.RuntimeException /index.jsp autoFlush和buffer autoFlush：指定jsp的输出流缓冲区满时，是否自动刷新！默认为true，如果为false，那么在缓冲区满时抛出异常！ buffer：指定缓冲区大小，默认为8kb，通常不需要修改！指定out对象的缓存区 其他属性： isELIgnored：是否忽略el表达式，默认值为false，不忽略，即支持！ language：指定当前jsp编译后的语言类型，默认值为java。 info：信息！ isThreadSafe：当前的jsp是否支持并发访问！ session：当前页面是否支持session，如果为false，那么当前页面就没有session这个内置对象！ extends：让jsp生成的servlet去继承该属性指定的类！ include静态包含 与RequestDispatcher的include()方法的功能相似。 它是在jsp编译成java文件时完成的！他们共同生成一个java(就是一个servlet)文件，然后再生成一个class！ RequestDispatcher的include()是一个方法，包含和被包含的是两个servlet，即两个.class！他们只是把响应的内容在运行时合并了！ 作用：把页面分解了，使用包含的方式组合在一起，这样一个页面中不变的部分，就是一个独立jsp，而我们只需要处理变化的页面。 taglib导入标签库 两个属性： prefix：指定标签库在本页面中的前缀！由我们自己来起名称！ uri: 相对于项目目录的路径,指向tld文件 前缀的用法 JSP的动作标签 这些jsp的动作标签，与html提供的标签有本质的区别，是由tomcat(服务器)来解释执行。都有id和scope属性。 ：转发！它与RequestDispatcher的forward方法是一样的 }\" flush=\"true\">：包含：它与RequestDispatcher的include方法是一样的,本质上只是调用另一个Servlet 编译级别(同一个Servlet)运行级别(不同Servlet) \">：它用来作为forward和include的子标签！用来给转发或包含的页面传递参数！ 嵌入Applet JavaBean javaBean的规范 必须要有一个无参构造器 提供get/set方法，如果只有get方法，那么这个属性是只读属性,如果只有set方法,为只写属性. 属性：有get/set方法的成员，还可以没有成员，只有get/set方法。属性名称由get/set方法来决定！而不是成员名称！ 方法名称满足一定的规范，那么它就是属性！boolean类型的属性，它的读方法可以是is开头，也可以是get开头！ JavaBean属性名要求：一般小写开头,特殊时需前两个字母要么都大写，要么都小写 内省 // 通过java.beans.Introspector的getBeanInfo()方法来获取java.beans.BeanInfo实例。 BeanInfo beanInfo = Introspector.getBeanInfo(User.class); // 通过BeanInfo可以得到这个类的所有JavaBean属性的PropertyDescriptor(属性描述符)对象。 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); // 每个PropertyDescriptor对象对应一个JavaBean属性： String getName()：获取JavaBean属性名称； Method getReadMethod：获取属性的读方法； Method getWriteMethod：获取属性的写方法。 commons-beanutils，它是依赖内省完成 导包：commons-beanutils.jar，commons-logging.jar 方法 BeanUtils.getProperty(Object bean, String propertyName) 获取JavaBean属性 BeanUtils.setProperty(Object bean, String propertyName, String propertyValue) 设置JavaBean属性 BeanUtils.populate(Map map, Object bean) 封装Map数据到JavaBean对象中 CommontUtils.toBean(Map map, Class class) 返回封装了Map数据的JavaBean对象 jsp中与javaBean相关的标签 创建或查询bean 在session域中查找名为user1的bean，如果不存在，创建之 设置属性 设置名为user1的这个javabean的username属性值为admin 获取属性 获取名为user1的javabean的名为username属性值 "},"javaWeb/JSTL.html":{"url":"javaWeb/JSTL.html","title":"JSTL(JSP标准标签库)","keywords":"","body":"JSTL(JSP标准标签库) 导包：JSTL.jar，standard.jar(1.2后不需要这个包了) core标签库(c标签) 在需要使用的JSP页面引用标签库 out和set标签 ：输出 value：可以是字符串常量，也可以是EL表达式 default：当要输出的内容为null时，会输出default指定的值 escapeXml：默认值为true，当为false时解析XML ：设置(创建域的属性) var：变量名 value：变量值，可以是EL表达式 scope：域，默认为page，可选值：page、request、session、application remove标签 ：删除域变量 var：变量名 scope：如果不给出scope，表示删除所有域中的该名称的变量；如果指定了域，那么只删除该域的变量。 url标签 ：输出url value：指定一个路径！它会在路径前面自动添加项目名。 ，它会输出/day13_1/index.jsp var：指定变量名，一旦添加了这个属性，那么url标签就不会再输出到页面，而是把生成url保存到域中。 scope：它与var一起使用，用来保存url。 子标签：，用来给url后面添加参数，例如： 结果为：/day13_1/index.jsp?username=%ED%2C%3F%ED%2C%3F if标签 对应java中的if语句 ...，当test为true时，执行标签体内容 var用于存储条件结果的变量，scope为var所在域 choose标签 它对应java中的if/else if/ ... /else,更接近switch 例如： ... ... ... ... ... forEach标签 属性： var：循环变量 begin：设置循环变量从几开始。 end：设置循环变量到几结束。 step：设置步长！等同与java中的i++，或i+=2。step默认为1 status：代表循环状态的变量名称,有属性 ${status.current}当前这次迭代的（集合中的）项 ${status.index}当前这次迭代从 0 开始的迭代索引 ${status.count} 当前这次迭代从 1 开始的迭代计数 ${status.first} 用来表明当前这轮迭代是否为第一次迭代的标志 ${status.last} 用来表明当前这轮迭代是否为最后一次迭代的标志 items：指定要循环谁，它可以是一个数组或一个集合 a)循环变量方式： ${i} b)遍历数组、集合 ${str } items：指定要循环谁，它可以是一个数组或一个集合 var：把数组或集合中的每个元素赋值给var指定的变量。 当遍历map时,用${str.key}和${str.value}输出 forTokens标签 和foreach相似，指定分隔符，分隔字符串为数组，然后循环 独有属性：delims分隔符 fmt库,格式化库 格式化时间 value：指定一个Date类型的变量 pattern：用来指定输出的模板！例如：yyyy-MM-dd HH:mm:ss type：time，date，both dateStyle：short，medium，long，full，default timeStyle：short，medium，long，full，default 格式化数字 保留小数点后2位，它会四舍五入！如果不足2位，以0补位！ 保留小数点后2位，它会四舍五入！如果不足2位，不补位！ value 要显示的数字 是 无 type NUMBER，CURRENCY，或 PERCENT类型 否 Number pattern 指定一个自定义的格式化模式用与输出 否 无 currencyCode 货币码（当type=\"currency\"时） 否 取决于默认区域 currencySymbol 货币符号 (当 type=\"currency\"时) 否 取决于默认区域 groupingUsed 是否对数字分组 (TRUE 或 FALSE) 否 true maxIntegerDigits 整型数最大的位数 否 无 minIntegerDigits 整型数最小的位数 否 无 maxFractionDigits 小数点后最大的位数 否 无 minFractionDigits 小数点后最小的位数 否 无 var 存储格式化数字的变量 否 Print to page scope var属性的作用域 否 page SQL标签 JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下： 标签 描述 指定数据源 运行SQL查询语句 运行SQL更新语句 将SQL语句中的参数设为指定值 将SQL语句中的日期参数设为指定的java.util.Date 对象值 在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行 自定义标签 步骤 定义标签处理类（必须是Tag或SimpleTag的实现类,继承SimpleTagSupport更方便） 编写tld文件，它是一个xml 页面中使用来指定tld文件的位置 标签处理类 SimpleTag接口： void doTag()：每次执行标签时都会调用这个方法； JspTag getParent()：返回父标签（非生命周期方法） void setParent(JspTag)：设置父标签 void setJspBody(JspFragment)：设置标签体对象 void seetJspContext(JspContext)：设置jsp上下文对象，其实传入的是子类PageContext 在执行doTag()之前，其他三个set方法会被tomcat调用，所以可以在doTag中使用三个成员变量 可以在标签处理类中的doTag()中抛出SkipPageException，当Tomcat调用doTag()方法，并捕获到SkipPageException时，它会跳过本页面其他内容，结束处理。 package my.tag; import java.io.IOException; import java.io.StringWriter; import javax.servlet.jsp.JspContext; import javax.servlet.jsp.JspException; import javax.servlet.jsp.tagext.SimpleTagSupport; public class HelloTag extends SimpleTagSupport{ // 标签属性设置为同名的bean属性，并配上get/set方法 private String who = \"\"; StringWriter sw = new StringWriter(); @Override public void doTag() throws JspException, IOException { // 获取标签体内容传给sw getJspBody().invoke(sw); JspContext jctx = this.getJspContext(); jctx.getOut().write(\"hello \"+this.who+\"!\"+sw.toString()); } public String getWho() { return who; } public void setWho(String who) { this.who = who; } } 配置tld文件 tld文件一般都放到WEB-INF之下，这样保证客户端访问不到 This is my tag library MY Tag 1.0 my my.tag print \"hello my tag\" hello my.tag.HelloTag scriptless the name of a person who false true java.lang.String false 标签体取值： empty：无标签体,即忽略标签体。 JSP：可以包含所有类型的JSP语法 scriptless：接受文本，EL表达式和JSP动作标签，如JSP脚本元素()就不行 getjspbody().invoke(Writer out) 处理标签体内容,并输出到指定out。参数为null是输出到pageContext.getOut()得到的JspWriter对象中。 tagdependent：标签体原封不动转交由标签处理类处理 JSP页面中指定tld文件位置 然后使用标签 How are you? 运行结果 hello john!How are you? "},"javaWeb/Listener&Fiter.html":{"url":"javaWeb/Listener&Fiter.html","title":"过滤器和监视器","keywords":"","body":"过滤器和监视器 过滤器 javax.servlet.Filter接口 它会在一组资源（jsp、servlet、.css、.html等等）的前面执行，它可以让请求得到目标资源，也可以不让请求达到，过滤器有拦截请求的能力 过滤器如何编写 实现javax.servlet.Filter接口(单例) 方法: void init(FilterConfig) // 创建之后，马上执行；Filter会在服务器启动时就创建！ void destory() // 销毁之前执行！在服务器关闭时销毁 void doFilter(ServletRequest,ServletResponse,FilterChain) // 每次过滤时都会执行 配置web.xml xxx cn.itcast.web.filter.AFitler xxx /* myservlet 配置servlet为目标资源 --> FilterConfig-->与ServletConfig相似 获取初始化参数：getInitParameter() 获取过滤器名称：getFilterName() 获取appliction：getServletContext() 获取所有初始化参数的名称: Enumeration getInitParameterNames() FilterChain(链条) doFilter(ServletRequest, ServletResponse)：放行，执行目标资源，或是执行下一个过滤器 多过滤器 过滤器的四种拦截方式 REQUEST默认的,请求(直接访问) FORWARD转发 INCLUDE包含(动态包含时才触发即) ERROR通过这种方式指定的页面 在中的最后进行配置。 多个过滤器的执行顺序 的配置先后顺序决定了过滤器的执行顺序！ 监视器 事件源：三大域 ServletContext 生命周期监听：ServletContextListener void contextInitialized(ServletContextEvent sce)：创建Servletcontext(后)时 void contextDestroyed(ServletContextEvent sce)：销毁Servletcontext(前)时 属性监听：ServletContextAttributeListener void attributeAdded(ServletContextAttributeEvent event)：添加属性时； void attributeReplaced(ServletContextAttributeEvent event)：替换属性时； void attributeRemoved(ServletContextAttributeEvent event)：移除属性时； HttpSession 生命周期监听：HttpSessionListener void sessionCreated(HttpSessionEvent se)：创建session(后)时 void sessionDestroyed(HttpSessionEvent se)：销毁session(前)时 属性监听：HttpSessioniAttributeListener void attributeAdded(HttpSessionBindingEvent event)：添加属性时； void attributeReplaced(HttpSessionBindingEvent event)：替换属性时 void attributeRemoved(HttpSessionBindingEvent event)：移除属性时 ServletRequest 生命周期监听：ServletRequestListener void requestInitialized(ServletRequestEvent sre)：创建request(后)时 void requestDestroyed(ServletRequestEvent sre)：销毁request(前)时 属性监听：ServletRequestAttributeListener void attributeAdded(ServletRequestAttributeEvent srae)：添加属性时 void attributeReplaced(ServletRequestAttributeEvent srae)：替换属性时 void attributeRemoved(ServletRequestAttributeEvent srae)：移除属性时 事件对象 ServletContextEvent：ServletContext getServletContext() HttpSessionEvent：HttpSession getSession() ServletRequest： ServletContext getServletContext()； ServletReques getServletRequest()； ServletContextAttributeEvent： ServletContext getServletContext()； String getName()：获取当前操作的属性名 Object getValue()：获取当前操作的属性值 HttpSessionBindingEvent： String getName()：获取当前操作的属性名； Object getValue()：获取当前操作的属性值； HttpSession getSession()：获取当前操作的session对象。 ServletRequestAttributeEvent ： String getName()：获取当前操作的属性名； Object getValue()：获取当前操作的属性值； ServletContext getServletContext()：获取ServletContext对象； ServletRequest getServletRequest()：获取当前操作的ServletRequest对象。 关于属性监听中event的getValue的结果的分析: 添加:getValue获取这次添加的值 替换:getValue获取替换前的值,两次值相同也当成是替换 移除:getValue获取移除的值 感知监听（都与HttpSession相关） 它用来添加到JavaBean上，而不是添加到三大域上，这两个监听器都不需要在web.xml中注册。 HttpSessionBindingListener接口 javabean实现该接口，javabean就知道自己是否添加到session中了。 public void valueBound(HttpSessionBindingEvent event)：当把监听器对象添加到session中会调用监听器对象的本方法； public void valueUnbound(HttpSessionBindingEvent event)：当把监听器对象从session中移除时会调用监听器对象的本方法； HttpSessionActivationListener接口 javabean实现该接口，javabean就知道自己是否随session钝化活化了.且要实现serializable接口,否则无法序列化,将会被从session中移除 public void sessionWillPassivate(HttpSessionEvent se)：当对象感知被活化时调用本方法； public void sessionDidActivate(HttpSessionEvent se)：当对象感知被钝化时调用本方法； 注意：标签一般配置在标签前面,多个时按配置顺序执行 "},"javaWeb/servlet.html":{"url":"javaWeb/servlet.html","title":"servlet","keywords":"","body":"servlet javax.servlet.Servlet 接口 servlet都是单例 方法: public void init(ServletConfig config) throws ServletException; 初始化操作,只在创建Servlet对象之后执行一次 public void destroy(); 在Servlet销毁之前执行一次,本身不执行销毁 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; 每次处理请求时调用 public ServletConfig getServletConfig(); 获取Servlet配置信息 public String getServletInfo(); 获取Servlet信息 1.在web.xml里配置Servlet hello cn.itcast.servlet.HelloServlet //随服务器启动,值为大于等于0的整数,小的先执行 0 hello /helloworld 通过相同的servlet-name把servlet的实现类与url路径关联起来. 2.ServletConfig接口 ServletConfig对象封装了Servlet在web.xml中的配置信息，它对应元素。ServletConfig类的功能有： String getServletName()：获取Servlet配置名，即的值； ServletContext getServletContext()：获取ServletContext对象，这个对象稍后介绍 String getInitParameter(String name)：获取Servlet自己的初始化参数 Enumeration getInitParameterNames()：获取Servlet自己的所有初始化参数的名称 在web.xml文件中，配置时可以为配置0~N个初始化参数，例如： xxx cn.itcast.servlet.MyServlet p1 v1 p2 v2 GenericServlet抽象类 GenericServlet是Servlet接口的实现类，但它是一个抽象类，它唯一的抽象方法就是service()方法 GenericServlet实现了Servlet接口： 实现了String getServletInfo()方法 实现了void destory()方法，空实现 实现了void init(ServletConfig)方法，用来保存ServletConfig参数 实现了ServletConfig getServletConfig()方法 GenericServlet实现了ServletConfig接口： 实现了ServletContext getServletContext()方法 实现了String getInitParameter()方法 实现了String getServletName()方法 实现了Enumeration getInitParameterNames()方法 GenericServlet添加了init()方法： 该方法会被init(ServletConfig)方法调用 如果希望对Servlet进行初始化，那么应该覆盖init()方法，而不是init(ServletConfig)方法 HttpServlet类 HttpServlet是GenericServlet的子类，它专注HTTP请求 HttpServlet类的方法： 实现了void service(ServletRequest,ServletResponse)方法，实现内容是： 把ServletRequest强转成HttpServletRequest 把ServletResponse强转成HttpServletResponse 调用本类添加的void service(HttpServletRequest,HttpServletResponse)方法 添加了void service(HttpServletRequest,HttpServletResponse)方法，内容是： 调用request的getMethod()获取请求方式 如果请求方式为GET，那么调用本类添加的doGet(HttpServletRequest,HttpServletResponse)方法 如果请求方式为POST，那么调用本类添加的doPost(HttpServletRequest,HttpServletResponse)方法 添加了doGet(HttpServletRequest,HttpServletResponse)方法，内容是响应405，表示错误，所以我们应该去覆盖这个方法 添加了doPost(HttpServletRequest,HttpServletResponse)方法，内容是响应405，表示错误，所以我们应用去覆盖这个方法 如果是通过继承HttpServlet类来自定义Sevlet的话，那么： 不要去覆盖void service(ServletRequest,ServletResponse) 不要去覆盖void service(HttpServletRequest, HttpServletResponse) 而应该去覆盖doGet()或doPost()方法。 配置 url-pattern是一种匹配,匹配的是项目路径后的url部分,匹配到则跳转相应的Servlet 是的子元素，用来绑定Servlet的访问路径 可以在一个中给出多个，也就是说一个Servlet可以有 多个访问路径： xxx /helo1 /hello2 还可以在中使用通配符，即“*”。 /*：表示匹配任何路径(全匹配) /do/*：表示匹配以/do开头的任何路径(路径匹配) *.do：表示匹配任何以“.do”结尾的路径(拓展名匹配) 同时匹配多个Servlet时,匹配越多优先级越低 注意： 通配符要么在开头，要么在结尾，不能在中间，例如：/*.do就是错误的使用。 如果不使用通配符，那么必须以“/”开头，例如：abc就是错误的 Servlet域对象 HttpServletContext接口 ServletContext是Servlet三大域对象之一.ServletContext在服务器启动时创建，在服务器关闭时销毁，一个JavaWeb应用只创建一个ServletContext对象 获取ServletContext对象 ServletConfig getServletContext()； GenericServlet getServletContext(); HttpSession getServletContext() ServletContextEvent getServletContext() // 在HttpServlet中可以通过以下方法来获取ServletContext对象 ServletContext sc = this.getServletContext() ServletContext sc = this.getServletConfig().getServletContext() 存取数据 因为在一个JavaWeb应用中，只有一个ServletContext对象，所以在ServletContext中保存的数据可以共整个JavaWeb应用中的动态资源共享.ServletContext是Servlet三大域对象之一，域对象内部有一个Map，用来保存数据 void setAttribute(String name, Object value)：用来添加或替换ServletContext域数据 Object getAttribute(String name)：通过名称来获取域数据 void removeAttribute(String name)：通过名称移除域数据 Enumeration getAttributeNames()：获取所有ServletContext域数据的名称 读取web.xml中配置的应用初始化参数 p1 v1 p2 v2 servletContext.getInitParameter(\"p1\")，返回v1 servletContext.getInitParameter(\"p2\")，返回v2 servletContext.getInitParameterNames()，返回Enumeration，包含p1和p2 获取项目资源 相对路径和/路径都是项目目录 // String getRealPath(String path)：获取资源的真实路径 String path = servletContext.getRealPath(\"/WEB-INF/a.jpg\"); 返回值为/WEB-INF/a.jpg真实路径，即磁盘路径： C:/tomcat6/wabapps/hello/WEB-INF/a.jpg // InputStream getResourceAsStream(String path)：获取资源的输入流 InputStream in = servletContext.getResourceAsStream(\"/WEB-INF/a.jpg\"); 返回的是a.jpg的输入流对象，可以从流中得到a.jpg的数据 // Set getResourcePaths(String path)：获取指定目录下的所有资源路径 Set paths = servletContext.getResourcePaths(\"/WEB-INF\"); 返回的Set中包含如下字符串： /WEB-INF/lib/ /WEB-INF/classes/ /WEB-INF/web.xml /WEB-INF/a.jpg 获取类路径资源 可以通过Class类的对象来获取类路径下的资源，对应JavaWeb应用的类路径就是classes目录下的资源， 例如： InputStream in = cn.itcast.servlet.MyServlet.class.getResourceAsStream(\"a.jpg\"); 获取的是：/WEB-INF/classes/cn/itcast/servlet/a.jpg，即与MyServlet.class同目录下的资源 例如： InputStream in = cn.itcast.servlet.MyServlet.class.getResourceAsStream(\"/a.jpg\"); 获取的是：/WEB-INF/classes/a.jpg，即类路径的根目录下的资源，类路径的根目录就是/classes目录 HttpServletRequest接口 服务器处理请求的流程： 服务器每次收到请求时，都会为这个请求开辟一个新的线程。 服务器会把客户端的请求数据封装到request对象中，request就是请求数据的载体！ 服务器还会创建response对象，这个对象与客户端连接在一起，它可以用来向客户端发送响应。 获取请求头信息 请求协议中的数据都可以通过request对象来获取 * 获取常用信息 > 获取客户端IP，案例：封IP。request.getRemoteAddr() > 请求方式，request.getMethod()，可能是POST也可能是GET * 获取HTTP请求头 > String getHeader(String name)，适用于单值头 > int getIntHeader(String name)，适用于单值int类型的请求头 > long getDateHeader(String name)，适用于单值毫秒类型的请求头 > Enumeration getHeaders(String name)，适用于多值请求头 案例： 通过User-Agent识别用户浏览器类型 防盗链：如果请求不是通过本站的超链接发出的，发送错误状态码404。Referer这个请求头，表示请求的来源。 获取请求URL http://localhost:8080/day10_2/AServlet?username=xxx&password=yyy > String getScheme()：获取协议，http > String getServerName()：获取服务器名，localhost > String getServerPort()：获取服务器端口，8080 > String getContextPath()：获取项目名，/day10_2 > String getServletPath()：获取Servlet路径，/AServlet > String getQueryString()：获取参数部分，即问号后面的部分。username=xxx&password=yyy > String getRequestURI()：获取请求URI，等于项目名+Servlet路径。/day10_2/AServlet > String getRequestURL()：获取请求URL，等于不包含参数的整个请求路径。http://localhost:8080/day10_2/AServlet > String getProtocol() 返回请求用的协议类型及版本号 获取请求参数 请求参数是由客户端发送给服务器的！有可能是在请求体中（POST），也可能是在URL之后（GET） 请求参数：有一个参数一个值的，还有一个参数多个值 String getParameter(String name)：获取指定名称的请求参数值，适用于单值请求参数 String[] getParameterValues(String name)：获取指定名称的请求参数值，适用于多值请求参数 Enumeration getParameterNames()：获取所有请求参数名称 Map getParameterMap()：获取所有请求参数，其中key为参数名，value为参数值。 请求转发和请求包含 RequestDispatcher rd = request.getRequestDispatcher(\"/MyServlet\"); 使用request获取RequestDispatcher对象，方法的参数是被转发或包含的Servlet的Servlet路径(url-pattern) 请求转发：rd.forward(request,response); 请求包含：rd.include(request,response); 有时一个请求需要多个Servlet协作才能完成，所以需要在一个Servlet跳到另一个Servlet 一个请求跨多个Servlet，需要使用转发和包含。 请求转发：由下一个Servlet完成响应体！当前Servlet可以设置响应头！（留头不留体,响应体会被后一个覆盖） 请求包含：由两个Servlet共同来完成响应体！（都留） 无论是请求转发还是请求包含，都在一个请求范围内！使用同一个request和response！ request域 Servlet中三大域对象：request、session、application(ServletContext)，都有如下三个方法： void setAttribute(String name, Object value) Object getAttribute(String name) void removeAttribute(String name); 同一请求范围内使用request.setAttribute()、request.getAttribute()来传值！前一个Servlet调用setAttribute()保存值，后一个Servlet调用getAttribute()获取值。 请求转发和重定向的区别 请求转发是一个请求一次响应，而重定向是两次请求两次响应 请求转发地址栏不变化，而重定向会显示后一个请求的地址 请求转发只能转发到本项目其他Servlet，而重定向不只能重定向到本项目的其他Servlet，还能定向到其他项目 请求转发是服务器端行为，只需给出转发的Servlet路径，而重定向需要给出requestURI，即包含项目名！ 请求转发和重定向效率是转发高！因为是一个请求！ 需要地址栏发生变化，那么必须使用重定向！ 需要在下一个Servlet中获取request域中的数据，必须要使用转发！ HttpServletResponse接口 继承自ServletResponse接口,response使用的就是其对象. 方法 sendError(int sc) --> 发送错误状态码，例如404、500 sendError(int sc, String msg) --> 也是发送错误状态码，还可以带一个错误信息！ setStatus(int sc) --> 发送成功的状态码，可以用来发送302 响应头方法(头名不区分大小写) setHeader(String name, String value)：适用于单值的响应头 addHeader(String name, String value)：适用于多值的响应头 setIntHeader(String name, int value)：适用于单值的int类型的响应头 addIntHeader(String name, int value)：适用于多值的int类型的响应头 setDateHeader(String name, long value)：适用于单值的毫秒类型的响应头 addDateHeader(String name, long value)：适用于多值的毫秒类型的响应头 案例： 发送302，设置Location头，完成重定向,值为包含项目名的/路径 定时刷新：设置Refresh头，你可以把它理解成，定时重定向！ response.setHeader(\"Refresh\", \"5;URL=/firstWeb/servlet/NewAServlet\") 禁用浏览器缓存：Cache-Control、pragma、expires 标签可以代替响应头： response的两个流： ServletOutputStream getOutputStream()用来向客户端发送字节数据。 PrintWriter getWriter()，用来向客户端发送字符数据！需要设置编码。 两个流不能同时使用！否则会抛出IllegalStateException异常 sendRedirect(String location)重定向方法,设置302，设置Location 编码 常见字符编码：iso-8859-1(不支持中文)、gb2312、gbk、gb18030(系统默认编码，中国的国标码)、utf-8(万国码，支持全世界的编码，所以我们使用这个) 响应编码 服务端字符流编码设置 response.setCharaceterEncoding() 客户端解读编码设置,且会自动执行setCharacterEncding()方法 response.setHeader(\"Content-type\",\"text/html;charset=utf-8\") setContentType(\"text/html;charset=utf-8)。 请求编码 地址栏直接给出参数编码为GBK,表单或链接则与页面编码格式相同 服务器端默认使用ISO-8859-1来解码！ // GET请求编码处理： String username = new String(request.getParameter(\"name\").getBytes(\"iso-8859-1\"), \"utf-8\"); 在server.xml中配置URIEncoding=utf-8(不推荐,不通用) // POST请求编码处理： String username = new String(request.getParameter(\"name\").getBytes(\"iso-8859-1\"), \"utf-8\"); 在获取参数之前调用request.setCharacterEncoding(\"utf-8\"); URL编码 表单的类型：Content-Type: application/x-www-form-urlencoded，就是把中文转换成%后面跟随两位的16进制。 作用：在客户端和服务器之间传递中文时需要把它转换成网络适合的方式,防止传输过程中数据丢失 URL编码需要先指定一种字符编码，把字符串解码后，得到byte[]，然后把小于0的字节+256，再转换成16进制。前面再添加一个%。 POST请求默认就使用URL编码！tomcat会自动使用URL解码！ URL编码：String username = URLEncoder.encode(username, \"utf-8\"); URL解码：String username = URLDecoder.decode(username, \"utf-8\"); 路径 web.xml中路径，（叫它Servlet路径！） 要么以“*”开头，要么为“/”开头 转发和包含路径 以“/”开头：相对当前项目路径，即http://localhost:8080/项目名/ 不以“/”开头：相对当前Servlet路径。http://localhost:8080/项目名/servlet/ 重定向路径（客户端路径） 以“/”开头：相对当前主机，例如：http://localhost:8080/，　所以需要自己手动添加项目名，例如；response.sendRedirect(\"/day10_1/Bservlet\"); 页面中超链接和表单路径 与重定向相同，都是客户端路径！需要添加项目名 如果不以“/”开头，那么相对当前页面所在路径。如果是http://localhost:8080/day10_1/html/form.html。　即：http://localhost:8080/day10_1/html/ASevlet 建立使用以“/”开头的路径，即绝对路径！ ServletContext获取资源路径 以不以\"/\"开头都是相对当前项目目录，即当然index.jsp所在目录 ClassLoader获取资源路径 相对classes目录(不能以\"/\"开头) Class获取资源路径 以“/”开头相对classes目录 不以“/”开头相对当前.class文件所在目录。 servlet细节 不要在Servlet中创建成员！创建局部变量即可！ 可以创建无状态成员！(无论谁执行都不会变化) 可以创建有状态的成员，但状态必须为只读(无法修改)的！ "},"javaWeb/xml.html":{"url":"javaWeb/xml.html","title":"XML","keywords":"","body":"XML 树结构 实例： Everyday Italian Giada De Laurentiis 2005 30.00 实例中的根元素是 。文档中的所有 元素都被包含在 中。 元素有 4 个子元素：、、、。蓝色字体为属性。 第一行为声明。 语法规则 必须要有根元素 声明为可选，如存在需放在第一行。 所有元素都必须要有一个关闭标签，如 必须正确嵌套。即关闭标签的顺序要一致。 属性值必须加引号。 实体引用，有5个预定义，用来替代这些符号，避免错误。 | &lt; | &gt; | > | greater than | | &amp; | & | ampersand | | &apos; | ' | apostrophe | | &quot; | \" | quotation mark | 当这些字符很多时可以用， 注释，格式为 空格会被保留，连续的空格不会被合并。 以LF存储换行。 在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。 在 Unix 和 Mac OSX 中，使用 LF 来存储新行。 在旧的 Mac 系统中，使用 CR 来存储新行。 XML 以 LF 存储换行。 标签对大小写敏感。 元素 概念：元素是指从（且包括）开始标签直到（且包括）结束标签的部分。一个元素可以包含：其他元素，文本，属性，或混合以上所有。 命名规则：包含字母、数字以及其他的字符。不能以数字或标点符号开始。不能以任何xml三个字组成的开始。不能包含空格。 命名习惯：避免使用“-”“.”“:” 空元素：或者 属性 属性必须加引号，单双引号均可。如果属性值本身包含双引号可以用单引号包含双引号，或者使用字符实体。 一个元素可以有多个属性，用空格隔开。 没有规定什么时候使用属性，什么时候使用元素，建议尽量避免使用属性。 下面的 id 属性仅仅是一个标识符，用于标识不同的便签。它并不是便签数据的组成部分。 在此我们极力向您传递的理念是：元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。 Tove Jani Reminder Don't forget me this weekend! Jani Tove Re: Reminder I will not 命名空间 使用前缀来避免命名冲突。 语法规则：xmlns:前缀=\"URI\",命名空间可以在他们被使用的元素中或者在XML根元素中声明。 默认命名空间如下。默认空间名不应用于属性。如下面的isbn属性没有命名空间。 取消绑定命名空间：表示purchase范围内都位于无命名空间。表示范围内lib不能使用，可以重新定义。 Sherlock Holmes - I Arthur Conan Doyle Sherlock Holmes - II Arthur Conan Doyle Sherlock Holmes - III Arthur Conan Doyle 在以上的示例中， 元素Book、 Title 和 Author 与命名空间http://www.library.com 关联，元素 purchase、 Title 和 Author 与命名空间http://www.otherlibrary.com 关联。 "},"front_end/CSS.html":{"url":"front_end/CSS.html","title":"CSS","keywords":"","body":"CSS 语法 行内样式 行内样式 内嵌样式 选择器{ 属性1:值; 属性2:值; } 外部样式表 链接式： 特点：属于xhtml，先加载CSS。 导入式：@import url(\"css文件路径\") 特点：属于CSS，先加载HTML后加载样式。 注释：/*注释内容*/ 多重样式优先级 行内样式 > 内嵌样式 > 外部样式 > 浏览器默认样式 选择器 选择器 示例 示例说明 .class .intro 选择所有class=\"intro\"的元素 #id #firstname 选择所有id=\"firstname\"的元素 * * 选择所有元素 element p 并集选择器，选择所有元素 element,element div,p 选择所有元素和元素 element element div p 后代选择器，选择元素内的所有元素 （不限层级） element>element div>p 子元素选择器，选择所有父级是 元素的元素 （限第一层后代） element+element div+p 相邻兄弟选择器，选择所有紧接着元素之后的元素（限相邻的第一个同级别元素） element1~element2 p~ul 后续兄弟选择器，选择p元素之后的每一个ul元素（不需要相邻，且所有ul元素） [attribute] [target] 选择所有带有target属性元素 [attribute=value] [target=-blank] 选择所有使用target=\"-blank\"的元素 [attribute~=value] [title~=flower] 选择标题属性包含单词\"flower\"的所有元素 [attribute\\ =language] [lang\\ =en] 选择 lang属性以en为开头的所有元素 :link a:link 选择所有未访问链接 :visited a:visited 选择所有访问过的链接 :active a:active 选择活动链接 :hover a:hover 选择鼠标在链接上面时 :focus input:focus 选择具有焦点的输入元素 :first-letter p:first-letter 选择每一个元素的第一个字母 :first- p:first-line 选择每一个元素的第一行 :first-child p:first-child 指定只有当元素是其父级的第一个子级的样式。 :before p:before 在每个元素之前插入内容 :after p:after 在每个元素之后插入内容 :lang(language) p:lang(it) 选择一个lang属性的起始值=\"it\"的所有元素 [attribute^=value] a[src^=\"https\"] 选择每一个src属性的值以\"https\"开头的元素 [attribute$=value] a[src$=\".pdf\"] 选择每一个src属性的值以\".pdf\"结尾的元素 [attribute**=value*] a[src*=\"runoob\"] 选择每一个src属性的值包含子字符串\"runoob\"的元素 :first-of-type p:first-of-type 选择每个p元素是其父级的第一个p元素 :last-of-type p:last-of-type 选择每个p元素是其父级的最后一个p元素 :only-of-type p:only-of-type 选择每个p元素是其父级的唯一p元素 :only-child p:only-child 选择每个p元素是其父级的唯一子元素 :nth-child(n) p:nth-child(2) 选择每个p元素是其父级的第二个子元素 :nth-last-child(n) p:nth-last-child(2) 选择每个p元素的是其父级的第二个子元素，从最后一个子项计数 :nth-of-type(n) p:nth-of-type(2) 选择每个p元素是其父级的第二个p元素 :nth-last-of-type(n) p:nth-last-of-type(2) 选择每个p元素的是其父级的第二个p元素，从最后一个子项计数 :last-child p:last-child 择每个p元素是其父级的最后一个子级。 :root :root 选择文档的根元素 :empty p:empty 选择每个没有任何子级的p元素（包括文本节点） :target #news:target 选择当前活动的#news元素（包含该锚名称的点击的URL） :enabled input:enable 选择每一个已启用的输入元素 :disabled input:disabled 选择每一个禁用的输入元素 :checked input:checked 选择每个选中的输入元素 :not(selector) :not(p) 选择每个并非p元素的元素 ::selection ::selection 匹配元素中被用户选中或处于高亮状态的部分 :out-of-range :out-of-range 匹配值在指定区间之外的input元素 :in-range :in-range 匹配值在指定区间之内的input元素 :read-write :read-write 用于匹配可读及可写的元素 :read-only :read-only 用于匹配设置 \"readonly\"（只读） 属性的元素 :optional :optional 用于匹配可选的输入元素 :required :required 用于匹配设置了 \"required\" 属性的元素 :valid :valid 用于匹配输入值为合法的元素 :invalid :invalid 用于匹配输入值为非法的元素 属性 字体属性 Property 描述 值 font-style 指定文本的字体样式 normal/italic/oblique/inherit font-variant 以小型大写字体或者正常字体显示文本。 normal/small-caps/inherit font-weight 指定字体的粗细。 normal/bold/bolder/lighter font-size 指定文本的字体大小 必须 font-family 指定文本的字体系列 必须 font 在一个声明中设置所有的字体属性 文本属性 属性 描述 值 color 设置文本颜色 rgba(225,225,225,0.5)红,绿,蓝,透明度 line-height 设置行高,行间距 text-align 对齐元素中的文本 left,center,right text-decoration 向文本添加修饰 underline,line-through,none direction 设置文本方向。 letter-spacing 设置字符间距 text-indent 缩进元素中文本的首行 text-shadow 设置文本阴影 text-transform 控制元素中的字母 capitalize首字母大写 unicode-bidi 设置或返回文本是否被重写 vertical-align 设置元素的垂直对齐 white-space 设置元素中空白的处理方式 除非遇到或块级,内部不换行 word-spacing 设置字间距 display 设置元素应该生成的框类型 block块级 背景属性 Property 描述 值 background 简写属性，作用是将背景属性设置在一个声明中。 顺序如表排列顺序 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 url(\"URL\") background-position 设置背景图像的起始位置。 x:left,center,right,值,% y:top,middle,bottom,值,% background-repeat 设置背景图像是否及如何重复。 (no-)repeat(-x/y) background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 scroll,fixed 列表属性 属性 描述 值 list-style 简写属性。用于把所有用于列表的属性设置于一个声明中 none list-style-type 设置列表项标志的类型。 disc,circle,square,decimal list-style-image 将图象设置为列表项标志。 list-style-position 设置列表中列表项标志的位置。 超链接伪类 :link a:link 选择所有未访问链接 :visited a:visited 选择所有访问过的链接 :hover a:hover 把鼠标放在链接上的状态 :active a:active 选择正在活动链接 CSS规定:hover必须在link和visited后,active必须在hover后 input伪类 :valid input:valid 选择所有有效值的属性 :invalid input:invalid 选择所有无效的元素 :focus input:focus 选择具有焦点的输入元素 鼠标cursor属性 值 描述 url 需使用的自定义光标的 URL。 注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。 default 默认光标（通常是一个箭头） text 此光标指示文本。 move 此光标指示某对象可被移动。 crosshair 光标呈现为十字线。 pointer 光标呈现为指示链接的指针（一只手） wait 此光标指示程序正忙（通常是一只表或沙漏）。 help 此光标指示可用的帮助（通常是一个问号或一个气球）。 盒子模型 Margin(外边距) - 清除边框外的区域，外边距是透明的。 auto浏览器计算边距 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 顺序:上 右 下 左(省略的左等于右,下等于上) Border(边框) - 围绕在内边距和内容外的边框。 border:5px solid red; Content(内容) - 盒子的内容，显示文本和图像。width和height指的是content的大小. 浮动属性 float:left/right/none clear:left/right/both/none 指定周围不允许有浮动元素 overflow:hidden/visible/scroll/auto 指定内容溢出时的处理方式,父元素设为hidden可以清除浮动 float对宽度的影响 默认情况下，div的宽度是自适应auto的，在没有设置float的情况下，宽度是自动调整最大化，设置float之后，宽度自动调整最小化。 定位属性position static:默认 fixed:相对于浏览器窗口的位置 relative:相对于默认的偏移 absolute:相对于最近的已定位(非static)的父元素,否则相对于 元素重叠:z-index:一个带正负号的int值决定堆叠顺序,没有指定时,最后定位的在上面 尺寸单位 单位 描述 % 百分比 in 英寸 cm 厘米 mm 毫米 em 1em 等于当前的字体尺寸。 2em 等于当前字体尺寸的两倍。 例如，如果某元素以 12pt 显示，那么 2em 是24pt。 在 CSS 中，em 是非常有用的单位，因为它可以自动适应用户所使用的字体。 ex 一个 ex 是一个字体的 x-height。 (x-height 通常是字体尺寸的一半。) pt 磅 (1 pt 等于 1/72 英寸) pc 12 点活字 (1 pc 等于 12 点) px 像素 (计算机屏幕上的一个点) "},"front_end/html.html":{"url":"front_end/html.html","title":"HTML5","keywords":"","body":"HTML5 声明是HTML5文件 定义一个注释 元数据和脚本 标签名 作用 head 头部元素的容器，必须包含title，可以包含其他元数据标签 title 标题（必需） meta 元数据，定义HTML本身的文档信息 base 为页面内的所有相对链接规定默认URL或默认目标 link 定义文档与外部资源的关系，如链接css style 定义CSS样式文件，属性type默认值为text/css。 script 定义JavaScript脚本， noscript 浏览器不支持脚本时显示内部的内容，内部可以包含任何HTML元素 meta标签 base标签 属性 href：规定页面中所有相对链接的基准 URL。 target：规定所有超链接和表单在何处打开。会被每个链接自身的target覆盖。值为：_blank，_parent，_self，_top，framename。 link标签 属性 href：定义被链接文档的位置。值为URL。 hreflang：定义被连接文档中文本的语言。 ref：必需。定义当前文档与被连接文档之间的关系。值为stylesheet，icon等 media：规定链接文档将显示在什么设备上。 script标签 属性 src：规定外部脚本的URL。 type：默认为text/javascript。 charset：规定脚本中使用的字符编码（仅适用于外部脚本）。 async：规定异步执行脚本（仅适用于外部脚本）。 defer：规定当页面已完成解析后，执行脚本（仅适用于外部脚本）。 没有 defer 或 async，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。 有 async，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。 有 defer，文档的解析不会停止，其他线程将下载脚本，待到文档解析完成，脚本才会执行。 async和defer都不能保证脚本按照加载顺序执行。 文档章节 标签名 作用 body 定义文档主体的部分 h1~h6 定义HTML标题，不同级别标题样式不同。 hgroup 被用来对标题元素进行分组。 article 定义一个文章内容。 aside 定义 标签外的内容。 address 定义文档作者或拥有者的联系信息。 section 定义了文档的某个区域。 header 定义一个文档头部部分。 footer 定义一个文档底部。 nav 定义导航链接的部分。 文本级别语义 标签名 作用 span 定义文档中的行内元素。前后不会换行。没有结构上的意义。 a 定义超链接。 ruby 定义 ruby 注释（中文注音或字符）。 rt 在 ruby 中使用，定义字符（中文注音或字符）的解释或发音。 rp 在 ruby 中使用，以定义不支持 ruby 元素的浏览器所显示的内容。 em 呈现为被强调的文本。效果是类似斜体。 strong 定义重要的文本。效果是类似加粗。 dfn 定义一个定义项目。 code 定义计算机代码文本。 samp 定义样本文本。 kbd 定义键盘文本。它表示文本是从键盘上键入的。它经常用在与计算机相关的文档或手册中。 var 定义变量。您可以将此标签与 及 标签配合使用。 abbr 定义一个缩写。 q 定义短的引用。属性cite：规定引用的源URL。 cite 定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。 time 定义一个日期/时间。也可以用属性datetime规定日期/时间。 i 定义斜体文本。 b 定义粗体文本。 sub 定义下标文本。 sup 定义上标文本。 small 定义小号文本。 mark 定义带有记号的文本。背景高亮的文本。 ins 定义被插入文本。即更新修正后的文本，体现为下划线。属性：cite和datetime。 del 定义已删除的文本。即有删除线的文本。属性：cite和datetime。 s 对那些不正确、不准确或者没有用的文本进行标识。也有删除线，但替换和删除的文本用del标签。 bdi 允许您设置一段文本，使其脱离其父元素的文本方向设置。 bdo 定义文本的方向。属性dir设置文本方向：ltr从左向右和rtl从右向左。 wbr 规定在文本中的何处适合添加换行符。如单词换行时机。 a标签 属性 href：规定连接的目标URL。 hreflang：规定被连接文档的语言。 ref：规定当前文档和目标URL的关系。 target：规定在何处打开目标 URL。值有：_blank，_parent，_self，_top，framename。 type：规定目标文档的 MIME 类型。 download：定义下载链接的地址或者是下载文件的名称（不用写后缀会自动加上）。 media：规定目标 URL 的媒介类型。默认值：all。仅在 href 属性存在时使用。 组合内容 标签名 作用 br 插入一个简单的换行符。 hr 定义水平线。 div 定义一个块级元素。前后会自动换行。 p 定义一个段落 ol 定义一个有序列表 ul 定义一个无序列表 li 定义一个列表项。是ol和ul的子标签。 dl 定义一个描述列表。 dt 定义一个描述列表的项目/名字。是dl的子标签。 dd 用来描述一个描述列表的项目/名字。是dl的子标签，紧跟dt。 figure 规定独立的流内容（图像、图表、照片、代码等等）。 figcaption 为figure标签定义一个标签。一般位于figure标签的第一个或最后一个元素。 pre 定义预格式文本。通常会保留空格和换行符。而文本也会呈现为等宽字体。 blockquote 定义摘自另一个源的块引用。 表单 标签名 作用 form 定义一个 HTML 表单，用于用户输入。 input 定义一个输入控件 datalist 规定了 input 元素可能的选项列表。配合input的list属性指定datalist的id。配合子标签option。 label 定义 input 元素的标注。点击该元素会自动触发for属性里id指向的input元素的焦点。 textarea 定义多行的文本输入控件。属性：cols，rows，wrap提交时文本是否换行（soft不换行，hard换行） select 定义选择列表（下拉列表）。属性：multiple多选，size显示的项目数 optgroup 定义选择列表中相关选项的组合。属性：label组名称，disabled禁用。 option 定义选择列表中的选项。属性：selected选中，label button 定义按钮。属性：type为button，reset，submit。 fieldset 定义围绕表单中元素的边框。属性：disabled，form，name。 legend 定义 fieldset 元素的标题。 output 定义一个计算的结果 progress 定义运行中的任务进度（进程）。 meter 定义度量衡。仅用于已知最大和最小值的度量。 keygen 规定用于表单的密钥对生成器字段。 form标签 属性： action：规定提交表单时请求的URL target：规定在何处打开action的URL，值为：_blank，_parent，_self，_top，framename。 method：规定用于发送表单数据的 HTTP 方法，值为get和post。 enctype：属性规定在将表单数据发送到服务器之前如何对其进行编码。只有method=“post”时才使用。 application/x-www-form-urlencoded：默认。在发送前对所有字符进行编码（将空格转换为 \"+\" 符号，特殊字符转换为 ASCII HEX 值）。 multipart/form-data：不对字符编码。当使用有文件上传控件的表单时，该值是必需的。 text/plain：将空格转换为 \"+\" 符号，但不编码特殊字符。 name：规定表单的名称。 novalidate：如果使用该属性，表单提交时不进行验证。 accept-charset：规定表单提交时使用的字符编码列表，多个字符编码使用空格分隔。 input标签 属性 type：规定元素的类型。值为：text（默认，文本字段），button（按钮），image（图片按钮），submit（提交），reset （重置按钮，重置为默认值），radio（单选框），checkbox（复选框），file（文件），hidden（隐藏），number（数字），password（密码），color（拾色器），date（年月日），datetime（日期时间时区），datetime-local（日期时间），time（时间），month（月份和年），week（周几和年份），range（范围取值），search（搜索字段），tel（电话号码），email，url accept：规定type为file时上传文件的类型限制。值为audio/*，video/*,image/*等，多个值用逗号分隔。 alt：规定图像无法显示时，代替显示的文本。只适用type为image。。 src：规定图像的URL。只适用type为image。 height：规定图像的高度。只配合type为image。。 width：规定图像的宽度。只配合type为image。。 checked：布尔属性。会在页面加载时被预先选定。只适用type为checkbox和radio。 list：规定需要预定义选项的datalist的id。 multiple：布尔属性。允许用户输入多个值。适用type为email和file。 pattern：规定验证用的正则表达式。适用type为text、search、url、tel、email和password。 max：规定最大值。适用type为number、range、date、datetime、datetime-local、month、time 和 week。 min：规定最小值。适用type为number、range、date、datetime、datetime-local、month、time 和 week。 step：规定合法数字间隔。以0位起点，正负都可以。适用type为number、range、date、datetime、datetime-local、month、time 和 week。 required：布尔属性。规定提交前必须填写该元素。适用type为text、search、url、tel、email、password、date pickers、number、checkbox、radio和file。 name：规定元素的名称。 value：规定元素的值。 size：规定可见宽度，以字符数计，默认20。 maxlength：规定允许的最大字符数。 placeholder：规定用户输入值之前显示在输入字段中的提示信息。 autocomplete ：否应该启用自动完成功能。值为on（启动）和off（关闭）。 readonly：布尔属性。规定元素为只读，不能修改，可以选中。 autofocus：布尔属性。当页面加载时会自动获得焦点。 disabled：布尔属性。禁用元素，无法使用和无法点击。 formaction：用于覆盖form的action属性。适用于type为submit和image。 formenctype ：用于覆盖form的enctype属性。适用于type为submit和image。 formmethod ：用于覆盖form的method属性。适用于type为submit和image。 formtarget ：用于覆盖form的target属性。适用于type为submit和image。 formnovalidate ：用于覆盖form的novalidate 属性。适用于type为submit和image。 form：规定所属的一个或多个表单。值为form的id。 表格数据 标签名 作用 table 定义 HTML 表格。属性：border值为1有边框。 colgroup 对表格中的列进行组合，以便对其进行格式化。属性：span定义colgroup横跨的列数。 col 规定colgroup内部每一列的列属性。属性：span定义colgroup横跨的列数。 caption 定义表格的标题。放置到 table 标签之后。 th 定义表格中的表头单元格。属性：colspan，rowspan，headers，scope tr 定义表格中的行。 td 定义表格中的单元。属性：colspan，rowspan，headers thead 定义表格中的表头内容。 tbody 定义表格中的主体内容。 tfoot 定义表格中的表注内容（脚注）。 嵌入式内容 标签名 作用 img 定义图像。 map 定义图像映射。 area 定义图像地图内部的区域。map的内部标签。 embed 定义了一个容器，用来嵌入外部应用或者互动程序（插件）。属性：height，width，src，type。 canvas 定义画布元素，供脚本画图。属性：height和width。 object 定义嵌入的对象。属性：data(资源的URL)，form，height，width，name，type，usemap。 param 定义对象的参数。object的内部标签。属性：name和value。 iframe 定义内联框架。 audio 定义声音，比如音乐或其他音频流。 video 定义一个音频或者视频 source 定义媒体资源（比如video>和 audio）。属性：media，src，type。 track 定义媒体文件的字幕文件或其他文本文。 图像映射 img的属性usemap指定map的id或name，map标签用来规定img内可点击区域的映射。 area标签 属性 href：规定区域要跳转的目标URL。 hreflang：规定区域要跳转的目标URL的语言。 target：规定在何处打开目标URL。 type：规定目标URL的MIME类型。 media：规定区域要跳转的目标URL是为何种媒介/设备优化的。默认all。 rel：规定区域要跳转的目标URL与当前html文档之间的关系。 shape：规定区域的形状。值为：default（全部区域），rect（矩形），circle（圆形），poly（多边形）。 coords：规定区域的坐标。 shape为rect：x1,y1,x2,y2 规定矩形左上角和右下角的坐标。 shape为circ：x,y,radius 规定圆心的坐标和半径。 shape为poly：x1,y1,x2,y2,...,xn,yn 规定多边形各顶点的值。如果第一个坐标和最后一个坐标不一致，那么为了关闭多边形，浏览器必须添加最后一对坐标。 alt：规定区域的替代文本。悬浮时显示。 iframe标签 属性 src：规定显示文档的URL。 sandbox：内容定义一系列额外的限制。 \"\"：启用所有限制条件。 allow-same-origin：允许将内容作为普通来源对待。如果未使用该关键字，嵌入的内容将被视为一个独立的源。 allow-top-navigation：嵌入的页面的上下文可以导航（加载）内容到顶级的浏览上下文环境（browsing context）。如果未使用该关键字，这个操作将不可用。 allow-forms：允许表单提交。 allow-scripts：允许脚本执行。 seamless：布尔属性。没有边框和滚动条。 srcdoc：规定要显示在内联框架中的页面的 HTML 内容。配合sandbox和seamless属性。 name：定义名称。 height：定义高度。 width：定义宽度。 audio标签 属性 autoplay：布尔属性。音频在就绪后马上播放。 controls：布尔属性。向用户显示音频控件（比如播放/暂停按钮）。 loop：布尔属性。每当音频结束时重新开始播放。 muted：布尔属性。音频输出为静音。 preload：规定当网页加载时，音频是否默认被加载以及如何被加载。值为：auto（载入音频），meta（载入元数据），none（不载入）。 src：规定音频文件的 URL。 video标签 属性 autoplay：布尔属性。视频在就绪后马上播放。 controls：布尔属性。向用户显示视频控件（比如播放/暂停按钮）。 loop：布尔属性。每当视频结束时重新开始播放。 muted：布尔属性。视频的音频输出为静音。 preload：规定是否在页面加载后载入视频。如果设置了 autoplay 属性，则忽略该属性。值为：auto（载入视频/音频），meta（载入元数据），none（不载入）。 src：规定视频文件的 URL。 poster：规定视频正在下载时显示的图像URL，直到用户点击播放按钮。 height：设置视频播放器的高度。 width：设置视频播放器的宽度。 交互元素 标签名 作用 menu 定义了一个命令列表或菜单。属性：label和type。 command 定义用户可能调用的命令。属性：checked，disabled，icon，label，radiogroup，type。 details 规定了用户可见的或者隐藏的需求的补充细节。属性：open规定是否可见。 summary 定义一个可见的标题。为details的子标签。 "},"front_end/JavaScript.html":{"url":"front_end/JavaScript.html","title":"JavaScript","keywords":"","body":"JavaScript 语法 HTML 中的脚本必须位于 与 标签之间。 脚本可被放置在 HTML 页面的 和 部分中。 通常的做法是把函数放入 部分中，或者放在页面底部(操作dom需要先加载dom,所以放底部)。 格式 现在已经不用写type了,浏览器都默认了 是为当老版本浏览器不识别时,把代码注释掉. 行内使用: 外部引用:JavaScript代码1 注意:JavaScript代码1会被myScript.js覆盖,无法执行. 变量 对大小写敏感,命名规则和java相同 用var声明变量,无需变量类型,文本值用\"\"或'',否则当成数值.可一次声明多个变量 var pi=3.14; var person=\"John Doe\"; var answer='Yes I am!'; var lastname=\"Doe\", age=30, job=\"carpenter\"; 细节: 未赋值的变量其值是undefined. 如果重新声明 JavaScript 变量，该变量的值不会丢失. 变量可以重复赋不同类型的值 不写var也可以声明变量,等效于window.变量名 句尾的;可以省略,但不推荐省略. 数据类型 字符串（String）、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空（Null）、未定义（Undefined）、函数(Function)、日期(Date)。null表示值为空,用于清空值,undefined表示未定义或定义未赋值 typeof操作符 typeof \"John\" // 返回 string typeof 3.14 // 返回 number typeof false // 返回 boolean typeof [1,2,3,4] // 返回 object typeof {name:'John', age:34} // 返回 object typeof function () {} // 返回 function typeof undefined // undefined typeof null // object null === undefined // false null == undefined // true 注意:JavaScript中的==比较值,===比较值和类型. for in循环 for(var num in nums){}类似于for each,用于遍历 num是nums的下标或属性名 循环对象属性： var person = {fname:\"John\", lname:\"Doe\", age:25}; var text = \"\"; var x; for (x in person) { text += person[x]; } text 输出结果为:John Doe 25 函数定义 函数声明格式 function functionName(parameters) { 执行的代码 } 函数可以通过函数表达式定义一个匿名函数存在变量里使用 实例: //var myFunction = new Function(\"a\", \"b\", \"return a * b\"); 不推荐使用,JavaScript应避免使用new var myFunction = function (a, b) {return a * b} var x = myFunction(4, 3); 匿名函数的声明和使用：( function(a,b){return ab} )()加粗部分为声明 每个函数都包含两个非继承而来的方法,call()方法和apply()方法 apply([thisObj [,argArray] ]); call([thisObj[,arg1 [,arg2 [,...,argn]]]]); 如果没有提供thisObj参数，那么Global对象被用于thisObj function add(c,d){ return this.a + this.b + c + d; } var s = {a:1, b:2}; console.log(add.call(s,3,4)); // 1+2+3+4 = 10 console.log(add.apply(s,[5,6])); // 1+2+5+6 = 14 对象 定义:对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： var person = {firstName:\"John\", lastName:\"Doe\", age:50, eyeColor:\"blue\"}; name : value的键值对称为对象的属性.JavaScript 对象是属性变量的容器。 访问对象属性:1)person.lastName; 2)person[\"lastName\"]; 对象方法: 你可以使用以下语法创建对象方法： methodName : function() { code lines } 你可以使用以下语法访问对象方法： objectName.methodName() 你可以使用以下语法获取对象方法定义函数的字符串: objectName.methodName 函数 alert(\"提示信息\"); prompt(\"提示信息\",\"输入框默认信息(可选项)\");返回输入的字符串 confirm(\"确认信息?\"); 确定返回true,取消返回否false isNaN(value)数值返回false,参数值为 NaN 或字符串、对象、undefined等非数字值返回true eval(string)计算 JavaScript 字符串，并把它作为脚本代码来执行。 类型转换 parseInt(string,radix) radix表示string是什么进制的数(范围2~36) 忽略字符串前面的空格，直至找到第一个非空字符,还会将数字后面的非数字的字符串去掉。 如果第一个字符不是数字符号或者负号，返回NaN 会将小数取整。（向下取整） parseFloat(string) document.write(parseFloat(\"10\") + \"\"); //10 document.write(parseFloat(\"10.33\") + \"\"); //10.33 document.write(parseFloat(\"34 45 66\") + \"\"); //34 document.write(parseFloat(\" 60 \") + \"\"); //60 document.write(parseFloat(\"40 years\") + \"\"); //40 document.write(parseFloat(\"He was 40\") + \"\"); //NaN 与parseInt一样，唯一区别是parseFloat可以保留小数。 toString()对象共有函数,返回字符串 String(object) Number(object) object可选,不写返回0 document.write(Number(new Boolean(true))+ \"\"); document.write(Number(new Boolean(false))+ \"\"); document.write(Number(new Date())+ \"\"); document.write(Number(String(\"999\"))+ \"\"); document.write(Number(String(\"999 888\"))+ \"\"); 如果转换的内容本身就是一个数值类型的字符串，那么将来在转换的时候会返回自己。 如果转换的内容本身不是一个数值类型的字符串，那么在转换的时候结果是NaN. 如果要转换的内容是空的字符串，那以转换的结果是0. 如果是其它的字符，那么将来在转换的时候结果是NaN. Boolean(object) 转换成boolean,除了false,\"\",0,NaN,undefined都转换成true !!(object)也可以转换成boolean 隐式转换: 5 + null // 返回 5 null 转换为 0 \"5\" + null // 返回\"5null\" null 转换为 \"null\" \"5\" + 1 // 返回 \"51\" 1 转换为 \"1\" \"5\" - 1 // 返回 4 \"5\" 转换为 5 与string进行+运算都转成string(b例外) 与Number进行运算能转换的都转换,不行的NaN if的判断条件会自动转换成boolean 异常和调试 try catch throw try { //在这里运行代码 } catch(err) { //在这里处理错误 } err.message 获取错误信息 throw exception ,exception可以使JavaScript字符串,数字,逻辑值或对象 调试 chrome浏览器可用,console.log()方法,用F12打开调试窗口,看console界面 debugger;可以设置断点,只有在调试时才会产生作用. 事件 语法: 事件 描述 onclick 用户点击 HTML 元素 ondblclick 当用户双击某个对象时调用的事件句柄。 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 onunload 用户退出页面。 ( 和 ) onfocus 元素获取焦点时触发(光标进入) onblur 元素失去焦点时触发(光标离开) onchange HTML 元素改变 onsubmit 表单提交时触发 onvalid input元素内的值无效时触发的事件 event对象 属性 描述 bubbles 返回布尔值，指示事件是否是起泡事件类型。 cancelable 返回布尔值，指示事件是否可拥可取消的默认动作。 currentTarget 返回其事件监听器触发该事件的元素。 eventPhase 返回事件传播的当前阶段。 target 返回触发此事件的元素（事件的目标节点）。 timeStamp 返回事件生成的日期和时间。 type 返回当前 Event 对象表示的事件的名称。 方法 描述 initEvent() 初始化新创建的 Event 对象的属性。 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 stopPropagation() 不再派发事件。只能中断冒泡阶段 相关方法 element.addEventListener(event, function, useCapture) event: 事件名去掉\"on\" useCapture: true在捕获阶段执行,false(默认)在冒泡阶段执行. 事件检测先从外到内检测触发位置,这个过程称为捕获,之后逐层向外返回,称为冒泡阶段. true的触发顺序总是在false之前；如果多个均为true，则外层的触发先于内层；如果多个均为false，则内层的触发先于外层. 对象 Date对象: var d = new Date();当前时间 var d = new Date(milliseconds); var d = new Date(dateString);\"October 13, 1975 11:13:00\" var d = new Date(year, month, day, hours, minutes, seconds, milliseconds); 方法 描述 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 Array对象 var cars=new Array(\"Saab\",\"Volvo\",\"BMW\"); var cars=[\"Saab\",\"Volvo\",\"BMW\"]; var cars=new Array(5); 返回一个元素值为undefined,长度为5的数组 var cars=new Array(); 返回length为0的数组 cars[0]=\"Saab\"; 可以这样向空数组加对象 cars[1]=\"Volvo\"; cars[2]=\"BMW\"; 二维数组定义 Var aa=new Array(); //定义一维数组 for(i=1;i 方法 描述 join(separator) 把数组的所有元素放入一个字符串返回。 push(参数列表) 向数组的末尾添加一个或更多元素，并返回新的长度。 sort(sortfunction) 对数组的元素进行排序。function为比较方法 小知识点 hosting:在变量与函数的作用域内，不管变量与函数在何处声明，都会被提升到作用域的顶部，但是变量初始化的顺序不变。 var myvar = '变量值'; (function() { console.log(myvar); // undefined var myvar = '内部变量值'; })(); 等效于 var myvar = '变量值'; (function() { var myvar; console.log(myvar); // undefined myvar = '内部变量值'; })(); ||和&&的用法 var c=a||b;其实等效于(a||b)?a:b; var c=a&&b;其实等效于(a&&b)?b:a; 理解:由于JavaScript中所有值都可以判断其boolean,所以传True/False和传真值等效. a||b和a&&b只需传最终决定boolean值的项. {}和[]的使用 { } 大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数。 如：var LangShen = {\"Name\":\"Langshen\",\"AGE\":\"28\"}; 访问属性可以用LangShen.Name或LangShen[\"Name\"] 事件绑定的function的this JS中绑定:$(\"sometag\").click(somefunction); html中绑定: 两种方式的区别是：前一种绑定方式，自动的把当前标签当作this元素传递给somefunction，在后一种方式不会把当前元素传递给somefunction函数， 如果需要，可以将当前元素当作somefunction的参数传入，如： 在somefunction 中用一个参数（参数名不能是this，会js自己的this冲突）捕获this就可以了。 setInterval(time(),1000)为什么只执行一次 该方法有两个重载setInterval(func,millisec)和setInterval(code,millisec) time()是函数的调用,是函数time的返回结果,其实是执行了第二个方法 time才是function变量,所以应该写成setInterval(time,1000) 或者可以写成setInterval(\"time()\",1000)调用第二个方法来实现 JavaScript特性 解释性 用于客户端 基于对象 function的自执行 (function() { /* code */ })(); 或者 (function () { /* code */ } ()); eval()的巧用 可以把字符串拼接的json数据两边的\"\"去掉,使其成为json数据 JS的操作行内style的方法 document.getElementById(\"id\").style.cssText 可以获取行内所有的css属性,对其赋值或者制空来设置或清空行内样式. js操作cookie的坑 cookie不同path下允许存在同名cookie,不同浏览器对于cookie的默认path处理不同 所以在用js设置cookie时的path和删除时的path容易因为不一致时会导致操作失效,推荐在操作cookie时带上path "},"front_end/JQuery.html":{"url":"front_end/JQuery.html","title":"JQuery","keywords":"","body":"JQuery 语法 $(selector).action(); 工厂函数​$()：将DOM对象转化为jQuery对象 选择器selector：获取需要操作的DOM元素 方法action()：jQuery中提供的方法，包括绑定事件处理的方法 “$”等同于“jQuery” $(document).ready()等同于jQuery(document).ready() $(function() {});是$(document).ready(function(){ })的简写 this，如果是取得元素的话，则对应当前元素的对象 $(this)则是当前元素被jQuery处理的对象。 事件 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress(按住不断触发,即产生字符时) submit load dblclick keydown(按住只触发一次) change resize mouseenter keyup focus获得焦点 scroll mouseleave 指针离开被选元素时 blur失去焦点 unload mousemove 鼠标指针离开任意子元素时也会被触发 事例 $(\"p\").click(function(){ // 动作触发后执行的代码!! }); 事件绑定 $(selector).bind(event,data,function,map) $(selector).on(event,childSelector,data,function,map) event 必需。规定添加到元素的一个或多个事件。 由空格分隔多个事件值。必须是有效的事件。 data 可选。规定传递到函数的额外数据。 function 必需。规定当事件发生时运行的函数。 map 规定事件映射 ({event:function, event:function, ...})，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。 例如: 1,多个事件 $(\"p\").bind(\"mouseover mouseout\",function(){ $(\"p\").toggleClass(\"intro\"); }); 2,事件映射 $(\"button\").bind({ click:function(){$(\"p\").slideToggle();}, mouseover:function(){$(\"body\").css(\"background-color\",\"#E9E9E4\");}, mouseout:function(){$(\"body\").css(\"background-color\",\"#FFFFFF\");} }); 事件解绑 $(selector).unbind(event,function,eventObj) $(selector).off(event,selector,function(eventObj),map) 参数 描述 event unbind可选,off必需。规定一个或多个要从元素上移除的事件。 由空格分隔多个事件值。 如果只规定了该参数，则会删除绑定到指定事件的所有函数。 function 可选。规定从元素上指定事件取消绑定的函数名称。 eventObj 可选。规定要使用的移除的 event 对象。这个 eventObj 参数来自事件绑定函数。 动画效果 隐藏/显示 $(selector).hide(speed,callback);隐藏 $(selector).show(speed,callback);显示 $(selector).toggle(speed,callback);切换 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 淡入/淡出 jQuery fadeIn()/fadeOut()方法 jQuery fadeIn() 用于淡入已隐藏的元素。 语法: $(selector).fadeIn(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 向下滑动/向上滑动 slideDown()/slideUp()方法 jQuery slideDown() 方法用于向下滑动元素。 语法: $(selector).slideDown(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 jQuery slideToggle() 自定义动画 (selector).animate({styles},speed,easing,callback) 例如: $(\"button\").click(function(){ $(\"#box\").animate({height:\"300px\"}); }); 停止动画 $(selector).stop(stopAll,goToEnd) 两个可选参数都默认false jQuery HTML/CSS 查找节点 三个简单实用的用于 DOM 操作的 jQuery 方法： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素标签的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 attr(attribute) - 设置或返回被选元素的属性/值 添加元素 在被选元素的结尾插入内容 $(selector).append(content,function(index,html)) 在被选元素的结尾插入 HTML 元素 $(content).appendTo(selector) content:必需。规定要插入的内容（必须包含 HTML 标签）。 如果 content 是已存在的元素，它将从它的当前位置被移除，并被插入在被选元素之后。 在被选元素的开头插入内容 $(selector).prepend(content,function(index,html)) 在被选元素的开头插入 HTML 元素 $(content).prependTo(selector) content:必需。规定要插入的内容（必须包含 HTML 标签）。 如果 content 是已存在的元素，它将从它的当前位置被移除，并被插入在被选元素之后。 在被选元素之后插入内容 $(selector).after(content,function(index)) 在被选元素后插入 HTML 元素 $(content).insertAfter(selector) content:必需。规定要插入的内容（必须包含 HTML 标签）。 如果 content 是已存在的元素，它将从它的当前位置被移除，并被插入在被选元素之后。 在被选元素之前插入内容 $(selector).**before**(content,function(index)) 在被选元素前插入 HTML 元素 $(content).**insertBefore**(selector) content:必需。规定要插入的内容（必须包含 HTML 标签）。 如果 content 是已存在的元素，它将从它的当前位置被移除，并被插入在被选元素之后。 删除元素 移除被选元素（包含数据和事件） $(selector).remove() 从被选元素移除所有子节点和内容 $(selector).empty() 替换,复制 把被选元素替换为新的 HTML 元素 $(content).replaceAll(selector) 必须包含 HTML 标签 把被选元素替换为新的内容 $(selector).replaceWith(content,function(index)) 生成被选元素的副本,包含子节点、文本和属性。 $(selector).clone(true|false) 是否需复制事件处理程序。 CSS 1,向被选元素添加一个或多个类名 $(selector).addClass(classname,function(index,oldclass)) 2,从被选元素移除一个或多个类 $(selector).removeClass(classname,function(index,currentclass)) 规定要移除的一个或多个类名称。如需移除若干个类，请使用空格分隔类名称。如果该参数为空，则将移除所有类名称。 JSON JSON 语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 \"name\": \"菜鸟教程\" 数据由逗号分隔 { \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" } 大括号保存对象 中括号保存数组 JSON 值 JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） { \"flag\":true } 数组（在中括号中）[] 对象（在大括号中）{} null {\"runoob\":null } 表单 $(\"form\").serialize() 通过序列化表单值创建 URL 编码文本字符串:FirstName=Mickey&LastName=Mouse $(\"form\").serializeArray() 通过序列化表单值来创建对象（name 和 value）的数组。对象数组[{name:,value:},…] 表单提交的三种方法 //ajax提交 $(\"#ajaxBtn\").click(function() { var params = $(\"#myform\").serialize(); $.ajax( { type : \"POST\", url : \"RegisterAction.action\", data : params, success : function(msg) { alert(\"success: \" + msg); } }); }) //jQuery提交 $(\"#jqueryBtn\").click(function(){ $(\"#myFormId\").attr(\"action\", \"userinfo.shtml\"); $(\"#myform\").submit(); }) //js提交 $(\"#jsBtn\").click(function(){ document.myform.action=\"RegisterAction.action\"; document.myform.submit(); }) JQuery遍历两种each方法 each循环方法规定为每个匹配元素规定运行的函数。 $(selector).each(function(index,element)) index - 选择器的 index 位置(匹配的节点数组的索引) element - 当前的元素（也可使用 \"this\" 选择器） $.each方法,遍历对象的子元素为其执行的方法 遍历对象(有附加参数)： $.each(Object, function(p1, p2) { this; //这里的this指向每次遍历中Object的当前属性值 p1; p2; //访问附加参数 }, ['参数1', '参数2']); 遍历数组(有附件参数)： $.each(Array, function(p1, p2){ this; //这里的this指向每次遍历中Array的当前元素 p1; p2; //访问附加参数 }, ['参数1', '参数2']); 遍历对象(没有附加参数) $.each(Object, function(name, value) { this; //this指向当前属性的值 name; //name表示Object当前属性的名称 value; //value表示Object当前属性的值 }); 遍历数组(没有附加参数) $.each(Array, function(i, value) { this; //this指向当前元素 i; //i表示Array当前下标 value; //value表示Array当前元素 }); "},"database/function.html":{"url":"database/function.html","title":"MySQL数据库函数","keywords":"","body":"MySQL数据库函数 多行函数/聚合函数 对一组值执行计算并返回单一的值的函数,不能直接在where使用 聚合函数 支持的数据类型 描述 sum(name) 数字 对指定列中的所有非空值求和 avg(name) 数字 对指定列中的所有非空值求平均值 min(name) 数字,字符,日期 返回指定列的最小值 max(name) 数字,字符,日期 返回指定列的最大值 count([DISTINCT] name) 任意基于行的数据类型 返回匹配指定列的非空行数，*包含null，DISTINCT字段统计不重复记录。 count(expression or null) 可以统计匹配expression的行数，因为count只当参数为null时不计数，其他包括false都会计数，同理可以用count(if(expression,1,null)) 字符串函数 lower(name)/lcase() 小写 upper(name)/ucase() 大写 substr(name,off,len)/mid 截取字符串,off是第几位,len为截几个 trim(name)/LTRIM/RTRIM 去除前后的空格,删除左/右的空格 trim(s1 from s) 删除s左右两边的s1 str_to_date(str,pattern) 字符转日期pattern:%Y-%m-%d %H:%i:%s 默认日期格式为:%Y-%m-%d,会自动转型 date_format(date,pattern) 日期转字符 format(name,num) 转成千位表示,num为小数位,四舍五入 ifnull(name,value) 将null转换为指定值 char_length(name) 获取字符个数 length(name) 获取占用字节数 concat(s1,s2...) 连接多个字符串, mysql的concat函数拼接规则是 当多个拼接的字段的字段值中存在null时，返回的一定是 null。 concat_ws(x,s1,s2) 连接多个字符串以x为分隔符 insert(s1,x,len,s2) 在s1里从第x个字符开始,len个字符替换成s2 replace(s,s1,s2) 替换s中所有的s1为s2 left(s,len) 从左开始截取len个字符 right(s,len) 从右开始截取len个字符 repeat(s,len) 返回s重复len遍 LPAD(S,len,s2) 用s2填充s的左边知道总字符为len RPAD(s,len,s2) 用s2填充s的右边知道总字符为len elt(n,s1,s2...) 从后面的多个字段中返回第N个 field(s,s1,s2..) 返回s在s1,s2...中处于第几个,无返回0 日期与时间函数 now()/current_timestamp() localtime(),sysdate() 获取当前日期和时间 curdate()/current_date() 获取当前的日期,+0获得20170616类似的数值 curtime()/current_time() 获取当前的时间,+0获得时分秒拼接的数值 month(date)/monthname(date) 获取指定date的月份或月份名 dayname(date) 获取指定date的星期名 dayofweek(date) 获取指定date处于一周的第几天(周日为1) weekday(date) 获取指定date对应的星期几(一~日对应0~6) week(date) 获取指定date处于一年的第几个星期(0~) weekofyear(date) 获取指定date处于一年的第几个星期(1~) dayofyear(date) 获取指定date是一年的第几天(1~) dayofmonth(date) 获取指定date是一月的第几天(1~) year(date) 获取指定date的年份 quarter(date) 获取指定date的季度 hour(date) 获取指定date的小时 minute(date) 获取指定date的分钟 second(date) 获取指定date的秒钟 数学函数 ABS(x) 绝对值 SIGN(X) 符号函数,返回-1,0,1表示负数,零,正数 rand() 生成0~1的随机数,开区间 cell(x)/celling(x) 进一 floor(x) 去尾 round(name,num) 四舍五入,num为保留几位小数,可为负,不写取整 truncate(name,num) 保留num位小数,直接截取 MOD(x,y) 取模x%y POW(X,Y) X的Y次幂 EXP(x) e的x次幂 SQRT(X) 求x的平方根 Radians(x) x换成弧度 degrees(x) x换成角度 pi() 返回π的值 三角函数(x) 三角函数:sin,cos,tan,asin,acos,atan,cot 系统函数 version() 系统版本 connection_id() 当前用户连接数 datebase()/schema() 返回当前使用的数据库 user()/current_user() system_user()/session_user() 返回当前用户名 其他 LAST_INSERT_ID() 自动返回最后一个INSERT或 UPDATE 操作为 AUTO_INCREMENT列设置的第一个发生的值。 即一次操作产生了多行数据时,只返回第一个值 IFNULL()当为null时返回给定值 IFNULL(expression_1,expression_2); 如果expression_1不为NULL，则IFNULL函数返回expression_1; 否则返回expression_2的结果。 "},"database/MySQL.html":{"url":"database/MySQL.html","title":"MySQL","keywords":"","body":"MySQL 数据类型 日期和时间数据类型 MySQL数据类型 含义 date 3字节，日期，格式：2014-09-18 time 3字节，时间，格式：08:42:30 datetime 8字节，日期时间，格式：2014-09-18 08:42:30 timestamp 4字节，自动存储记录修改的时间 year 1字节，年份 整型 MySQL数据类型 含义（有符号） tinyint 1字节，范围（-128~127） smallint 2字节，范围（-32768~32767） mediumint 3字节，范围（-8388608~8388607） int 4字节，范围（-2147483648~2147483647） bigint 8字节，范围（+-9.22*10的18次方） 上面定义的都是有符号的，当然了，也可以加上unsigned关键字，定义成无符号的类型，那么对应的取值范围就要翻翻了，比如：tinyint unsigned的取值范围为0~255。 int(n)需配合fillzero使用,表示int的显示位数为n位,不足的左边补0,多的原样输出,不影响内存占用大小. 浮点型 MySQL数据类型 含义 float(m, d) 4字节，单精度浮点型，m总个数，d小数位 double(m, d) 8字节，双精度浮点型，m总个数，d小数位 decimal(m, d) decimal是存储为字符串的浮点数 我在MySQL中建立了一个表，有一列为float(5, 3)；做了以下试验： 插入123.45678，最后查询得到的结果为99.999； 插入123.456，最后查询结果为99.999； 插入12.34567，最后查询结果为12.346； 所以，在使用浮点型的时候，还是要注意陷阱的，要以插入数据库中的实际结果为准。 FLOAT和DOUBLE在不指 定精度时，默认会按照实际的精度来显示，而DECIMAL在不指定精度时，默认整数为10，小数为0。 字符串数据类型 MySQL数据类型 含义 char(n)效率高 固定长度，最多255个字符 varchar(n)节省内存 可变长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 char（n）和varchar（n）中括号中n代表字符的个数，并不代表字节个数，所以当使用了中文的时候(UTF8)意味着可以插入m个中文，但是实际会占用m*3个字节。 同时char和varchar最大的区别就在于char不管实际value都会占用n个字符的空间，而varchar只会占用实际字符应该占用的空间+1，并且实际空间+1 超过char和varchar的n设置后，字符串会被截断。 char的上限为255字节，varchar的上限65535字节，text的上限为65535。 char在存储的时候会截断尾部的空格，varchar和text不会。 varchar会使用1-3个字节来存储长度，text不会。 binary属性只用于char和varchar值。当为列指定了该属性时，将以区分大小写的方式排序。与之相反，忽略binary属性时，将使用不区分大小写的方式排序。 其它类型 enum(“member1″, “member2″, … “member65535″) enum数据类型就是定义了一种枚举，最多包含65535个不同的成员。当定义了一个enum的列时，该列的值限制为列定义中声明的值。如果列声明包含NULL属性，则NULL将被认为是一个有效值，并且是默认值。如果声明了NOT NULL，则列表的第一个成员是默认值。 set(“member”, “member2″, … “member64″) set数据类型为指定一组预定义值中的零个或多个值提供了一种方法，这组值最多包括64个成员。值的选择限制为列定义中声明的值。 BLOB(Binary Large OBject)二进制大对象 专门存储图片,视频(提供视频的链接地址) CLOB(Character Large OBject)字符大对象 存储比较大的文本,4G+的字符串可以储存 常用命令 mySQL使用步骤 连接数据库:mysql -h 服务器主机地址 -u 用户名 -p 用户密码 打开/关闭服务:net start/stop mysql(mysql57) 打开数据库:use database_name 展示所有表/数据库/变量/存储引擎:show tables/databeses/variables/engines 其他命令 查看版本:mysql --version/-V 或者进入后select version() 退出mysql:quit 或者 exit 或者 \\q 或ctrl+c(mysql里可能失效) show create table table_name: \\G 查看表的创建过程的语句,\\G为格式化 show tables from database_name查看其它数据库的表 describe/desc table_name 查看表结构 结果含义:Field字段名,Type字段类型,NULL是否可以为空,Key是否是主键,Default默认值,Extra附加信息 set character_set_result='GBK'设置显示编码 source 路径 运行.sql文件 mysqldump 库名 [表名]>路径 -uroot -p123 导出数据 truncate table table_name 清空表,表结构不变,速度快 use database_name 使用数据库 set @变量名=值 //设置变量 select @变量名 //查询变量值 SQL运算符 运算符是一个保留字或字符，主要用于连接WHERE后面的条件。 算数运算符 运算符 描述 + 加法 - 把运算符两边的值相加 - 减法 - 左操作数减去右操作数 * 乘法 - 把运算符两边的值相乘 / 除法 - 左操作数除以右操作数 % 取模 - 左操作数除以右操作数后得到的余数 比较运算符 运算符 描述 = 检查两个操作数的值是否相等，如果相等则条件为真 != 检查两个操作数的值是否相等，如果不相等则条件为真。 <> 检查两个操作数的值是否相等，如果不相等则条件为真 > 检查左操作数的值是否大于右操作数的值，如果是则条件为真 检查左操作数的值是否小于右操作数的值，如果是则条件为真 >= 检查左操作数的值是否大于等于右操作数的值，如果是则条件为真 检查左操作数的值是否小于等于右操作数的值，如果是则条件为真 ! 检查左操作数的值是否不小于右操作数的值，如果是则条件为真 !> 检查左操作数的值是否不大于右操作数的值，如果是则条件为真 位运算符 运算符 描述 & 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中 \\ \\ 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中 ~ 二进制补码运算符是一元运算符，具有\"翻转\"位效应 二进制左移运算符。左操作数的值向左移动右操作数指定的位数 >> 二进制右移运算符。左操作数的值向右移动右操作数指定的位数 逻辑运算符 运算符 描述 AND AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。 BETWEEN BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。用在数字闭区间,用在字符前闭后开 EXISTS EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。 IN IN 运算符用于把某个值与一系列指定列表的值进行比较。 NOT IN IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。 LIKE LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。 GLOB GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。 NOT NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。 OR OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。 IS NULL NULL 运算符用于把某个值与 NULL 值进行比较。 IS IS 运算符与 = 相似。 IS NOT IS NOT 运算符与 != 相似。 \\ \\ 连接两个不同的字符串，得到一个新的字符串。 UNIQUE UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。 AND 和OR 的顺序优先级对判断的影响 存储引擎 MyISAM(常用) 格式文件-存储表结构的定义(mytable.frm) 数据文件-存储表行的内容(mytable.MYD) 索引文件-存储表上索引(mytable.MYI) 优点：可压缩,支持只读表(节省安全控制,检索效率高) 适用：大量数据读而少量数据更新的混合操作或者使用压缩的只读表. InnoDB(默认) 优点：支持事务,级联更新和级联删除,服务器崩溃后提供自动回复 适用：查询中包含较多数据更新操作 MEMORY 表数据及索引被存储在内存中 优点：检索速度快. 缺点:不能持久化 适用：非永久需要的数据或能从基于磁盘的表中重新生成的数据. "},"database/SQL.html":{"url":"database/SQL.html","title":"结构化查询语言(SQL)","keywords":"","body":"结构化查询语言(SQL) 不区分大小写，[]可选，非数值用''包围，字段名可以用``来包围，以区别于关键字 DDL（数据定义语言) CREATE(创建表) 1,CREATE database name --创建数据库 2,CREATE table name( --创建表(每行末尾可以用回车) col_name1 col_type(len) [not null], col_name2 col_type(len) [not null], ...); 3,CREATE table t_name1 AS SELECT col_name(s) From t_name --把查询结果当成表创建 DROP(删除表) 1,DROP database name --删除数据库 2,drop table [if exists] table_name1,table_name2 [CASCADE|RESTRICT] --删除无关数据表 3,alter table f_table_name drop FOREIGN KEY con_name[CASCADE|RESTRICT] --解除外部约束 restrict: 确保只有不存在相关视图和完整性约束的表才能删除 cascade: 任何相关视图和完整性约束一并被删除 ALTER（修改表） 1,alter table old_name rename to new_name --修改表名 2,alter table table_name • change old_name new_name new_type --修改字段名 • modify col_name new_type 约束 --修改字段类型 • add new_col_name new_type --增加字段 • drop col_name --删除字段 • alter col_name set DEFAULT value --添加默认值 3,alter table table_name --修改表级约束 add CONSTRAINT con_name --增加表级约束 • PRIMARY KEY(col)_name) --增加主键约束 • FOREIGN KEY(f_col)references m_table(M_col) --增加外键约束 • CHECK(exp) --定义约束 • DROP 约束关键字 约束名 --删除约束 DML（数据操作语言） INSERT(新增数据) 1,INSERT INTO table_name values(V1,V2,...Vn) --插入一行记录,列值同数同序(不建议使用,无法修改变结构因为会导致该语句失效) 2, INSERT INTO table_name (col1,col2...coln) values(V1,V2,....Vn) --插入指定列的值,多行插入就在values后写多个()用,隔开 3,INSERT INTO table_name SELECT col_name(s) FROM table_name1 --插入查询结果 DELETE(删除数据) 1,delete from table_name --删除所有行数据(清空表) where condition_expression --删除指定行 2,on delete cascade --外键约束定义语句，级联删除 UPDATE(更新数据) update table_name set{col_name=expression}[,...n] --修改列数据,可以多列 where condition_expression --条件语句,限定范围 例： update users set user_sex='女' where user_QQ='12302' DQL（数据查询语言） SELECT格式和顺序 1,select database(); --显示当前使用的数据库,未进库时显示所有库 2,select [distinct] col1,col2,..coln --写出要显示的列,distinct消除重复,*所有列 from table1,table2,...tablen [where conditions] --显示满足conditions的数据 [group by col_name...] --根据col_name分组并分别显示结果 --多字段分组,先按第一个分组,在对这些组按第二个分组... [聚合函数在分组之后进行计算并显示结果] [having conditions] --显示满足聚合函数的conditions的分组 [显示select选择的列项] [order by col_name[asc|desc]] --按照order_list的升序或降序排序,后跟数字指第几列 多列排序:order by col_name1 asc, col_name2 desc --按1升,2降,1优先级高 [LIMIT index,count 或者 count] --指定显示从index(0开始)开始的count个数据,或从头开始的count个数据 (mysql独有) 连接查询 内连接INNER JOIN(交集) SELECT column_name(s) FROM table1 a [INNER] JOIN table2 b ON a.column_name=b.column_name; --等值连接 ON a.column_name between b.column_name1 and b.column_name2 --非等值连接 SELECT column_name(s) FROM table a [INNER] JOIN table b ON a.column_name1=b.column_name2; --自连接 外连接LEFT/RIGHT OUTER JOIN 执行步骤：先求笛卡尔积得结果集-->用on语句筛选-->把left/right表中未匹配的行以外部行的形式加到结果集上，并用null补全。 SELECT column_name(s) FROM table1 LEFT/RIGHT [OUTER] JOIN table2 ON table1.column_name=table2.column_name; 全连接FULL OUTER JOIN(mysql内没有) 可以用UNION把left和right结合起来就是full了 多表连接 前两个表的结果表和后一个表连接 注意：ON的条件再筛选完后会补上主表的剩余的数据加上填满null值得副表，要对主副两表做限制可以先用where筛选过后的表进行关联查询 内外连接图解 子查询 IN(以in里的值查询目标) SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,...); 或(SELECT column_name From…) EXISTS(子查询有返回行时执行外查询) SELECT column_name(s) FROM table_name WHERE column_name EXISTS(SELECT * From…) WHERE(用子查询来使用聚合函数) SELECT column_name(s) FROM table_name WHERE column_name >(SELECT avg(name) From table) FROM(把子查询作为临时表) SELECT column_name(s) FROM (SELECT * From…) SELECT(只适用于单行子查询) SELECT column_name(s),(SELECT column_name From…) FROM table_name 联合查询UNION UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 注意：UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 SELECT column_name(s) FROM table1 UNION [ALL] SELECT column_name(s) FROM table2**; All为允许重复，默认不允许，可以用''替代没有值的列 Like通配符 通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 'A_Z'：所有以 'A' 起头，另一个任何值的字原，且以'Z' 为结尾的字串。 'ABZ' 和 'A2Z' 都符合这一个模式，而 'AKKZ' 并不符合 (因为在 A 和 Z 之间有两个字原，而不是一个字原)。 'ABC%'：所有以 'ABC' 起头的字串。举例来说，'ABCD' 和 'ABCABC' 都符合这个套式。 '%XYZ'：所有以 'XYZ' 结尾的字串。举例来说，'WXYZ' 和 'ZZXYZ' 都符合这个套式。 '%AN%'：所有含有 'AN' 这个套式的字串。举例来说，'LOS ANGELES' 和 'SAN FRANCISCO' 都符合这个套式。 CASE表达式 -- 简单case CASE expr WHEN expr_value THEN case_value WHEN expr_value THEN case_value ELSE case_value END -- expr 可以是列名，也可以是函数或表达式 -- expr_value expr表达式的值 -- case_value expr满足expr_value后，整个case表达式的值 -- case搜索函数 CASE WHEN expression THEN case_value WHEN expression THEN case_value ELSE case_value END -- expression 条件表达式 -- case_value expression满足后，整个case表达式的值 使用场景：SELECT后，GROUP BY后，CHECK约束内，SET赋值时“=”后 CASE内可以使用BETWEEN，LIKE，IS NULL，IN，EXISTS等等。 "},"database/transaction.html":{"url":"database/transaction.html","title":"事务Transaction","keywords":"","body":"事务Transaction 概念 一个最小的不可再分的工作单元 一个事务对应一个完整的业务逻辑 事务只和DML语句有关系,由批量的DML语句组成 事务的四个特性(ACID) Atomicity（原子性）：事务是不可分割的。内部操作要么全成功，要么全失败。 Consistency（一致性）：事务要求所有DML语句操作,必须保持同时成功或同时失败. Isolation（隔离性）：多个并发事务之间要相互隔离，不能有干扰。 Durability（持久性）：事务一旦提交就会持久化数据(写入数据库并持久储存)，并且不能回滚。 原子性 确保原子性的方法是回滚。在MySQL中，回滚是通过回滚日志(Undo Log)实现的。回滚日志就是记录了你的多有操作的逆操作，当需要回滚时，就把这个事务的回滚日志里的操作全执行一次。 一致性 事务执行的前后都是合法的数据状态，不会违背任何的数据完整性，这就是“一致”的意思。即在事务执行前后数据都应是正确无误，逻辑自洽，完整无缺的。 隔离级别 read uncommitted（读未提交） 事务A先写数据，则事务B不允许同时进行写操作，但允许事务B读A未提交的此行数据，这里读到的数据称为脏数据,即脏读\"Dirty Read\" 底层：读不加锁,写加行级共享锁(可以读,无法修改和删除的一种数据锁,只能加共享锁)直到事务结束 read committed（读已提交） 事务A先写,事务B不能读,A提交后才能读此行数据 但可能出现不可重复读：即B前后两次读之间A修改了,导致不一致 底层:读时加行级共享锁,读完释放,写时加行级排它锁(不能加其他锁,获锁的事务可以读写)直到事务结束 repeatable read（可重复读） 事务A先写,事务B不能读写,A先读,B不能写 但可能产生幻读：即B前后两次读全表之间A插入了,导致不一致 底层:读时加行级共享锁,直到事务结束,写时加行级排他锁直到事务结束. serializable（可串行化） 事务只能一个按顺序一个执行 底层:读时,加表级共享锁,直到事务结束,写时加表级排他锁直到事务结束. 隔离级别 脏读（Dirty read） 不可重复读（Non-repeatable read） 幻读（Phantom read） 第一类丢失更新 第二类丢失更新 READ UNCOMMITED 允许 允许 允许 不允许 允许 READ COMMITED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZBLE 不允许 不允许 不允许 不允许 不允许 脏读：读取缓冲池中未提交的行数据就叫脏读，违反了事务的隔离性。 不可重复读：一个事务内，多次读到了其他已经提交的事务的更改(或删除)数据.对策：添加行级锁 幻读：一个事务内，多次读到了其他已提交事务的新增数据.对策：添加表级锁 第一类丢失更新：A事务回滚时覆盖了事务B已提交的数据 第二类丢失更新：A事务提交时覆盖了事务B已提交的数据 大部分数据库中使用提交读作为默认的隔离级别，这是出于性能和一致性的平衡，而MySQL中则默认采用可重复读作为配置。 语法 关闭/开启自动提交事务(只对当前会话有效) set autocommit = off/on; 或者 set session autocommit = off/on; 事务的使用 start transaction;或BEGIN DML语句... COMMIT; 成功时提交,持久化数据,事务终结. ROLLBACK; 失败时回滚,记录的操作都失效.事务终结 修改隔离级别 SET [无/session/global] transaction isolation level 查看隔离级别 SELECT @@[无/session/global].tx_isolation --会话/全局 "},"database/constraint.html":{"url":"database/constraint.html","title":"约束，索引，注释","keywords":"","body":"约束，索引，注释 数据完整性(data integrity) 数据完整性(complete)、一致性(consistent)1和准确无误(accurate)的程度。 存储在数据库中的所有数据值均正确的状态。如果数据库中存储有不正确的数据值，则该数据库称为已丧失数据完整性。 实体完整性 表中每一行记录代表一个实体，指这些实体的完整性。 方法：主键约束和唯一值约束。 域完整性 指列的值域的完整性。 方法：数据类型、CHECK约束、UNIQUE约束、default默认值、自增、not null/null 参照完整性 指表与表之间数据参照关系的完整性。 方法：外键约束FOREIGN KEY 1. 数据的自洽和逻辑关系 ↩ 约束 约束名 作用 NOT NULL/NULL 能否为空 UNIQUE 保证某列的每行都唯一，允许多个null PRIMARY KEY 主键约束，非空唯一 FOREIGN KEY 外键约束，列值参照另一表 CHECK 限制列值范围 DEFAULT '非数值'/数值 默认值 AUTO_INCREMENT 自增列 ZEROFILL 不足位0填充，自带UNSIGNED UNSIGNED 无符号的 约束的通用写法 -- 在创建列时声明 CREATE TABLE student( id int PRIMARY KEY auto_increment, tid int ZEROFILL CHECK (tid > 0), name varchar(50) UNIQUE NOT NULL, Sex varchar(10) default '男', -- 在列创建完后声明约束 [CONSTRAINT fk_student_tid] FOREIGN KEY (tid) REFERENCES teacher(id)， -- FOREIGN KEY (tid,name) REFERENCES teacher(id，name) 组合外键 -- PRIMARY KEY(id) 可以放到下面写 -- PRIMARY KEY(id，tid) 复合主键 -- UNIQUE(id,tid) -- [CONSTRAINT chk_student] CHECK (tid > 0) ); -- 用ALTER添加 ALTER TABLE student ADD PRIMARY KEY (id); ALTER TABLE student ADD UNIQUE (id); ALTER TABLE student ADD CHECK (tid > 0); ALTER TABLE student ALTER Sex SET DEFAULT '女' ALTER TABLE student ADD [CONSTRAINT fk_student_tid] FOREIGN KEY(tid) REFERENCES teacher(id); -- 用ALTER修改 ALTER TABLE student MODIFY id int primary key； ALTER TABLE student MODIFY id int primary key； ALTER TABLE student MODIFY Sex VARCHAR(50) DEFAULT '女'; ALTER TABLE student MODIFY name VARCHAR(50) unique not null; -- 删除约束 ALTER TABLE student DROP PRIMARY KEY; ALTER TABLE student DROP index name; ALTER TABLE student DROP CHECK chk_student; ALTER TABLE student DROP FOREIGN KEY fk_student_tid; 索引 索引是一个单独的、物理的数据库结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。 优缺点：提高查询速度,降低更新,删除,插入的速度 索引名称 中文名 作用 PRIMARY KEY 主键索引 自然主键(自增数)荐/业务主键(字段) UNIQUE 唯一,null除外 加速查询 + 列值唯一（可以有null） INDEX 普通索引 最基本的索引，没有任何限制 FULLTEXT 全文索引 仅可以适用于MyISAM引擎的数据表；作用于CHAR、VARCHAR、TEXT数据类型的列。 创建索引 CREATE TABLE table_name( -- CREATE 时 跟在字段后面 INDEX index_name (colname,...) } CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table(colname,...) ALTER TABLE table_name ADD [UNIQUE|INDEX|FULLTEXT] index_name ON (colname,...) -- 对于字符类型的列，可以编制“前缀索引”，length表示按照列的指定长度的字符串索引 索引列名 [(length)] [ASC|DESC] 删除索引 DROP index 索引名 on 表名 ALTER table 表名 drop 索引名 查看索引 SHOW INDEX/KEYS FROM 表名 什么时候加索引：字段数据庞大,字段很少用DML操作,字段经常出现在where条件中 外键约束定义语句 on update cascade 级联更新 注释 创建表的时候写注释 create table test1 ( field_name int comment '字段的注释' )comment='表的注释'; 修改表的注释 alter table test1 comment '修改后的表的注释'; 修改字段的注释 alter table test1 modify column field_name int comment '修改后的字段注释'; --注意：字段名和字段类型照写就行 "},"database/procedure.html":{"url":"database/procedure.html","title":"存储过程","keywords":"","body":"存储过程 语法 定义存储过程 DELIMITER // CREATE PROCEDURE sp_name ([proc_parameter[,...]]) [characteristic ...] routine_body // DELIMITER ; -- proc_parameter(存储过程参数): [ IN | OUT | INOUT ] param_name type -- type: 任何合法的MySQL数据类型 -- routine_body 存储过程体 proc_parameter(存储过程参数) IN：传入参数(默认选项)。可以是字面量或变量，在存储过程中改变该变量的值不会影响该变量在存储过程外的值，即只是传值不传址。 OUT：输出参数。只能是变量。在存储过程中该变量的值为null，存储过程结束时，把存储过程外该变量的值变成存储过程内该变量的值。即只传了一个值为null的址。 INOUT：输入输出参数。只能是变量。外部的值可以在存储过程内使用，存储过程内改变的值也会影响外部。即传了一个带本身值得址。 characteristic(特征值) LANGUAGE SQL：说明下面过程的BODY 是使用SQL 语言编写，这条是系统默认的，为今后MySQL 会支持的除SQL 外的其他语言支持的存储过程而准备。 [NOT] DETERMINISTIC：如果程序或线程总是对同样的输入参数产生同样的结果，则被认为它是“确定的”（DETERMINISTIC），否则就是“非确定”的。默认的就是NOT DETERMINISTIC。 { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：这些特征值提供子程序使用数据的内在信息，这些特征值目前只是提供给服务器，并没有根据这些特征值来约束过程实际使用数据的情况。默认使用的值是CONTAINS SQL。 CONTAINS SQL 表示子程序不包含读或写数据的语句。 NO SQL 表示子程序不包含SQL 语句。 READS SQL DATA 表示子程序包含读数据的语句，但不包含写数据的语句。 MODIFIES SQL DATA 表示子程序包含写数据的语句。如果这些特征没有明确给定。 SQL SECURITY { DEFINER | INVOKER}：可以用来指定子程序该用创建子程序者的许可来执行，还是使用调用者的许可来执行。默认值是DEFINER(创建者)。 COMMENT 'string'：存储过程或者函数的注释信息。 分隔符 MySQL默认以\";\"为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要事先用“DELIMITER //”声明当前段分隔符，让编译器把两个\"//\"之间的内容当做存储过程的代码，不会执行这些代码；“DELIMITER ;”的意为把分隔符还原。 创建函数 CREATE FUNCTION sp_name ([func_parameter[,...]]) RETURNS type [characteristic ...] routine_body 函数的参数都是类似in型的，且只能有一个返回值用return定义。 修改存储过程/函数特性 ALTER {PROCEDURE | FUNCTION} sp_name [characteristic ...] 删除存储过程/函数 DROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name 查看存储过程/函数 SHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern'] -- 查看状态 SHOW CREATE {PROCEDURE | FUNCTION} sp_name -- 查看定义 select * from information_schema.Routines where ROUTINE_NAME = 'sp_name ' 存储过程/函数的调用 CALL sp_name([parameter[,...]]) 过程体语法 变量操作 变量的定义必须写在begin/end的开头，其作用域即begin/end的范围。多层嵌套begin/end时，对于同名变量采取就近原则，优先使用本作用域内的变量。 -- 声明变量，必须复合语句的开头其他语句前，可以规定默认值。 DECLARE var_name[,...] type [DEFAULT value] -- 变量赋值，一个SET语句可以赋值多个变量。 SET var_name = expr [, var_name = expr] ... -- 把查询语句的列名域内的值赋值给变量。 SELECT col_name[,...] INTO var_name[,...] table_expr @是用户自定义变量，@@是系统定义变量 流程语句 BEGIN END语句(复合语句) [begin_label:] BEGIN 　　[statement_list] END [end_label]; IF 语句 IF search_condition THEN statement_list [ELSEIF search_condition THEN statement_list] ... [ELSE statement_list] END IF; -- search_condition 条件表达式,即where后跟的那种 -- statement_list 执行的代码语句 CASE语句 CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE； -- case_value 条件判断的变量 -- when_value 变量的取值 -- statement_list 满足特定when_value时执行的语句 CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE； -- search_condition 条件判断语句 -- statement_list 满足特定search_condition时执行的语句 LOOP语句 [begin_label:] LOOP -- 循环执行的语句 END LOOP [end_label] ; begin_label参数和end_label参数分别表示循环开始和结束的标志，这两个标志必须相同，而且都可以省略 LEAVE语句 LEAVE label ; LEAVE语句主要用于跳出循环控制，label参数表示循环的标志。 ITERATE语句 ITERATE label ; ITERATE语句是跳出本次循环，然后直接进入下一次循环。只可以出现在LOOP、REPEAT、WHILE语句内 REPEAT语句 [begin_label:] REPEAT -- 循环执行的语句 UNTIL search_condition END REPEAT [end_label] ; search_condition参数表示结束循环的条件，满足该条件时循环结束。 search_condition为0就是死循环。 WHILE语句 [begin_label:] WHILE search_condition DO -- 循环执行的语句 END WHILE [end_label] ; search_condition参数表示循环执行的条件，满足该条件时循环执行。 条件和处理 条件的定义 DECLARE condition_name CONDITION FOR condition_value condition_value(条件类型): SQLSTATE [VALUE] sqlstate_value：如ERROR 1142（42000）的42000 mysql_error_code ：如ERROR 1142（42000）的1142 条件的处理 DECLARE handler_type HANDLER FOR condition_value[,...] sp_statement handler_type ：指定错误处理方式 CONTINUE 表示继续执行下面的语句。 EXIT 则表示执行终止。 UNDO 现在还不支持。 sp_statement是处理语句，都在continue和exit之前执行。 condition_value ：表示错误类型 SQLSTATE [VALUE] sqlstate_value：包含5个字符的字符串错误值 mysql_error_code：数值类型的错误代码 cond_name：定义条件的名称 SQLWARNING 是对所有以01 开头的SQLSTATE 代码的速记。 NOT FOUND 是对所有以02 开头的SQLSTATE 代码的速记。 SQLEXCEPTION 是对所有没有被SQLWARNING 或NOT FOUND 捕获的SQLSTATE 代码的速记。 参考： MySql sqlstate代码大全 游标的使用 声明游标 DECLARE cursor_name CURSOR FOR select_statement 声明一个指向select_statement结果集的游标 OPEN 游标 OPEN cursor_name FETCH 游标 FETCH cursor_name INTO var_name [, var_name] ... 读取游标下一行数据，并存入var_name内，最后游标下移一行。 CLOSE 游标 CLOSE cursor_name 注意： 变量、条件、处理程序、游标都是通过DECLARE 定义的，它们之间是有先后顺序的要求的。变量和条件必须在最前面声明，然后才能是游标的声明，最后才可以是处理程序的声明。 表的列名一旦改变就有可能使存储过程失效 触发器 它是个特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（insert，delete，update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。 触发器可以从DBA_TRIGGERS，USER_TRIGGERS 数据字典中查到。 创建触发器 CREATE [DEFINER = { user | CURRENT_USER }] TRIGGER { BEFORE | AFTER } { INSERT | UPDATE | DELETE } ON FOR EACH ROW 说明： DEFINER：触发器触发时检查权限，一般格式为'user_name'@'host_name'。 触发器名称：触发器必须有名字，最多64个字符，可能后面会附有分隔符。它和MySQL中其他对象的命名方式基本相象 触发程序的动作时间：BEFORE AFTER. 可以设置为事件发生前或后. 事件：指明了激活触发程序的语句的类型。可以是下述值之一： INSERT：将新行插入表时激活触发程序，例如，通过INSERT、LOADDATA和REPLACE语句。 UPDATE：更改某一行时激活触发程序，例如，通过UPDATE语句。 DELETE：从表中删除某一行时激活触发程序，例如，通过DELETE和REPLACE语句。 表名称：触发器是属于某一个表的：当在这个表上执行插入、更新或删除操作的时候就导致触发器的激活。我们不能给同一张表的同一个事件安排两个触发器，而且必须引用永久性表，不能将触发程序与TEMPORARY表或视图关联起来。(MySQL 5.7支持多触发器) 触发间隔：FOR EACH ROW通知触发器每隔一行执行一次动作，而不是对整个表执行一次。 关于OLD的和NEW的列名称标识 在触发器的SQL语句中，对于表中的任意列，你会需要用到该事件发生后该列的数据NEW . column_name和事件发生前该列的数据OLD. column_name，用OLD和NEW来区分事件前后数据的变化。 对于INSERT语句,只有NEW是合法的；对于DELETE语句，只有OLD才合法；而UPDATE语句可以同时使用NEW和OLD。 触发的SQL语句：是当触发程序激活时执行的语句。如果你打算执行多个语句，可使用BEGIN ... END复合语句结构。这样，就能使用存储子程序中允许的相同语句。 删除触发器 DROP TRIGGER [schema_name.]trigger_name 说明： 方案名称（schema_name）是可选的。如果省略了schema（方案），将从当前方案中舍弃触发程序。DROP TRIGGER语句需要SUPER权限。 查询触发器 模糊查询 SHOW TRIGGERS [{FROM | IN} db_name] [LIKE 'pattern' | WHERE expr] 查询所有触发器: SELECT * FROM information_schema.`TRIGGERS` 查询触发器定义语句: select * from information_schema.triggers where TRIGGER_NAME='触发器名'; 触发器执行的语句有以下两个限制 触发程序不能调用将数据返回客户端的存储程序，也不能使用采用CALL 语句的动态SQL语句，但是允许存储程序通过参数将数据返回触发程序。也就是存储过程或者函数通过OUT或者INOUT 类型的参数将数据返回触发器是可以的，但是不能调用直接返回数据的过程。 不能在触发器中使用以显式或隐式方式开始或结束事务的语句，如START TRANSACTION、COMMIT 或ROLLBACK。 注意: MySQL 的触发器是按照BEFORE 触发器、行操作、AFTER 触发器的顺序执行的，其中任何一 步操作发生错误都不会继续执行剩下的操作。如果是对事务表进行的操作，那么会整个作为 一个事务被回滚（Rollback），但是如果是对非事务表进行的操作，那么已经更新的记录将无 法回滚，这也是设计触发器的时候需要注意的问题。 "},"database/view.html":{"url":"database/view.html","title":"视图","keywords":"","body":"视图 视图的定义保存在数据字典内。创建视图所基于的表为“基表” 创建视图 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 说明 OR REPLACE：给定了OR REPLACE子句，语句能够替换已有的同名视图。 ALGORITHM：可选的mysql算法扩展，算法会影响MySQL处理视图的方式。有以下三个值： UNDEFINED--将由MySQL选择所要使用的算法。如果可能，它倾向于MERGE而不是TEMPTABLE，这是因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。 MERGE--语句上的合并,视图的查询语句与使用视图的语句组合。 TEMPTABLE--视图的结果将被置于临时表中，然后使用它执行语句。 column_list：要想为视图的列定义明确的名称，列出由逗号隔开的列名。column_list中的名称数目必须等于SELECT语句检索的列数。若使用与源表或视图中相同的列名时可以省略column_list。 select_statement：用来创建视图的SELECT语句，可在SELECT语句中查询多个表或视图。但对SELECT语句有以下的限制： 定义视图的用户必须对所参照的表或视图有查询（即可执行SELECT语句）权限； 在定义中引用的表或视图必须存在； WITH[cascaded|local] CHECK OPTION：不写默认为cascaded cascaded：所有针对该视图执行的语句都必须满足视图和所有底层视图的where条件—— 即使那些视图不是带检查选项定义的，也是如此 local：针对这个视图执行的语句只需要满足指定了检查选项的视图的where条件就可以了 视图定义的限制条件 SELECT语句不能包含FROM子句中的子查询。 SELECT语句不能引用系统或用户变量。 SELECT语句不能引用预处理语句参数。 在存储子程序内，定义不能引用子程序参数或局部变量。 在定义中引用的表或视图必须存在。但是，创建了视图后，能够舍弃定义引用的表或视图。要想检查视图定义是否存在这类问题，可使用CHECK TABLE语句。 在定义中不能引用TEMPORARY表，不能创建TEMPORARY视图。 在视图定义中命名的表必须已存在。 不能将触发程序与视图关联在一起。 修改视图结构 ALTER [ALGORITHM = {UNDEFINED | MERGE |TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL]CHECK OPTION] 说明： 该语句用于更改已有视图的定义。其语法与CREATE VIEW类似。该语句需要具有针对视图的CREATE VIEW和DROP权限，也需要针对SELECT语句中引用的每一列的某些权限。 查看视图结构 SHOW CREATE VIEW view_name 说明： 该语句给出了1个创建给定视图的CREATE VIEW语句。 删除视图 DROP VIEW [IF EXISTS] view_name [, view_name]... [RESTRICT | CASCADE] 说明： DROP VIEW能够删除1个或多个视图。必须在每个视图上拥有DROP权限。 可以使用关键字IF EXISTS来防止因不存在的视图而出错。 如果给定了RESTRICT和CASCADE，将解析并忽略它们。 更新视图数据 概述： 视图的使用与表一样，有增删改查四种操作，且语法也与表相同。 在视图上也可以使用修改数据的DML语句，如INSERT、UPDATE和DELETE可以统称为“通过视图更新数据”。 通过视图更新数据有如下限制： 一次只能修改一个底层的基表 如果修改违反了基表的约束条件，则无法更新视图 如果视图中的列不是表中的原始列（如创建视图时使用了连接操作符、聚合函数等），则不能通过视图更新。 视图更新操作： 可更新的视图：要通过视图更新基本表数据，必须保证视图是可更新视图，即可以在INSET、UPDATE或DELETE等语句当中使用它们。对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。还有一些特定的其他结构，这类结构会使得视图不可更新。如果视图包含下述结构中的任何一种，那么它就是不可更新的： 聚合函数； DISTINCT关键字； GROUP BY子句； ORDER BY子句； HAVING子句； UNION运算符； 位于选择列表中的子查询； FROM子句中包含多个表； SELECT语句中引用了不可更新视图； 插入数据：使用INSERT语句通过视图向基本表插入数据 注意： 当视图所依赖的基本表有多个时，不能向该视图插入数据，因为这将会影响多个基本表。 对INSERT语句还有一个限制：SELECT语句中必须包含FROM子句中指定表的所有不能为空的列。 修改数据：使用UPDATE语句可以通过视图修改基本表的数据 注意：若视图是基于多个表使用联接操作而导出的，那么对这个视图执行更新操作时，每次只能影响其中的一个表。 删除数据：使用DELETE语句可以通过视图删除基本表的数据 注意：对依赖于多个基本表的视图，不能使用DELETE语句。 "},"framework/maven.html":{"url":"framework/maven.html","title":"Maven","keywords":"","body":"Maven 基本概念 Apache Maven是一个基于项目对象模型（POM）的概念，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。通过中心仓库来管理依赖。 仓库类型：local本地仓库，remote私服(局域网)，central中央仓库(互联网) 生命周期 清洁生命周期：pre-clean，clean，post-clean。 默认生命周期：compile，test，package，install，deploy。（当后面的命令执行时，会按顺序先把它之前的命令执行） 网站的生命周期：pre-site，site，post-site，site-deploy。 打包类型：pom(聚合工程)，jar(java工程)，war(web工程) group Id：即域名。如：org.apache。artifact Id：即项目名。如maven version：snapshot测试版本，release正式版本。 安装配置 官网下载，解压。 配置path环境变量指向maven的bin文奸夹。 配置conf/settings文件 配置本地仓库的路径。 配置镜像服务器。属性有id，name，url，mirrorof（被镜像服务器替代的原始服务器的id）。 阿里的镜像服务器配置 alimaven central aliyun maven http://maven.aliyun.com/nexus/content/repositories/central/ eclipse配置 配置本地maven：Eclipse→Maven→Installation和User Setting 创建索引，加快检索效率：Show View→Maven→右键rebuild index 目录结构 src 源码目录 |---main 项目主体目录 |---|---java 项目主体源代码目录 |---|---resources 项目主体配置文件目录 |---test 项目测试目录 |---|---java 项目测试源代码目录 |---|---|---resources 项目测试配置文件目录 pom.xml Maven工程核心配置文件 命令 mvn tomcat:run 部署项目 mvn -v 版本信息 mvn clean 清理（删除target目录下编译内容） mvn compile 编译源代码，一般编译模块下的src/main/java目录 mvn package 项目打包工具,会在模块下的target目录生成jar或war等文件 mvn test 测试命令,执行src/test/java/下所有XxxxTest.java的测试用例. mvn install 将打包的jar/war文件复制到你的本地仓库中,供其他模块使用 创建项目 maven module：子模块 maven project：普通maven项目或父工程。 依赖 插件配置在的。 参考：maven依赖查询。 dependencies和dependencyManagement的区别 dependencies：本项目会引入依赖。即使子项目不写该依赖项，仍会从父项目中继承该依赖（完全继承）。 dependencyManagement：本项目不会引入依赖，只是声明依赖的版本。因此子项目需要显示的声明需要用的依赖。 在子项目中不声明依赖，不会从父项目中继承依赖下来； 在子项目中声明该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom; 在子项目中声明并指定了版本号，那么会使用子项目中指定的jar版本。 依赖范围 即内的。 依赖范围 编译时使用该依赖 测试时使用该依赖 运行时使用该依赖 compile（默认） Y Y Y test - Y - provided Y Y - runtime - Y Y system Y Y - 依赖传递 A依赖B且scope为X，B依赖C且scope为Y。A与B的依赖称为第一直接依赖，B与C的依赖称为第二直接依赖。A与C的依赖称为传递性依赖，其scope如下表所示。-表示依赖不传递，即A不依赖C。 下边是X/右边是Y compile test provided runtime compile compile - - runtime test test - - test provided provided - provided provided runtime runtime - - runtime 总结 Y是compile时，A依赖C且其scope与X相同。 Y是test时，A不依赖C。 Y是provided时，只有X是provided时，A依赖C，且scope依然为provided。 Y是runtime时，当X为compile和runtime时，A依赖C且其scope为runtime，否则与X相同。 依赖冲突 A→B→C→D→E→X（version 0.1） A→F→X（version 0.2） 如上情况所示A对于X的依赖不只有一种，处理这种冲突的方法如下： 就近原则：即依赖的层级少的优先于依赖层级多的。（直接依赖优先于传递依赖就是这一规则的特殊体现）。 声明优先原则：即在依赖层级相同的情况下，声明靠前的优先于靠后的。 版本锁定：配置dependencyManagement。 排除依赖： org.springframework spring-core ${spring.version} commons-logging commons-logging 常用依赖配置 JSTL javax.servlet jstl 1.2 插件 插件配置在的。 pluginManagement类似于dependencyManagement，都是用于控制版本的。 常用插件配置 编译环境 org.apache.maven.plugins maven-compiler-plugin 3.8.0 1.8 1.8 UTF-8 tomcat配置 org.apache.tomcat.maven tomcat7-maven-plugin 2.2 8080 / UTF-8 http://xxx.xxx.xxx.xxx:8080/manager/text username password Goals命令：tomcat7:run，tomcat7:deploy，tomcat7:redeploy 远程部署 配置到远程tomcat服务器需修改该服务器的conf下的tomcat-users.xml，进行角色权限配置。 配置说明： manager-gui：允许访问html接口(即URL路径为/manager/html/) manager-script：允许访问纯文本接口(即URL路径为/manager/text/) manager-jmx：允许访问JMX代理接口(即URL路径为/manager/jmxproxy/) manager-status：允许访问Tomcat只读状态页面(即URL路径为/manager/status/) 从Tomcat Manager内部配置文件中可以得知，manager-gui、manager-script、manager-jmx均具备manager-status的权限，也就是说，manager-gui、manager-script、manager-jmx三种角色权限无需再额外添加manager-status权限，即可直接访问路径\"/manager/status/*\"。 其他配置 properties标签 2.3.15 5.1.29 4.3.1.Final pom.xml中配置properties标签，在pom.xml中可以通过${struts.version}来取得2.3.15这个值。 常见错误整理 No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK? 原因：maven编译需要JDK，而eclipse配置的是JRE。 解决：【Window】-->【Prefrences】-->【Java】-->【Installed JREs】--->【add】--->【Standard VM】--->【Directory...】--->JDK路径--->勾选配置的JDK然后确认。 "},"framework/Mybatis.html":{"url":"framework/Mybatis.html","title":"Mybatis","keywords":"","body":"Mybatis 原理 配置基础配置XML，如SqlMapConfig.xml 配置映射器XML，如mapper.xml 解析XML，SqlSessionFactoryBuilder构建出SqlSessionFactory对象 SqlSessionFactory产生SqlSession对象 SqlSession下的四大对象 Executor：执行器，由它统一调度其他三个对象来执行对应的SQL； StatementHandler：使用数据库的Statement执行操作； ParameterHandler：用于SQL对参数的处理； ResultHandler：进行最后数据集的封装返回处理； // 配置文件 String resource = \"SqlMapConfig.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 创建数据库会话实例sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个/多个记录，根据用户id查询用户信息(namespace.select的id) User user = sqlSession.selectOne(\"test.findUserById\", 10); List list = sqlSession.selectList(\"test.findUserByName\",\"小明\"); // 插入user用户的信息 sqlSession.insert(\"test.insertUser\", user); // 删除用户 sqlSession.delete(\"test.deleteUserById\",18); // 更新用户 sqlSession.update(\"test.updateUser\", user); // 提交事务 sqlSession.commit(); 原始DAO开发 编写DAO接口类 编写DAO实现类，实现类注入成员属性sqlSessionFactory，方法结构如下 @Override public User findUserById(Integer id) { SqlSession sqlSession = sqlSessionFactory.openSession(); User user = sqlSession.selectOne(\"test.findUserById\", id); // 释放资源 sqlSession.close(); return user; } 缺点：由于SQLSession是线程不安全的，所以必须放在方法内，但同时就导致方法内有很多重复冗余的代码。 mapper代理开发 编写mapper.xml 编写mapper接口（类似于DAO接口） 通过SqlSession.getMapper(接口名.class)获取实现了该接口的代理类实例，即DAO实例。 两者需要遵循一些规范才能生效 Mapper.xml文件中的namespace与mapper接口的类全限定名相同 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 基础配置XML 根元素configuration 配置Properties 加载顺序： 先加载内的的属性 然后加载resource/url指定的文件内的属性，并覆盖已读同名属性 最后读取parameterType传进来的属性值，并覆盖已读同名属性 使用：配置了的属性可以用${属性名}来调用，包括mapper.xml里也能使用 配置settings 参考：settings全部属性 配置连接池和事务管理，如果在Spring里配置则可以不写 加载映射文件 默认别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 自定义别名 在Spring里配置Mybatis XML映射文件 根元素mapper statement配置 insert into user(id,username,birthday,sex,address) values(#{id},#{username},#{birthday},#{sex},#{address}) delete from user where id=#{id} update user set username=#{username},birthday=#{birthday}, sex=#{sex},address=#{address} where id=#{id} select * from user where id = #{id} #{}和${} #{}占位符 进行java类型和jdbc类型转换 传值时会带\"\" 如果parameterType传入的是pojo类型，那么#{}中的变量名称必须是pojo中对应的属性.属性.属性... 如果parameterType传入的是基础类型值，#{}括号中可以是value或其它名称 可以有效防止sql注入 ${}拼接符 不进行java类型和jdbc类型转换 传值时不带\"\" 如果parameterType传入的是pojo类型，那么${}中的变量名称必须是pojo中对应的属性.属性.属性... 如果parameterType传输单个简单类型值，${}括号中只能是value 使用情景 mybaties排序时使用order by动态参数时需要注意，使用${}而不用#{} 模糊查询：LIKE CONCAT('%',#{value},'%') 或 LIKE '%${value}%' 定义resultMap resultMap标签 id：resultMap的标识，即statement内resultMap属性需要的值。 type：映射的pojo的全限定类名，或类型别名。 autoMapping：true（默认）或false。是否启动自动映射功能，true则自动查找与字段名小写同名的属性名，并调用setter方法。false则需要明确注明映射关系才会调用对应的setter方法。 extends：继承指定标识的resultMap的映射 id子标签：用于设置主键字段和pojo属性的映射关系 result子标签：用于设置普通字段和pojo属性的映射关系 property：pojo的属性名 column：查询结果的字段名 constructor标签：使用指定参数列表的构造函数来实例化pojo。注意：其子元素顺序必须与参数列表顺序对应 idArg子标签：标记该入参为主键 arg子标签：标记该入参为普通字段（主键使用该子元素设置也是可以的） column：查询结果的字段名 JavaType：入参的java类型名 association 标签：pojo内部pojo类型属性的映射 property：该pojo类型属性的属性名 javaType：该属性的pojo类型名或别名 resultMap：使用指定标识的resultMap映射 column：传入关联查询的字段名，多个用,隔开 select：关联查询的statement的id collection标签：对应于一对多的集合映射 property：该集合属性的属性名 javaType：该集合属性的java属性类名或别名 ofType：该集合内存的pojo类型名或别名 resultMap：使用指定标识的resultMap映射 column：传入关联查询的字段名，多个用,隔开 select：关联查询的statement的id 延迟加载：select指定的查询只有在该属性的get方法被调用的时候才会执行，并把结果映射给该参数。需配置以下设置。 discriminator标签：鉴别器，根据某个字段的值来动态选择映射类型，如果都不符合则使用父标签定义的resultMap column：用来判断的字段的名称 javaType：该字段映射的javaType，用来指定判断策略 case子标签：当column字段的值符合value属性时，使用resultType或者resultMap指定的映射关系。 INSERT返回主键 第一种方式：使用useGeneratedKeys insert into user(userName,password,comment) values(#{userName},#{password},#{comment}) useGeneratedKeys：默认false，true启用主键自增 keyProperty：把主键自增后的id写入parameterType实体类的哪个属性里。 MySQL和SQLServer支持，Oracle不支持。 第二种方式：使用获取自增id SELECT LAST_INSERT_ID() INSERT INTO t_product(productName,productDesrcible,merchantId)values(#{productName},#{productDesrcible},#{merchantId}); SELECT LAST_INSERT_ID()是查询刚刚插入的记录自增长的id的SQL语句 order：BEFORE或AFTER，表示在insert语句的之前还是之后执行 keyProperty：把主键自增后的id写入parameterType实体类的哪个属性里。 resultType：指定查询结果在java里的返回类型 第三种方式：使用生成自定义id SELECT product_seq.nextval from dual INSERT INTO t_product(productId,productName,productDesrcible,merchantId)values(#{productId},#{productName},#{productDesrcible},#{merchantId}); 动态SQL if标签 select * from user where 1=1 and id=#{id} and username like '%${username}%' 注意：要做不等于空字符串校验。 choose(when,otherwise)标签 select * from userinfo where department=#{department} where position=#{position} where gender=#{gender} 按顺序判断when中的条件出否成立，如果有一个成立，则choose结束。当choose中所有when的条件都不满则时，则执行otherwise中的sql。 where/set/trim标签 where 标签：只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where标签也会将它们去除。 set标签：只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“SET”子句。而且，若语句的结尾为,，set标签也会将它们去除。 trim标签： prefix：需要加在内部sql前面的前缀 prefixoverride：指定需要去掉的内部sql的第一个前缀 suffix：需要加在内部sql后面的后缀 suffixoverride：指定需要去掉的内部sql的最后一个后缀 sql片段 sql标签：定义一个可以被反复使用的sql片段。属性id指定sql片段的唯一标识 include标签：引用一个sql片段。属性refid指定sql片段的id。通过namespace.片段id来引用其他xml内的片段 foreach标签 collection：指定pojo的集合属性名，如果parameterType是List类型时填“list”，是数组时填“array” item：定义每次遍历生成的对象名，当为Map时指代值 index：定义遍历的索引名，当为Map时指代键 open：开始遍历时拼接的字符串 close：结束遍历时拼接的字符串 separator：便利对象之间拼接的字符串 "},"framework/Spring.html":{"url":"framework/Spring.html","title":"Spring","keywords":"","body":"Spring Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。 IoC理论 控制反转（Inversion of Control）是将组件对象的控制权从代码本身转移到外部容器的一种设计思想，主要作用是用来降低耦合度。其主要实现方式就是依赖注入（Dependency Injection，简称DI）。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 IoC底层原理 dom4j(导入并解析xml文件，获取类名) 反射机制（通过类名创建对象实例） 工厂模式（动态的注入对象依赖） IoC属性注入方式 属性注入(Setter方法注入)：灵活性好，但setter方法数量较多，时效性差，通过无参构造实例化 构造函数注入：灵活性差，重载限制太多，时效性好，通过匹配的构造方法实例化 工厂方法注入：不推荐使用，需要额外的类和代码 Spring的bean管理 xml配置bean创建 使用无参构造创建bean对象 使用工厂的静态方法创建bean对象 使用工厂的实例方法创建bean对象 Spring的属性注入 构造注入 因为一个bean代表一个对象，所以只需配一个构造方法，其他构造方法需要另配一个bean。 setter方法注入（常用） AOP理论 AOP(Aspect-Oriented Programming)面向切面编程，是一种通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态添加功能的技术。 Spring采用动态代理织入，AspectJ采用编译期织入和类装载织入 AOP相关术语 增强（Advice）(给目标对象增加功能，即织入的代码，同时它拥有执行点的方位) 切入点（Pointcut）(匹配连接点的规则，指出哪些方法需要增强) 连接点（Joinpoint）(实际匹配到切入点的方法加方位信息的具体程序执行点) 切面（Aspect）(增强和切入点组合起来就是切面，既包括对逻辑的定义，又包括连接点的定义) 代理（Proxy）(目标类被aop增强后产生的结果类，称为代理类) 目标对象（Target）(得到增强的目标类) 织入（Weaving）(增强的这个动作过程) 引介（Introduction）(类级别增强，为类动态添加接口实现逻辑) 连接点是所有能够被增强的方法，而切入点是规则指定要增强的方法。 增强处理类型: Before：前置增强处理，在目标方法前织入增强处理 AfterReturning：后置增强处理，在目标方法正常执行（不出现异常）后织入增强处理 AfterThrowing：异常增强处理，在目标方法抛出异常后织入增强处理 After：最终增强处理，不论方法是否抛出异常，都会在目标方法最后织入增强处理 Around：环绕增强处理，在目标方法的前后都可以织入增强处理 不同增强处理类型执行顺序 不同通知的执行顺序： @Around环绕通知，方法前... @Before前置通知 执行对象方法... @Around环绕通知，方法后... @AfterReturning后置通知 @After最终通知 执行... @AfterThrowing异常通知，程序出现异常了吗？ 退出方法... 相同通知的执行顺序是： 从上向下 两种动态代理 JDK动态代理 必须实现接口,才能使用 njava.lang.reflect.InvocationHandler njava.lang.reflect.Proxy CGLib动态代理 通过利用规则直接生成对应的子类代理.class，所以可以不需要实现接口，不能对final类代理。 添加CGLIB库，并在spring配置中加入 切入点的表达式 execution(? () ?) //?为可选项 //参数模式:如果入参类型为java.lang包下的类,可以直接使用类名,否则必须使用全限定名 //*代表类型任意，..代表包及其子包，.*(..)表示方法名任意且参数任意 execution(public * *(..) ) 任意public方法 execution(* *To(..)) 任意以To为后缀的方法 execution(* com.smart.Waiter.*(..)) 所有com.smart.Waiter接口定义的方法 execution(* com.smart.Waiter+.*(..)) 所有com.smart.Waiter接口和其实现类的方法 execution(* com.smart.*.*(..)) 所有com.smart包下的类的所有方法 execution(* com.smart..*.*(..)) 所有com.smart包下及其子包下的类的所有方法 execution(* com..*.*Dao.find*(..)) 所有com包下及其子包下以Dao为后缀的类的以find为前缀的方法 execution(* joke(String,int)) 匹配名为joke,入参类型为(String,int)的方法 execution(* joke(String,*)) 匹配名为joke,第一个入参为String,后一个任意的方法,但有且仅有两个入参 execution(* joke(String,..)) 匹配名为joke,第一个入参为String,后面可以有任意个(包括零)任意类型的入参 execution(* joke(Object+)) 匹配名为joke,入参类型为Object或其子类 Spring事务 配置事务管理器 支持的事务管理器： JDBC或MyBatis：org.springframework.jdbc.datasource.DataSourceTransactionManager Hibernate：org.springframework.orm.hibernate5.HibernateTransactionManager Jpa：org.springframework.orm.jpa.JpaTransactionManager Jdo：org.springframework.orm.jdo.JdoTransactionManager JTA：org.springframework.transaction.jta.JtaTransactionManager 声明式事务xml配置 Spring容器的启动配置 在web.xml里配置Listener，代码如下： org.springframework.web.context.ContextLoaderListener listener-class> 如果在web.xml里给该Listener指定要加载的xml，如： contextConfigLocation classpath:applicationContext.xml 则会去加载相应的xml，而不会去加载/WEB-INF/下的applicationContext.xml。 但是，如果没有指定的话，默认会去/WEB-INF/下加载applicationContext.xml。 注意：这里的contextConfigLocation内是对整个Spring有感知的，但是@controller会无法被MVC识别，而MVC的contextConfigLocation内只对MVC有用二者范围有区别. 路径写法 /WEB-INF/*-context.xml com/mycompany/**/applicationContext.xml file:C:/some/path/*-context.xml classpath:com/mycompany/**/applicationContext.xml 会查找到WEB-INF目录下的以\"-context.xml\"结尾的文件 在WEB-INF下的 a-context.xml b-context.xml都会被找到 com/mycompany/目录下所有的applicationContext.xml都会被找到 file 表示会根据文件系统的路径查找 这个条会找到 c盘下的/some/path目录以\"-context.xml\"的文件都会被找到 查找classpath下的com/mycompany/包中所有子包的applicationContext.xml文件 classpath：只会到你的class路径中查找找文件; classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找. 有时候会用模糊匹配的方式配置多配置文件。但是如果配置文件是在jar包里，模糊匹配就找不到了。可以用逗号或空格隔开的方式配置多个配置文件。或者配置文件在jar文件根目录除外的其他任何地方，然后根据路径名称模糊匹配即可找到。 没有资源前缀默认路径相对于WEB的部署根路径，Ant风格的匹配符：?匹配一个字符,匹配任意字符,*匹配多层路径 参考：spring配置文件路径你知多少 "},"framework/springanno.html":{"url":"framework/springanno.html","title":"Spring注解","keywords":"","body":"Spring注解 IoC注解 bean注解 @Component: 标注bean类，(\"id名\")，默认id名为首字母小写的类名，下面三个衍生注解 @Repository：用于标注持久层类，(\"id名\")，默认id名为首字母小写的类名 @Service：用于标注业务层类，(\"id名\")，默认id名为首字母小写的类名 @Controller：用于标注WEB层类，(\"id名\")，默认id名为首字母小写的类名 @RestController ：Spring4之后新加入的注解，原来返回json需要@ResponseBody和@Controller配合。即@RestController是@ResponseBody和@Controller的组合注解。 @Scope(\"protetype\")配置bean的scope属性 @Order(value=1)加载优先级,越小越高(Spring4.0加入) @Lazy 延迟到调用此属性时才注入,需同时加注在属性和bean上(Spring4.0加入) 属性注入 @Autowired 根据类型进行注入 required属性，默认true @Autowired(required = false) 找不到时注入一个null @Autowired(required = true) 找不到匹配的bean就报NoSuchBeanDefinitionException 修饰成员变量(此时可以不用写set/get方法) @Autowired @Qualifier(\"user\") //按名称注入 private User user 修饰方法/构造方法(多入参的每个都注入) @Autowired public Boss(@Qualifier(\"car\")Car car , @Qualifier(\"office\")Office office){ } 修饰集合 @Autowired(required=false) private List plugins; //将所有类型为Plugin的bean都注入进List集合 @Autowired private Map pluginMaps; //4.0新特性,key为Bean的名字,value为所有实现了Plugin的Bean @Resource （这个注解属于J2EE的），默认安照名称进行装配，名称可以通过name属性进行指定， 如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 修饰成员变量 @Resource(name=\"baseDao\") private BaseDao baseDao; 修饰方法/构造方法 @Resource public void setDataSource(DataSource dataSource) { this.dataSource = dataSource; } 修饰实体类时 @Resource用在类上的时候，Spring会把当前类作为资源放入Spring容器 参数绑定，转换注解 @RequestBody 注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。 public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception { System.out.println(items); return items; } @ResponseBody 该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端 注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据，需要注意的呢，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。 @RequestMapping(\"/login\") @ResponseBody public User login(User user){ return user; } 效果等同于如下代码： @RequestMapping(\"/login\") public void login(User user, HttpServletResponse response){ response.getWriter.write(JSONObject.fromObject(user).toString()); } @RequestMapping @RequestMapping(value=\"/item\")或@RequestMapping(\"/item）作用于类和方法,标识映射URL,带/为绝对路径(推荐) value的值是数组，可以将多个url映射到同一个方法或类, method的值为RequestMethod.GET/POST,多值用{,} @RequestMapping(value=\"/ itemsView/{id}\")：{×××}占位符，请求的URL可以是“/viewItems/1”或“/viewItems/2”，通过在方法中使用@PathVariable获取{×××}中的×××变量。 @PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上。支持REST,用于匹配RequestMapping中的{xxx}占位符参数 如果RequestMapping中表示为\"/ itemsView /{id}\"，id和形参名称一致，@PathVariable不用指定名称。 @RequestParam(value,required) value是匹配传递的参数名，等效于Request.getParamrter() required默认为true，表示必须包含对应的参数 @ModelAttribute(value) 作用于方法或形参，把返回值或参数对象存到request中，key为指定的value，本质是使用Model的addAttribute方法 Aop注解 增强注解 @Aspect 标注增强类 @Pointcut(\"execution(匹配表达式)\") public void pointcutId(){} //固定形式,方法名为pointcut的id名 切点引用修饰符: public 可视域为public protected 可视域为protected，该切点可以在当前包中的切面类，自切面类中使用 private 可视域为private，该切点只能在本切面类中使用 切点的引用：在切点表达式内用\"切面类名.切点名称\" @Before(\"pointcutId或匹配表达式\") @After(\"pointcutId或匹配表达式\") @Around(\"pointcutId或匹配表达式\") @AfterReturning(pointcut=\"pointcutId或匹配表达式\",returning=\"对应增强方法参数名\") @AfterThrowing(pointcut=\"pointcutId或匹配表达式\",throwing=\"对应增强方法参数名\") 增强织入顺序 切面类中，按定义的顺序进行织入 切面类，实现org.springframework.core.Orderd接口的，有接口方法的顺序号决定，顺序越小： 前置增强：越先织入 ， 后置增强：越后织入 ， 最终增强：越后织入 ， 环绕增强：调用原方法之前的部分先织入，调用原方法之后的部分后织入 给aspect添加@Order注解，该注解全称为：org.springframework.core.annotation.Order 事务注解 @Transactional(propagation=Propagation.REQUIRES_NEW, isolation=Isolation.READ_COMMITTED, rollbackFor={UserAccountException.class}, readOnly=false,timeout=3) @Transactional 当@Transactional加在方法上，表示对该方法应用事务。 当加在类上，表示对该类里面所有的方法都应用相同配置的事务。 属性 value:事务管理器 propagation 传播行为，默认不存在事务则新建，否则添加到已有事务 REQUIRED（默认值）：在有事务状态下执行；如当前没有事务，则创建新的事务； SUPPORTS：如当前有事务，则在事务状态下执行；如果当前没有事务，在无事务状态下执行； MANDATORY：必须在有事务状态下执行，如果当前没有事务，则抛出异常IllegalTransactionStateException； REQUIRES_NEW：创建新的事务并执行；如果当前已有事务，则将当前事务挂起； NOT_SUPPORTED：在无事务状态下执行；如果当前已有事务，则将当前事务挂起； NEVER：在无事务状态下执行；如果当前已有事务，则抛出异常IllegalTransactionStateException。 isolation 隔离级别 readOnly 是否读写 timeout 超时时间设置 "},"framework/SpringMVC.html":{"url":"framework/SpringMVC.html","title":"SpringMVC","keywords":"","body":"SpringMVC 基本概念 执行过程 执行步骤 发起请求到前端控制器(DispatcherServlet) 前端控制器请求HandlerMapping查找 Handler 可以根据xml配置、注解进行查找 处理器映射器HandlerMapping向前端控制器返回Handler 前端控制器调用处理器适配器HandlerAdapter去执行Handler 处理器适配器去执行Handler Handler执行完成给适配器返回ModelAndView 处理器适配器向前端控制器返回ModelAndView ModelAndView是springmvc框架的一个底层对象，包括 Model和view 前端控制器请求视图解析器ViewReslover去进行视图解析 根据逻辑视图名解析成真正的视图(jsp) 视图解析器向前端控制器返回View 前端控制器进行视图渲染 视图渲染将模型数据(在ModelAndView对象中)填充到request域 前端控制器向用户响应结果 配置使用 配置DispatcherServlet（前端控制器），web.xml内添加 springmvc org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:springmvc.xml 1 springmvc / 导入MVC命名空间约束 非注解配置处理器适配器和映射器。（一般不用） controller的bean id controller的bean id 使用注解配置（常用方式） 配置视图解析器 文件上传 静态资源 注解 @Controller：标识Handler类，修饰类 @RestController ：Spring4之后新加入的注解，原来返回json需要@ResponseBody和@Controller配合。即@RestController是@ResponseBody和@Controller的组合注解。 @RequestBody：将页面的json字符串转成pojo对象。 @ResponseBody ：注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据，需要注意的呢，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。 @RequestMapping(\"/login\") @ResponseBody public User login(User user){ return user; } // 效果等同于如下代码： @RequestMapping(\"/login\") public void login(User user, HttpServletResponse response){ response.getWriter.write(JSONObject.fromObject(user).toString()); } @RequestMapping(value=\"/item\")或@RequestMapping(\"/item）作用于类和方法，标识映射URL，带/为绝对路径(推荐) value的值是数组，可以将多个url映射到同一个方法或类。 method的值为RequestMethod.GET/POST，多值用{,} @PathVariable()：为支持REST，用于匹配RequestMapping中的{xxx}占位符参数 @RequestParam(value,required) 把request的参数绑定到方法的形参上 value是匹配传递的参数名，等效于Request.getParamrter() required默认为true,表示必须包含对应的参数 @ModelAttribute(value) 作用于方法： 该方法会在此controller每个方法执行前被执行。 如果方法有返回值，则使用Model的addAttribute添加该返回值为属性。 属性名为value值，如果没有value值则为首字母小写的类型名。 如下所示和@RequestMapping一起注释一个方法时，方法返回值不在表示视图名称，视图名称由RequestToViewNameTranslator根据请求\"/helloWorld.do\"转换为逻辑视图helloWorld。并且执行了model.addAttribute(\"attributeName\",\"hi\")把返回值存进了model里。 1 @Controller 2 public class HelloWorldController { 3 @RequestMapping(value = \"/helloWorld.do\") 4 @ModelAttribute(\"attributeName\") 5 public String helloWorld() { 6 return \"hi\"; 7 } 8 } 作用于形参： 会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。 @SessionAttributes(\"userSession\")只能修饰类，可以将Model中的属性同步到session当中，通过匹配参数名或者类型 String[] value：要保存到session中的参数名称 Class[] typtes：要保存的参数的类型，和value是并集关系，即互相独立起作用。 @RequestParam()自定义绑定，把请求里的参数绑定到形参里 value：传入key/value的key，即参数名称 required：true必须传此参数，否则报400 Required Integer parameter 'XXXX' is not present defaultValue：默认值，没同名参数时的默认值 参数绑定 默认支持参数类型(直接写在方法形参就可使用) HttpServletRequest获取请求信息 HttpServletResponse处理响应信息 HttpSession得到session中存放的对象 Model/ModelMap向页面传递数据（底层就是写入request域） RedirectAttributes用于重定向存储数据 简单类型绑定 基本数据类型的值，请求的参数名和形参名一致可传值 pojo绑定(和简单类型绑定同时生效,即同名两个都获得值) 形参pojo的属性名和请求参数名相同即可传值 请求参数名为item.name则匹配，某个pojo形参的item属性的name属性 pojo绑定的同时会注入pojo到request域，基础类型则不会。 数组绑定：页面多个参数name相同，形参同名数组类型即可 list绑定：页面参数名写成：items[0].name的形式 map绑定：页面参数名写成：items['name']的形式 自定义Converter 配置方式 编写自定义Converter类 // 接口的泛型就是需要转换的类型，一般是String转成目标类型 public class CustomDateConverter implements Converter { @Override public Date convert(String source) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); try { return simpleDateFormat.parse(source); } catch (ParseException e) { e.printStackTrace(); } return null; } } 原理分析：页面的参数名用来匹配形参的参数名，然后会根据形参的具体类型去自动匹配对应的转换器（如果有的话），把转换后的结果注入到变量中。 异常处理 局部异常处理 @ExceptionHandler：定义在Controller内部，作用于异常处理方法上. 例: @ExceptionHandler(value={IOException.class,SQLException.class}) public String exp(Exception ex,HttpServletRequest request) { } 全局异常处理 实现HandlerExceptionResolver接口，并配bean或者注解@Component就可以生效。 配置SimpleMappingExceptionResolver error/ioexp error/sqlexp 上传文件 需要jar包：commons-fileupload/io 前台form属性enctype=\"multipart/form-data\" 配置CommonsMultipartResolver 编写Controller方法 public String toRegister(HttpServletRequest request, @RequestParam(\"pic\") MultipartFile pic) { String filePath = request.getSession().getServletContext().getRealPath(\"upload/img\"); String picName = UUID.randomUUID()+ pic.getOriginalFilename().substring(pic.getOriginalFilename().lastIndexOf('.')); File file = new File(filePath + File.separator + picName); try { pic.transferTo(file); } catch (IllegalStateException | IOException e) { e.printStackTrace(); } return \"register\"; } MultipartFile接口 方法: String getOriginalFileName() 返回文件名.后缀 void transferTo(File file) 把文件存储到file里 虚拟目录 在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加： 访问http://localhost:8080/pic即可访问F:\\develop\\upload\\temp下的图片 拦截器 实现HandlerInterceptor接口 public class HandlerInterceptor1 implements HandlerInterceptor { //进入 Handler方法之前执行 //用于身份认证、身份授权 //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //return false表示拦截，不向下执行 //return true表示放行 return false; } //进入Handler方法之后，返回modelAndView之前执行 //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } //执行Handler完成执行此方法 //应用场景：统一异常处理，统一日志处理 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 执行顺序 preHandle按拦截器定义顺序调用 postHandler按拦截器定义逆序调用 afterCompletion按拦截器定义逆序调用 preHandle在拦截器链内它之前的所有拦截器方法返回true时调用。 postHandler在拦截器链内它之前的所有拦截器方法返回true时调用。 afterCompletion只要其自身的preHandle返回true就调用，反之返回false或不执行时都不调用。 配置拦截器 方式一(不推荐) 方式二 "},"framework/Springxml.html":{"url":"framework/Springxml.html","title":"Spring-xml配置","keywords":"","body":"Spring-xml配置 Beans命名空间 导入约束 标签 属性 id：Spring容器管理的bean实例的名称标识。不能包含特殊符号。 name：作用和id相同，但能包含特殊符号。（一般推荐用id）。 class：创建的实例的所属类的全路径。 scope：bean的作用范围。(后三个仅适用WebApplicationContext环境) singleton(默认值)：在Spring容器中仅存在一个共享的Bean实例,容器启动时实例化 prototype：每次从容器中都获取一个新的实例,被调用时才实例化 request：每次HTTP请求都会创建一个新的Bean实例 session：同一个HTTP请求共享一个Bean实例 global session：同一个全局Session共享一个Bean实例 init-method：初始化方法。紧随对象创建后执行。 destroy-method：摧毁方法。在实例被摧毁前执行。 lazy-init：当值为true时，不在随容器启动而提前实例化，但当被其他需要提前实例化的bean引用时，依然会提前实例化。 属性注入标签 标签 有属性name，value，ref。通过setter方法注入，其内可以有以下子标签 基本类型和字符串值，根据bean属性自动判断类型，注意字符实体 和空字符串 bean可以换成parent即父容器中的bean 内部bean，不能被外部引用，不写id 集合类型的标签，都是property的子标签 ，：其内可容纳的标签和property一样 内部由对组成 值 键值都必须是String类型，其内部子标签是若干值 集合合并：通过在集合标签内加入merge=\"true\"属性，来使子bean继承父bean的同名属性集合元素。 导入外部数据 导入Properties文件 classpath:com/smart/placeholder/jdbc.properties properties文件内可以引用自身文件内的属性值,如: dbName=sampledb url=jdbc:mysql://localhost:3306/${dbName} 属性引用的语法 xml配置:${属性名}，#{beanName.beanProp} 引用配置的bean的属性值或方法的返回值 基于java类：@Value(${属性名}，@Value(#{beanName.beanProp}) context:property-placeholder详解 属性: location=\"属性文件，多个之间逗号分隔,或者可以使用通配符\" file-encoding=\"文件编码\" ignore-resource-not-found=\"是否忽略找不到的属性文件，如果不忽略，找不到将抛出异常\" ignore-unresolvable=\"是否忽略解析不到的属性，如果不忽略，找不到将抛出异常.\" properties-ref=\"Spring内部Properties对象的Bean名\" ,例如XML中配置的java.util.Properties对象 local-override=\"是否本地覆盖模式，即如果true，那么properties-ref的属性将覆盖location加载的属性，否则相反\" system-properties-mode=\"系统属性模式\" ENVIRONMENT(默认):通过当前环境和本地properties解析占位符 NEVER:只通过本地properties,不通过系统环境参数 OVERRIDE:先系统环境参数后本地properties FALLBACK:先本地properties后系统环境参数 order=\"顺序\" 多个该标签配置之间的检索顺序 配置多个context:property-placeholder的方法 由于一般配置多个只会有一个生效，除了在一个里配置多个properties文件之外，就需要做如下配置: order属性决定多个配置时的加载先后顺序,数字越小越先加载 当spring加载的的ignore-unresolvable属性为false，则停止扫描剩余的，反之,则继续扫描. 由于ignore-unresolvable=\"true\"时会忽略解析不到的属性，无法报错，所以我们需要在最后加载的的ignore-unresolvable属性设为false。 多个配置文件中如果有属性名相同的情况，则后加载的会覆盖先加载的。 PropertyPlaceholderConfigurer和是等效的，以上的规则对其也适用，有时错误产生的原因就在PropertyPlaceholderConfigurer的配置上。 context命名空间 导入约束 开启注解扫描 component-scan的属性： base-package：扫描的包路径。 annotation-config：默认为true。即开启属性注解，等效于annotation-config。 resource-pattern：对资源进行筛选的正则表达式。具体细分在include-filter与exclude-filter中进行。 use-default-filters：默认为true。即会对@Component，@Controller，@Service，@Reposity等注解扫描。若值为false，则这些注解都不被扫描，需要配合include-filter指定需要的注解。即作用相当于全选和反选。 先排除黑名单,再加入白名单 include-filter与exclude-filter的type属性： annotation：注解类型 assignable_type：annotation：指定的类型 aspectj：按照Aspectj的表达式，基本上不会用到 regex：按照正则表达式 custom：自定义规则 p命名空间 导入约束 使用 特点是使用属性的形式而不是子元素配置Bean的属性 对于直接量(基本数据类型、字符串)属性：p:属性名=\"属性值\" 对于引用Bean的属性：p:属性名-ref=\"Bean的id\"，如： Aop命名空间 导入约束 配置切面 其他配置 tx命名空间 导入约束 增强事务 启用事务注解 "},"DesignPatterns/designPatterns.html":{"url":"DesignPatterns/designPatterns.html","title":"概念","keywords":"","body":"设计模式 面向对象的五个基本原则 1.单一职责原则（Single-Responsibility Principle） 定义: 一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。 优点:降低复杂性,可读性提高,维护性提高,变更引起的风险降低 推荐:接口和方法一定要做到单一职责,类的设计尽量做到只有一个原因引起变化 2.开放封闭原则（Open-Closed principle） ​ 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 3.里氏替换原则（Liskov Substitution Principle） 定义:所有引用基类（父类）的地方必须能透明地使用其子类的对象。(只要父类能出现的地方,子类就可以出现,替换为子类也不会产生任何错误和异常) 优点:增强程序的健壮性 含义: 子类必须完全实现父类的方法(父类可以被子类替代) 子类可以有自己的个性(子类不能被父类替代) 子类的方法的前置条件必须与超类中的被覆写的方法的前置条件相同或者更宽松. 覆写或实现父类的方法时输出结果可以被缩小 推荐: 在类中调用其他类时务必使用父类或接口. 如果子类不能完整地实现父类的方法,或者父类的某些方法在子类中已经发生了畸变,则建议断开父子继承关系,采用依赖,聚集和组合等关系代替继承. 4.接口隔离原则（Interface-Segregation Principle） 定义:使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口 优点:保证接口的纯洁性,接口细化. 5.依赖倒置原则（Dependency-Inversion Principle） 定义:抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要面向接口编程，而不是面向实现编程。 优点:减少类之间的耦合性,提高系统的稳定性,降低并行开发引起的风险,提高代码的可读性和可维护性. 推荐: 每个类都尽量有接口或者抽象类,或者都具备. 变量的表面类型尽量是接口或者是抽象 任何类都不应该从具体类派生 尽量不要覆写基类的方法 结合里式替换原则使用 设计模式的基本原则 2~5 6.迪米特法则(Law of Demeter) 定义:一个软件实体应当尽可能少地与其他实体发生相互作用.即当其中某一个模块发生修改时，就会尽量少地影响其他模块. 优点:解耦,提高复用率 缺点:会导致系统复杂度提高 推荐:类跳转超过两次要考虑重构 7.合成复用原则(Composite Reuse Principle) ​ 原则是尽量使用组合/聚合的方式，而不是使用继承。 "},"DesignPatterns/facade.html":{"url":"DesignPatterns/facade.html","title":"门面模式(facade)","keywords":"","body":"门面模式(facade) 定义：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行.门面模式提供一个高层次的接口,使得子系统更易于使用. 优点：减少系统的相互依赖,提高了灵活性,提高安全性. 缺点：不符合开闭原则,只能在源码上修改. 角色： Facade门面角色：此角色知晓子系统的所有功能和责任。会将所有从客户端发来的请求委派到相应的子系统中 subsystem子系统角色：可以有一个或多个，每个子系统是一个类的集合，子系统不知道门面的存在，门面是它们的客户端而已。 使用场景： 为一个复杂的模块或子系统提供一个供外界访问的接口. 子系统相对独立,外界对子系统的访问只要黑箱操作即可. 预防低水平人员带来的风险扩散. 注意事项： 一个子系统可以有多个门面,可以按功能拆分门面,或者按访问权限拆分门面 门面不参与子系统内的业务逻辑,具体逻辑可以通过封装类组合逻辑,门面访问封装类完成. 子系统 public class ClassA { /** * @Description 业务逻辑方法 */ public void doSomethingA() { System.out.println(\"子系统A的业务逻辑\"); } } 门面对象 public class Facade { /** 被委托的子系统对象 */ private ClassA a = new ClassA(); private ClassB b = new ClassB(); private ClassC c = new ClassC(); /** * @Description 提供给外部访问的方法 */ public void methodA() { this.a.doSomethingA(); } public void methodB() { this.b.doSomethingB(); } public void methodC() { this.c.doSomethingC(); } } "},"DesignPatterns/factory.html":{"url":"DesignPatterns/factory.html","title":"工厂模式(factory)","keywords":"","body":"工厂模式(factory) 工厂方法模式 定义:一个用于创建对象的接口,让子类决定实例化哪个类.工厂方法使一个类的实例化延迟到子类. 优点:良好的封装性,降低耦合性,扩展性优秀 简单工厂模式 建立一个工厂实体类，对实现了同一接口的产品类进行实例的创建。通过提供一个静态方法,返回实例,通过方法参数来决定。 多个工厂方法模式 建立一个工厂抽象类,通过与产品对应的工厂实现类对实现了同一个接口的产品类进行实例的创建.以此来避免单一工厂的方法过于巨大. 替代单例模式 通过工厂方法模式来实现单例,单例类私有化构造方法,工厂类通过反射创建单独的实例并返回,还可以扩展延时初始化lazy loading,通过管理一个存放实例的Map集合缓存. public class ProductFactory{ /** 产品单例实例的存放区 */ private static final Map prMap = new HashMap(); public static synchronized Product createProduct(Class type) throws Exception{ Product product = null; if(prMap.containsKey(type)){ product = prMap.get(type); }else{ product = type.newInstance(); prMap.put(type,product); } return product; } } 抽象工厂模式 工厂方法模式有一个问题就是，类的创建依赖工厂类，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，就用到抽象工厂模式，创建抽象工厂类，这样一旦需要增加新的功能，直接增加新的工厂实现类就可以了，不需要修改之前的代码。 定义:为创建一组相关或相互依赖的对象提供一个接口,而且无须指定它们的具体类. 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是CPU，其子类有AMD处理器、Intel处理器，则抽象CPU与具体品牌的CPU之间构成了一个产品等级结构 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如PC工厂生产的AMD处理器、AMD显卡，AMD处理器位于CPU产品等级结构中，AMD显卡位于显卡产品等级结构中，AMD处理器、AMD显卡构成了一个产品族。 在图3中，不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构。图3中一共有五个产品族，分属于三个不同的产品等级结构。我们只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一确定这个产品。 使用场景:在拥有同一主题的多个产品等级结构的情况下,把各个具体产品划分出一个个产品族,以具体工厂分别实现各个产品族内各个产品的产生为目的,抽象出抽象工厂,抽象工厂和具体工厂组成一个产品族等级结构. 优点:封装性,产品族内的约束为非公开状态,在工厂内实现. 缺点:对产品族的扩展非常困难,违反开闭原则 "},"DesignPatterns/flyweight.html":{"url":"DesignPatterns/flyweight.html","title":"享元模式(flyweight)","keywords":"","body":"享元模式(flyweight) 定义：使用共享对象可以有效的支持大量的细粒度的对象. 优点：减少创建对象,降低内存占用,增强程序的性能 缺点：分离出外部状态和内部状态,提高了系统的复杂性. 角色： Flyweight抽象享元角色：一个产品的抽象类,定义出对象的外部状态和内部状态的接口或实现. ConcreteFlyweight具体享元角色：实现抽象角色定义的业务,该角色中需要注意的是内部状态处理应该与环境无关,不应该出现一个操作改变了内部状态,同时修改了外部状态. unsharedConcreteFlyweight不可共享的享元角色：不存在外部状态或者安全要求(线程安全)不能够使用共享技术的对象,该对象一般不会出现在享元工厂里. FlyweightFactory享元工厂：就是一个池容器,提供获取对象的方法. 使用场景： 系统中存在大量相似的对象. 细粒度的对象都具备较接近的外部状态,而且内部状态与环境无关.也就是说对象没有特定身份. 需要缓冲池的场景. 抽象享元类 public abstract class AbstractFlyweight { /** 内部状态 */ private String intrinsic; /** 外部状态 */ protected final String EXTRINSIC; /** * @Description 设置外部状态 * @param EXTRINSIC 外部状态 */ public AbstractFlyweight(String EXTRINSIC) { this.EXTRINSIC = EXTRINSIC; } /** * @Description 业务逻辑 */ public abstract void operate(); public String getIntrinsic() { return intrinsic; } public void setIntrinsic(String intrinsic) { this.intrinsic = intrinsic; } } 具体享元类 public class ConcreteFlyweight1 extends AbstractFlyweight{ /** * @Description 设置外部状态 * @param EXTRINSIC 外部状态 */ public ConcreteFlyweight1(String EXTRINSIC) { super(EXTRINSIC); } /** * @Description 具体业务逻辑 */ @Override public void operate() { System.out.println(\"业务逻辑\"); } } 享元工厂类 public class FlyweightFactory { /** 池容器 */ private static HashMap pool = new HashMap(); /** * @Description 工厂方法 * @param EXTRINSIC 外部状态 * @return */ public static AbstractFlyweight getFlyweight(String EXTRINSIC) { AbstractFlyweight flyweight = null; if (pool.containsKey(EXTRINSIC)) { flyweight = pool.get(EXTRINSIC); } else { flyweight = new ConcreteFlyweight1(EXTRINSIC); pool.put(EXTRINSIC, flyweight); } return flyweight; } } "},"DesignPatterns/interpreter.html":{"url":"DesignPatterns/interpreter.html","title":"解释器模式(interpreter)","keywords":"","body":"解释器模式(interpreter) 定义：给定一门语言,定义它的文法的一种表示,并定义一个解释器,该解释器使用该表示来解释语言中的句子. 优点：扩展性好,只需增加非终结符类就行. 缺点：解释器模式会引起类膨胀,采用递归调用方法,效率问题. 角色： AbstractExpression抽象解释器 TerminalExpression终结符表达式：实现与文法中的元素关联的解释操作,一般只有一个,但有多个实例,对应不同的终结符. NonterminalExpression非终结符表达式：文法中的每条规则对应一个非终结表达式,根据逻辑的复杂程度而增加,原则上一个文法规则都对应一个非终结表达式. Context环境角色：具体到例子中是HashMap代替 使用场景： 重复发生的问题可以使用解释器模式 一个简单语法需要解释的场景 可以使用shell,JRuby,Groovy等脚本语言来代替解释器模式 Expression4J,MESP(Math Expression String Parser),Jep等开源解析工具包 抽象解释器 public abstract class AbstractExpression { public abstract Object interpret(Context context); } 终结符表达式 public class TerminalExpression extends AbstractExpression { public Object interpret(Context context) { return null; } } 非终结符表达式 public class NonterminalExpression extends AbstractExpression { public NonterminalExpression(AbstractExpression... Expression) { } public Object interpret(Context context) { return null; } } 客户类 public class Client { public static void main(String[] args) { Context ctx = new Context(); Stack stack = null; for(;;) { // 进行语法判断,并产生递归调用 } // 产生一个完整的语法树,由各个具体的语法分析进行解析 AbstractExpression exp = stack.pop(); // 具体元素进入场景 exp.interpret(ctx); } } "},"DesignPatterns/iterator.html":{"url":"DesignPatterns/iterator.html","title":"迭代器模式(iterator)","keywords":"","body":"迭代器模式(iterator) 定义：提供一种方法访问一个容器对象中各个元素,而又不需要暴露该对象的内部细节. 角色： 抽象迭代器Iterator：负责定义访问和遍历元素的接口 具体迭代器ConcreteIterator：实现迭代器接口,完成容器的遍历 抽象容器Aggregate：容器提供创建迭代器的方法 具体容器ConcreteAggregate：实现容器接口定义的方法,创建出容纳迭代器的方法 "},"DesignPatterns/mediator.html":{"url":"DesignPatterns/mediator.html","title":"中介者模式(mediator)","keywords":"","body":"中介者模式(mediator) 定义:用一个中介对象封装一系列的对象交互,中介者使各个对象不需要显示地相互作用,从而使其耦合松散,而且可以独立地改变他们之间的交互. 优点:减少类之间的依赖,把一对多,变成了一对一,降低了耦合性. 角色: 抽象中介者：中介者角色的统一接口 具体中介者角色：通过协调各同事角色实现协作行为,为此它必须依赖于各个同事角色 同事角色：拥有两种行为,自发行为,与其他同事类或中介者没有任何依赖.依赖行为,必须依赖中介者才能完成的行为. 实现: 同事类用构造函数注入中介者,中介者通过getter/setter方法注入同事类 中介者类 public abstract class AbstractMediator { /** 同事类1 */ protected ConcreteColleague1 c1; /** 同事类2 */ protected ConcreteColleague2 c2; public ConcreteColleague1 getC1() { return c1; } public void setC1(ConcreteColleague1 c1) { this.c1 = c1; } public ConcreteColleague2 getC2() { return c2; } public void setC2(ConcreteColleague2 c2) { this.c2 = c2; } /** * @Description 同事类之间的交互逻辑 */ public abstract void doSomething1(); /** * @Description 同事类之间的交互逻辑 */ public abstract void doSomething2(); } 同事类 public abstract class AbstractColleague { /** 同事类必须有中介者 */ protected AbstractMediator mediator; /** * @Description 通过构造函数注入中介者 * @param mediator 中介者对象 */ public AbstractColleague(AbstractMediator mediator) { this.mediator = mediator; } } 应用场景:N个对象之间产生了相互依赖的关系(N>2),类图呈现网状结构.而且依赖的行为不确定或者有可能发生改变的可能. "},"DesignPatterns/memento.html":{"url":"DesignPatterns/memento.html","title":"备忘录模式(memento)","keywords":"","body":"备忘录模式(memento) 定义：在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可将该对象恢复到原先保存的状态. 角色： Originator发起人角色：记录当前时刻的内部状态,负责定义哪些属于备份范围的状态,负责创建和恢复备忘录数据. Memento备忘录角色：负责存储发起人对象的内部状态,在需要的时候提供发起人需要的内部环境. Caretaker备忘录管理员角色：对备忘录进行管理,保存和提供备忘录. 扩展：clone方式的备忘录,多状态的备忘录,多备份的备忘录,封装备忘录 备忘录接口 public interface Memento { } 工具类 public class BeanUtils { /** * @Description 更新bean的属性并存在提供的map里 * @param bean 新的bean状态 * @param propMap 存放bean属性的Map类 */ public static void restoreProp(Object bean, HashMap propMap) { try { BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass()); PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor des:descriptors) { String fieldName = des.getName(); if (propMap.containsKey(fieldName)) { Method setter = des.getWriteMethod(); setter.invoke(bean,propMap.get(fieldName)); } } } catch (IntrospectionException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } /** * @Description 把bean的属性存放进Map并返回 * @param bean 需要处理的bean * @return 返回的Map */ public static HashMap backupProp(Object bean) { HashMap result = new HashMap(); try { BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass()); PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor des:descriptors) { String fieldName = des.getName(); Method getter = des.getReadMethod(); Object fieldValue = getter.invoke(bean); if (!fieldName.equalsIgnoreCase(\"class\")) { result.put(fieldName, fieldValue); } } } catch (IntrospectionException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } return result; } } 发起人角色(内部封装备忘录类) public class Originator { /** javaBean属性 */ private String state1 = \"\"; private String state2 = \"\"; private String state3 = \"\"; public String getState1() { return state1; } public void setState1(String state1) { this.state1 = state1; } public String getState2() { return state2; } public void setState2(String state2) { this.state2 = state2; } public String getState3() { return state3; } public void setState3(String state3) { this.state3 = state3; } /** * @Description 创建备忘录对象 */ public Memento createMemento() { return new ConcreteMemento(BeanUtils.backupProp(this)); } /** * @Description 更新备忘录对象 */ public void restoreMemento(Memento memento) { BeanUtils.restoreProp(this,((ConcreteMemento)memento).getStateMap()); } /** * @Description 转换成字符串输出 */ public String toString() { return \"state1 = \" + this.state1 + \"\\nstate2 = \" + this.state2 + \"\\nstate3 = \" + this.state3; } /** * @Description 备忘录内部类 * @author OrezWodahs * @date 2018年6月20日 下午4:08:20 * */ private class ConcreteMemento implements Memento { /** bean属性容器 */ private HashMap stateMap; /** * @Description 通过构造,保存bean的属性至map */ private ConcreteMemento(HashMap map) { this.stateMap = map; } private HashMap getStateMap() { return this.stateMap; } private void setStateMap(HashMap stateMap) { this.stateMap = stateMap; } } } 备忘录管理类 public class Caretaker { /** 备忘录容器 */ private HashMap memMap = new HashMap(); /** * @Description 获取一个备忘录 * @param idx 备忘录标识 * @return 对应备忘录 */ public Memento getMemento(String idx) { return this.memMap.get(idx); } /** * @Description 存储一个备忘录 * @param idx 备忘录标识 * @param memento 备忘录 */ public void setMemento(String idx,Memento memento) { this.memMap.put(idx, memento); } } "},"DesignPatterns/observer.html":{"url":"DesignPatterns/observer.html","title":"观察者模式(observer)","keywords":"","body":"观察者模式(observer) 定义：定义对象间一种一对多的依赖关系,使得每当一个对象改变状态,则所有依赖它的对象都会得到通知并被自动更新 优点：观察者和被观察者之间是抽象耦合,容易扩展,建立一套触发机制 缺点：开发效率和运行效率堪忧,推荐采用异步的方式. 角色 Subject被观察者：定义被观察者必须实现的职责,它必须能够动态的增加,取消观察者.一般是抽象类或实现类. Observer观察者：观察者接收到消息后,即进行update操作,对接收到的信息进行处理 ConcreteSubject具体被观察者：定义被观察者自己的逻辑,同时定义对哪些时间进行通知 ConcreteObject具体观察者：每个观察者在接收到消息后的处理反应是不同,拥有自己的处理逻辑 被观察者 public class Observable { /** Vector利用同步方法来线程安全，线程安全在多线程情况下不会造成数据混乱 */ private Vector obs = new Vector();; /** * @Description 新增一个观察者 * @param o */ public synchronized void addObserver(Observer o) { if (o == null) throw new NullPointerException(); if (!obs.contains(o)) { obs.addElement(o); } } /** * @Description 删除观察者 * @param o */ public synchronized void deleteObserver(Observer o) { obs.removeElement(o); } /** * @Description 通知观察者 */ public void notifyObservers() { for(Observer o :this.obs) { o.update(); } } } 观察者 public interface Observer { /** * @Description 更新方法 */ void update(); } "},"DesignPatterns/prototype.html":{"url":"DesignPatterns/prototype.html","title":"原型模式(prototype)","keywords":"","body":"原型模式(prototype) 定义:用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象. 优点:性能优良,逃避构造函数的约束 原理:实现Cloneable接口,并重写clone方法,如:(浅拷贝) public class Thing implements Cloneable{ /** 非基础类型的可变引用型变量,在浅拷贝时是不会被拷贝的 */ private ArrayList arrayList = new ArrayList(); /** * @Description Cloneable的接口是没有方法的,覆盖的是Object的clone方法 * @return 拷贝后的实例类 */ @Override protected Object clone() { Thing thing = null; try { // 调用Object的clone完成浅拷贝 thing = (Thing)super.clone(); // 手动拷贝arraylist来实现深拷贝 thing.arrayList = (ArrayList) this.arrayList.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return thing; } } 使用场景: 类初始化需要消耗非常多的资源,这个资源包括数据,硬件资源等. 通过new产生一个对象需要非常繁琐的数据准备或访问权限. 一个对象需要提供给其他对象访问,而且哥哥调用者都可能需要修改其值时. 注意: 构造函数不会被执行 浅拷贝:只拷贝本对象,对其内的数组,引用对象等都不拷贝,还是指向原生对象的内部元素地址. 深拷贝:所有的都拷贝.完全不会影响到原生对象. 实现:把不被拷贝的变量单独手动拷贝并添加到拷贝类里. 要使用clone就不能在成员变量上加final "},"DesignPatterns/proxy.html":{"url":"DesignPatterns/proxy.html","title":"代理模式(proxy)","keywords":"","body":"代理模式(proxy) 定义:为其他对象提供一种代理以控制对这个对象的访问. 优点:职责清晰,高扩展性,智能化 普通代理 定义:只需要访问代理类,不需要知道真实类的存在,通过代理类的构造方法来完成真实类的创建和绑定. public interface Subject { public void request(); } public class RealSubject implements Subject { @Override public void request() { // 业务处理 } } public class Proxy implements Subject { private Subject subject = null; public Proxy() { this.subject = new Proxy(); } public Proxy(Subject subject) { this.subject = subject; } public void request() { this.before(); this.subject.request(); this.after(); } private void after() { // 预处理 } private void before() { // 善后处理 } } 强制代理 定义:从真实类查找到代理类,不允许直接访问真实类,允许使用真实类管理的代理类访问真实类的方法.否则不能访问. 动态代理 定义:在实现阶段不关心代理谁,在运行阶段才指定代理哪个对象. 原理:java.lang.reflect.Proxy.newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)方法返回指定接口的代理类的实例，这些接口将调用方法调用到指定的调用处理程序。 public interface Subject { public void request(); } public class RealSubject implements Subject { @Override public void request() { // 业务处理 } } public class ProxyHandler implements InvocationHandler { private Subject subject = null; public ProxyHandler(Subject subject) { this.subject = subject; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 预处理 Objcet obj = method.invoke(this.subject,args); // 善后处理 return obj; } } public class Test { Subject subject = new RealSubject(); Subject proxy = (Subject)Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject..getClass().getInterfaces(), new ProxyHandler(subject)); proxy.request(); } "},"DesignPatterns/singleton.html":{"url":"DesignPatterns/singleton.html","title":"单例模式(singleton)","keywords":"","body":"单例模式(singleton) 定义:保证一个类仅有一个实例，而且自行实例化并提供一个访问它的全局访问点。 主要解决:一个全局使用的类频繁地创建与销毁。 关键代码:构造函数是私有的。 优点:减少内存开支,对性能都开销,在需要频繁创建销毁,而创建和销毁的性能又无法优化的时候使用. 缺点:扩展困难,不利于测试,与单一职责原则有冲突. 饿汉式 (推荐使用,不用考虑同步问题) public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 懒汉式(同步加synchronized) public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 双检锁/双重校验锁（DCL，即 double-checked locking） public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 登记式/静态内部类 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 枚举 public enum Singleton { INSTANCE; public void whateverMethod() { } } 经验之谈：一般情况下，不建议使用懒汉方式，建议使用饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用登记方式。如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。 "},"DesignPatterns/state.html":{"url":"DesignPatterns/state.html","title":"状态模式(state)","keywords":"","body":"状态模式(state) 定义：当一个对象的内在状态改变时允许其改变行为,这个对象看起来像改变了它的类型. 优点：结构清晰,遵循开闭原则和单一职责原则,封装性好 缺点：子类太多,类膨胀 角色 State抽象状态角色：接口或抽象类,负责对象状态的定义,并且封装环境角色以实现状态处理. ConcreteState具体状态角色：每个具体状态必须完成两个职责:本状态行为管理以及趋向状态处理,即本状态该做的事和状态过渡. Context环境角色：定义客户端需要的接口,并且负责具体状态的切换.(将状态对象声明为静态常量,具有状态抽象角色定义的所有行为,具体执行使用委托方式) 使用场景 行为随状态改变而改变的场景. 条件,分支判断语句的替代者. 抽象状态类 public abstract class AbstractState { /** 定义一个环境角色 */ protected Context context; /** * @Description 设置环境角色 */ public void setContext(Context context) { this.context = context; } /** * @Description 行为1 */ public abstract void handle1(); /** * @Description 行为2 */ public abstract void handle2(); } 具体状态类 public class ConcreteState1 extends AbstractState { /** * @Description 行为1 */ @Override public void handle1() { System.out.println(\"state1:状态1必须处理的逻辑\"); } /** * @Description 行为2,转为状态2,由状态2执行行为2 */ @Override public void handle2() { System.out.println(\"state1:转为状态2\"); super.context.setCurrentState(Context.STATE2); System.out.println(\"state1:委托context执行行为2\"); super.context.handle2(); } } public class ConcreteState2 extends AbstractState { /** * @Description 行为1,转为状态1,由状态1执行行为1 */ @Override public void handle1() { System.out.println(\"state2:转为状态1\"); super.context.setCurrentState(Context.STATE1); System.out.println(\"state2:委托context执行行为1\"); super.context.handle1(); } /** * @Description 行为2 */ @Override public void handle2() { System.out.println(\"state2:状态2必须处理的逻辑\"); } } 具体环境类 public class Context { /** 状态1 */ public static final AbstractState STATE1 = new ConcreteState1(); /** 状态2 */ public static final AbstractState STATE2 = new ConcreteState2(); /** 当前状态 */ private AbstractState CurrentState; /** * @Description 获得当前状态 * @return */ public AbstractState getCurrentState() { return CurrentState; } /** * @Description 设置当前状态 * @param currentState */ public void setCurrentState(AbstractState currentState) { this.CurrentState = currentState; this.CurrentState.setContext(this); } /** * @Description 委托执行行为1 */ public void handle1() { System.out.println(\"context:委托执行行为1\"); this.CurrentState.handle1(); } /** * @Description 委托执行行为2 */ public void handle2() { System.out.println(\"context:委托执行行为2\"); this.CurrentState.handle2(); } } "},"DesignPatterns/strategy.html":{"url":"DesignPatterns/strategy.html","title":"策略模式(strategy)","keywords":"","body":"策略模式(strategy) 定义：定义一组算法,将每个算法都封装起来,并且使他们之间可以互换. 优点：算法可以自由切换,避免使用多重条件判断,扩展性良好 缺点：策略类数量增多,所有的策略类都需要对外暴露 使用场景：多个类只有在算法上不同的场景,算法需要自由切换的场景,需要屏蔽算法规则的场景 角色: 封装角色：上下文角色,起承上启下封装作用,屏蔽高层模块对策略,算法的直接访问封装可能存在的变化 抽象策略角色：定义每个策略或算法必须具有的方法和属性. 具体策略角色：实现具体的算法. 策略枚举 public enum Calculator{ ADD(\"+\"){ public int exec(int a,int b){ return a + b; } }, SUB(\"-\"){ public int exec(int a,int b){ return a - b; } }; /** 存放符号标志 */ String value = \"\"; private Calculator(String value){ this.value = value; } public String getValue(){ return this.value; } /** * @Description 抽象算法 */ public abstract int exec(int a,int b); } 调用 Calculator.ADD.exec(a,b); Calculator.SUB.exec(a, b); "},"DesignPatterns/template.html":{"url":"DesignPatterns/template.html","title":"模板方法模式(template)","keywords":"","body":"模板方法模式(template) 定义一个算法中的操作框架，而将一些步骤延迟到子类中。使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。 使用了Java的继承机制，是一个非常广泛的模式。其中AbstractClass叫做抽象模板，它的方法分为三类： 基本方法 由子类实现的方法,在模板方法内被调用(尽量设计为protected类型，符合迪米特法则，不需要暴露的属性或方法尽量不要设置为protected类型。实现类若非必要，尽量不要扩大父类中的访问权限) 模板方法 可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调用，完成固定的逻辑。(一般都加上final关键字，防止被覆写） 钩子方法 由子类覆写的方法,返回一个boolean值,在模板方法中作为用来控制代码逻辑的一个标识. 代码举例 public abstract class AbstractClass { protected abstract void doAnything(); //基本方法 protected abstract void doSomething(); //基本方法 protected boolean isDoSomething(){ //钩子方法,默认父类方法返回真 return true; } public final void templateMethod(){ /* * 调用基本方法，完成相关的逻辑 */ this.doAnything(); if(this.isDoSomething()) this.doSomething(); } } public class ConcreteClass1 extends AbstractClass { private boolean isDoSth; @Override protected void doAnything() { //子类实现具体 } @Override protected void doSomething() { } protected void setDo(boolean isDo){ this.isDoSth = isDo; } protected boolean isDoSomething(){ return isDoSth; } } "},"DesignPatterns/visitor.html":{"url":"DesignPatterns/visitor.html","title":"访问者模式(visitor)","keywords":"","body":"访问者模式(visitor) 定义：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 优点：符合单一职责原则,优秀的扩展性,灵活性非常高 缺点：具体元素对访问者公布细节,具体元素变更比较困难,违背了依赖倒置原则 角色 Visitor抽象访问者： 声明访问者可以访问哪些元素,具体到程序就是visit方法的参数定义哪些对象是可以被访问的. ConcreteVisitor具体访问者：它影响访问者访问到一个类后具体该怎么干,要做什么事情. Element抽象元素： 声明接受哪一类访问者访问,程序上通过accept方法中的参数来定义. ConcreteElement具体元素： 实现accept方法,通常是visitor.visit(this). ObjectStruture结构对象：元素生产者,一般容纳在多个不同类,不同接口的容器.如List,Set,Map 使用场景： 一个对象结构包含很多类对象,它们有不同的接口,而你想对这些对象实施一些依赖于其具体类的操作,也就是说用迭代器模式已经不能胜任的场景. 需要对一个对象结构中的对象进行很多不同并且不相关的操作,而你想避免让这些操作\"污染\"这些对象的类. 业务规则要求遍历多个不同的对象,这本身也是访问者模式出发点,迭代器模式只能访问同类或同接口的数据(除非使用instanceof),而访问者模式可以遍历不同的对象,执行不同的操作,访问者模式还有一个用途,就是充当拦截器角色. 抽象访问者 public abstract class AbstractElement { /** * @Description 业务逻辑方法 */ public abstract void doSomething(); /** * @Description 访问者访问方法 * @param visitor 允许哪个访问者 */ public abstract void accept(Visitor Visitor); } 具体访问者 public class ConcreteElement1 extends AbstractElement { /** * @Description 业务逻辑方法 */ public void doSomething() { System.out.println(\"Element2业务逻辑\"); } /** * @Description 访问者访问方法 * @param visitor 允许哪个访问者 */ public void accept(Visitor visitor) { visitor.visit(this); } } 抽象访问者 public interface Visitor { /** * @Description 访问对象方法 * @param element1 可以访问哪些对象 */ void visit(ConcreteElement1 element1); /** * @Description 访问对象方法 * @param element2 可以访问哪些对象 */ void visit(ConcreteElement2 element2); } 具体访问者 public class VisitorImpl implements Visitor { /** * @Description 访问对象方法 * @param element1 可以访问哪些对象 */ @Override public void visit(ConcreteElement1 element1) { element1.doSomething(); } /** * @Description 访问对象方法 * @param element2 可以访问哪些对象 */ @Override public void visit(ConcreteElement2 element2) { element2.doSomething(); } } 结构对象 public class ObjectStructure { /** * @Description 对象生成器,通过一个工厂方法模式模拟 * @return */ public static AbstractElement createElement() { Random rand = new Random(); if (rand.nextInt(100) > 50) { return new ConcreteElement1(); } else { return new ConcreteElement2(); } } } "},"DesignPatterns/adapter.html":{"url":"DesignPatterns/adapter.html","title":"适配器模式(adapter)","keywords":"","body":"适配器模式(adapter) 定义：将一个类的接口变成客户端所期待的另一种接口,从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作. 优点：让两个没有任何联系的类一起运行,增加了类的透明性,提高了类的复用度,灵活性非常好 角色： 目标角色Target：定义把其他类转换为何种接口,也就是我们的期望接口. 源角色Adaptee：被转换的角色,它是已经存在的,运行良好的类或是对象,经过适配器包装,成为一个崭新的角色. 适配器角色Adapter：把源角色转换成目标角色,通过继承和类关联的方式. 类适配器：继承源角色类并实现目标角色接口,是类间继承. public class Adapter1 extends Adaptee1 implements Target { /** * @Description 实现Target方法,通过调用Adaptee的方法 */ @Override public void request() { super.doSomething(); } } 对象适配器：实现目标角色接口,通过类的关联,耦合源角色.是对象的合成关系.(使用的场景较多) public class Adapter2 implements Target { /** 存放源角色1 */ private Adaptee1 adaptee1 = null; /** 存放源角色2 */ private Adaptee2 adaptee2 = null; /** * @Description 通过构造函数设置源角色 * @param adaptee1 源角色1 * @param adaptee2 源角色2 */ public Adapter2(Adaptee1 adaptee1, Adaptee2 adaptee2) { this.adaptee1 = adaptee1; this.adaptee2 = adaptee2; } /** * @Description 实现Target的方法,调用源角色的方法 */ @Override public void request() { this.adaptee1.doSomething(); this.adaptee2.doSomething(); } } "},"DesignPatterns/bridge.html":{"url":"DesignPatterns/bridge.html","title":"桥梁模式(bridge)","keywords":"","body":"桥梁模式(bridge) 定义：将抽象和实现解耦，使得两者可以独立地变化。 优点：抽象和实现分离,优秀的扩充能力,实现细节对客户透明 理解： 即把不变的特性留在Abstraction内,把可变的特性提取出来单独放入Implementor。 Abstraction通过引用Implementor来具有这部分可变特性,形成一个完整地事物抽象。 而Implementor通过继承来实现这部分特性的变化.而Abstraction通过继承来实现事物整体的变化。 角色： Abstraction抽象化角色：定义出该角色的行为,同时保存一个对实现化角色的引用,该角色一般是抽象类. Implementor实现化角色：它是接口或抽象类,定义角色必须的行为和属性. RefinedAbstraction修正抽象化角色：它引用实现化角色对抽象化角色进行修正. ConcreteImplementor具体实现化角色：它实现接口或抽象类定义的方法和属性. 使用场景： 不希望或不适用使用继承的场景 接口或抽象类不稳定的场景 重用性要求较高的场景 抽象化角色 public abstract class Abstraction { /** 对实现化角色的引用 */ private Implementor imp; /** * @Description 设置实现化角色 * @param imp 实现化角色 */ public Abstraction(Implementor imp) { this.imp = imp; } /** * @Description 自身行为和属性 */ public void request() { this.imp.doSomething(); } public Implementor getImp() { return this.imp; } } 实现化角色 public interface Implementor { /** * @Description 业务逻辑 */ void doSomething(); /** * @Description 业务逻辑 */ void doAnything(); } 修正抽象化角色 public class RefinedAbstraction extends Abstraction { /** * @Description 覆写构造函数 */ public RefinedAbstraction(Implementor imp) { super(imp); } /** * @Description 修正父类行为 */ @Override public void request() { super.request(); super.getImp().doAnything(); } } 具体实现化角色 public class ConcreteImplementor1 implements Implementor { /** * @Description 业务逻辑 */ @Override public void doSomething() { System.out.println(\"ConcreteImplementor1----doSomething\"); } /** * @Description 业务逻辑 */ @Override public void doAnything() { System.out.println(\"ConcreteImplementor1----doAnything\"); } } "},"DesignPatterns/builder.html":{"url":"DesignPatterns/builder.html","title":"建造者模式(builder)","keywords":"","body":"建造者模式(builder) 定义:讲一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示. 优点:封装性,容易扩展,便于控制细节风险 注意:建造者模式关注的是顺序,而工厂方法模式更多关注创建. 角色: 产品类:通常实现了模板方法模式. 抽象建造者:规范产品的组件,即规范产品制造的流程结构. 具体建造者:实现抽象类定义的方法,并且返回一组建好的对象. 导演类:负责安排已有模块的顺序,并告知建造类开始建造. 使用场景: 1.相同方法,不同执行顺序,产生不同的事件结果时. 2.多个部件或零件都可以装配到一个对象中,但是产生的运行结果又不相同时,可以使用该类. 3.产品类非常复杂,或者产品类中的调用顺序不同产生了不同的效能,这个时候使用建造者模式非常合适. 实例 产品抽象类 public abstract class CarModel{ private ArrayList sequence = new ArrayList(); protected abstract void start(); //启动 protected abstract void stop(); //停车 protected abstract void alarm(); //喇叭 protected abstract void engineBoom(); //引擎 final public void run(){ for(String tag:sequence){ switch(tag.toLowerCase()){ case \"start\" : this.start(); break; case \"stop\" : this.stop(); break; case \"alarm\" : this.alarm(); break; case \"engineBoom\" : this.engineBoom(); break; } } } final public void setSequence(ArrayList sequence){ this.sequence = sequence; } } 产品实现类 public class BenzModel extends CarModel{ protected void start(){ system.out.println(\"奔驰启动\"); } protected void stop(){ system.out.println(\"奔驰停止\"); } protected void alarm(){ system.out.println(\"奔驰喇叭\"); } protected void engineBoom(){ system.out.println(\"奔驰引擎\"); } } public class BMWModel extends CarModel{ protected void start(){ system.out.println(\"宝马启动\"); } protected void stop(){ system.out.println(\"宝马停止\"); } protected void alarm(){ system.out.println(\"宝马喇叭\"); } protected void engineBoom(){ system.out.println(\"宝马引擎\"); } } 抽象建造者 public abstract class CarBuilder{ public abstract void setSequence(ArrayList sequence); public abstract CarModel getCarModel(); } 具体建造者 public BenzBuilder extends CarBuilder{ private BenzModel benz= new BenzModel(); public CarModel getCarModel(){ return this.benz; } public void setSequence(ArrayList sequence){ benz.setSequence(sequence); } } public BMWBuilder extends CarBuilder{ private BMWModel bmw= new BMWModel(); public CarModel getCarModel(){ return this.bmw; } public void setSequence(ArrayList sequence){ this.bmw.setSequence(sequence); } } 导演类 public class Director{ private ArrayList sequence = new ArrayList(); private BenzBuilder benzBuilder = new BenzBuilder(); private BMWBuilder bmwBuilder = new BMWBuilder(); public BenzModel getABenzModel(){ this.sequence.clear(); this.sequence.add(\"start\"); this.sequence.add(\"stop\"); this.benzBuilder.setSequence(sequence); return (BenzModel)this.benzBuilder.getCarModel(); } public BenzModel getBBenzModel(){ this.sequence.clear(); this.sequence.add(\"engineBoom\"); this.sequence.add(\"start\"); this.sequence.add(\"stop\"); this.benzBuilder.setSequence(sequence); return (BenzModel)this.benzBuilder.getCarModel(); } public BMWModel getCBMWModel(){ this.sequence.clear(); this.sequence.add(\"alarm\"); this.sequence.add(\"start\"); this.sequence.add(\"stop\"); this.bmwBuilder.setSequence(sequence); return (BMWModel)this.bmwBuilder.getCarModel(); } public BMWModel getDBMWModel(){ this.sequence.clear(); this.sequence.add(\"start\"); this.bmwBuilder.setSequence(sequence); return (BMWModel)this.bmwBuilder.getCarModel(); } } "},"DesignPatterns/chain.html":{"url":"DesignPatterns/chain.html","title":"责任链模式(Chain of Responsibility)","keywords":"","body":"责任链模式(Chain of Responsibility) 定义：使多个对象都有机会处理请求,从而避免请求的发送者和接受者之间的耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,直到有对象处理它为止. 优点：把请求和处理分开. 缺点：性能慢,调试不方便. 抽象处理者 public abstract class AbstractHandler { /** 存放下一个处理者 */ private AbstractHandler nextHandler; /** * @Description 对请求作出处理 */ public final Response handleMessage(Request request) { Response response = null; if (this.getHandlerLevel().equals(request.getRequestLevel())) { response = this.echo(request); } else { if (this.nextHandler != null) { response = this.nextHandler.handleMessage(request); } else { // 当没有适当的处理者,业务自行处理 } } return response; } /** * @Description 设置下一个处理者 */ public void setNext(AbstractHandler handler) { this.nextHandler = handler; } /** * @Description 获取处理者的处等级 * @return */ protected abstract Level getHandlerLevel(); protected abstract Response echo(Request request); } "},"DesignPatterns/command.html":{"url":"DesignPatterns/command.html","title":"命令模式(command)","keywords":"","body":"命令模式(command) 定义:将一个请求封装成一个对象,从而让你使用不同的请求把客户端参数化,对请求排队或者记录请求日志,可以提供命令的撤销和恢复功能. 优点:类间接耦合,可扩展性,命令模式结合其他模式会更优秀. 缺点:命令类会很膨胀. 角色: 接受者角色：干活的角色,命令传递到这里应该被执行的. 命令角色：需要执行的所有命令都在这里声明 调用者角色：接收到命令,并执行命令. 实现: 抽象命令类 public abstract class AbstractCommand { /** 定义一个子类全局共享变量 */ protected final AbstractReceiver receiver; /** * @Description 实现类必须传入一个接收者 */ public AbstractCommand(AbstractReceiver receiver) { this.receiver = receiver; } /** * @Description 每个命令类都必须有一个执行命令的方法 */ public abstract void execute(); } 具体命令类 public class ConcreteCommand1 extends AbstractCommand { /** * @Description 设置默认接收者 */ public ConcreteCommand1() { super(new ConcreteReceiver1()); } /** * @Description 构造函数传递接收者 * @param receiver 接收者对象 */ public ConcreteCommand1(AbstractReceiver receiver) { super(receiver); } /** * @Description 每个命令类必须实现执行命令方法 */ @Override public void execute() { // 业务逻辑 this.receiver.doSomething(); } } 接收者 public class ConcreteReceiver1 extends AbstractReceiver { /** * @Description 每个接收者都必须完成的业务逻辑 */ @Override public void doSomething() { // 业务逻辑处理 System.out.println(\"receiver1 is doing Something\"); } } 调用者 public class Invoker { /** 需要执行的命令类 */ private AbstractCommand command; /** * @Description 设置命令类 */ public void setCommand(AbstractCommand command) { this.command = command; } /** * @Description 执行命令 */ public void action() { this.command.execute(); } } "},"DesignPatterns/composite.html":{"url":"DesignPatterns/composite.html","title":"组合模式(composite)","keywords":"","body":"组合模式(composite) 定义：将对象组合成树形结构以表示\"部分-整体\"的层次结构,使得用户对单个对象和组合对象的使用具有一致性. 优点：高层模块调用简单,节点自由增加 缺点：与依赖倒置原则冲突 角色 Component抽象构件角色：参加组合对象的共有方法和属性. Leaf叶子构件：其下再也没有其他分支,遍历的最小单元 Composite树枝构件：组合树枝节点和叶子节点形成一个树形结构. 使用场景：只要是树形结构,体现局部和整体的关系的时候,这种关系还可能比较深的时候考虑组合模式 安全模式：把树枝节点和树叶节点彻底分开了,胜在安全. 抽象构件 public abstract class AbstractComponent { /** 父节点 */ private AbstractComponent parent = null; /** * @Description 个体和整体都具有的共享 */ public void doSomething() { // 编写业务逻辑 } public AbstractComponent getParent() { return parent; } public void setParent(AbstractComponent parent) { this.parent = parent; } } 树枝构件 public class Composite extends AbstractComponent { /** 构件容器 */ private ArrayList componentList = new ArrayList(); /** * @Description 增加一个构件 */ public void add(AbstractComponent component) { component.setParent(this); this.componentList.add(component); } /** * @Description 删除一个构件 */ public void remove(AbstractComponent component) { this.componentList.remove(component); } /** * @Description 获取分支下的所有构件 */ public ArrayList getChildren() { return this.componentList; } } 树叶构件 public class Leaf extends AbstractComponent { } 透明模式：遵循了依赖倒转原则,方便系统进行扩展,但是不太安全. 实现：把树枝构件的方法抽象给抽象构件,树枝构件和树叶构件都实现抽象构件. "},"DesignPatterns/decorator.html":{"url":"DesignPatterns/decorator.html","title":"装饰模式(decorator)","keywords":"","body":"装饰模式(decorator) 定义：动态的给一个对象添加一些额外的职责.就增加功能来说,装饰模式相比生成子类更为灵活. 优点：装饰类和被装饰类互相不会耦合,是继承关系的替代,动态扩展实现类. 缺点：多层装饰增加了系统的复杂度. 角色: 抽象构件：是一个接口或者抽象类,定义需要被装饰的对象. 具体构件：抽象构件的实现. 装饰角色：一般是抽象类,实现抽象构件,并属性有个private的抽象构件变量 具体装饰对象：装饰角色的实现 抽象装饰类 public abstract class AbstractDecorator extends AbstractComponent { /** 被修饰者 */ private AbstractComponent component = null; /** * @Description 通过构造函数传递被修饰者 * @param component */ public AbstractDecorator(AbstractComponent component) { this.component = component; } /** * @Description 委托被修饰者执行 */ @Override public void operate() { this.component.operate(); } } 具体装饰类 public class ConcreteDecorator1 extends AbstractDecorator { /** * @Description 定义被修饰者 */ public ConcreteDecorator1(AbstractComponent component) { super(component); } private void method1() { System.out.println(\"method1 修饰\"); } /** * @Description 重写父类方法 */ @Override public void operate() { this.method1(); super.operate(); } } "},"Typora.html":{"url":"Typora.html","title":"Typora的使用","keywords":"","body":"Typora的使用 文本修饰 Ctrl+1 ~ 6 ：一级~六级标题。（#-#######） Ctrl+=：提升标题级别。 Ctrl+-：降低标题级别。 Ctrl+0：普通文本。 Ctrl+I：斜体，效果演示。（一对*） Ctrl+B：粗体，效果演示。（一对**） Ctrl+U：下划线，效果演示。（） Shift+Alt+5：删除线，效果演示。（一对~~） Highlight：高亮，==效果演示==。（一对==） Ctrl+Shift+Q：引用。（前面加上>,个数随层级增加） 表格 Ctrl+T：插入表格。（用|分隔单元格，用---分隔表头，用:表示对齐方式） |左对齐|居中 |右对齐| |:--- |:---:|---: | | | | | 列表 Ctrl+Shift+[：有序列表。（数字接英文句号，如1.） Ctrl+Shift+]：无序列表。（*或+或-） Ctrl+[：减少列表缩进。 Ctrl+]：增加列表缩进。 代码块 Ctrl+Shift+` ：行内代码块。（用一个或两个`包起来） Ctrl+Shift+K：代码区块。（用三个`包起来） 图表（代码区块写入相应的语言即可） 流程图（flow） 时序图（sequence） 甘特图（mermaid） 图片、超链接、脚注 Ctrl+Shift+I：插入图片。（![图片名称](图片地址，本地或网络 \"悬浮名称\")） Ctrl+K：超链接，效果演示。（Ctrl+左击可以跳转到该超链接） [链接文本名称](带https://的URL地址 “链接悬浮名称”) [链接文本名称](#锚点id “链接悬浮名称”) //可以再标题后面加上锚点 ## 标题2{#title2} //另一种写法（图片也有类似的写法） [百度][2] [2]http://www.baidu.com \"baidu\" [百度][] [百度]http://www.baidu.com \"baidu\" Footnotes：脚注，效果演示。1 1. 脚注内容 ↩ [^标识] [^标识]：脚注内容 其他 Superscript：上标，效果演示X^2^。（一对^） Subscript：下标，效果演示H~2~O。（一对~） Ctrl+Shift+M：行间数学区块，内填LaTeX参考。（一对$$） Inline Math：行内数学公式，内填LaTeX参考。（一对$） 参考. https://blog.csdn.net/jyfu2_12/article/details/79207643 ↩ Todo List：复选框，只能放在行首，不能省略空格。（- [ ]或者- [X]） [ ] 效果演示 [x] 效果演示 Horizontal Line：分割线。（---或者***） emoji：表情图标，如 :happy:（:emoji名称:） Table of Contents：生成内容目录。（[toc]） 软件操作快捷键 Ctrl+Shift+V：纯文本粘贴。 Ctrl+L：选中当前行。 Ctrl+D：选中当前词。 Ctrl+/：源代码模式。 Ctrl+Shift+L：显示/隐藏侧边栏。 Ctrl+Shift+1：大纲视图。 Ctrl+Shift+3：文件树视图。 F8：专注模式，除当前行都变暗。 F9：打字机模式，当前行始终处于屏幕中央。 "},"PreviewImg.html":{"url":"PreviewImg.html","title":"图片预览总结","keywords":"","body":"图片上传预览功能的实现与坑 实现方法 FileReader 原理：把file对象转换成一段data:base64的字符串，在src插入该字符串。 上传图片预览 document.getElementById('file').onchange = function(){ var file = this.files[0]; var reader = new FileReader(); // 监听reader对象的的onload事件，当图片加载完成时，把base64编码賦值给预览图片 reader.onload = function(event){ document.getElementById('img').src = event.target.result; } // 调用reader.readAsDataURL()方法，把图片转成base64 reader.readAsDataURL(file); } URL.createObjectURL 原理：创建一个 File 对象或 Blob 对象的内存URL。该URL 的生命周期和创建它的窗口中的 document 绑定。 document.getElementById('file').onchange = function(){ var file = this.files[0]; document.getElementById('img').src = URL.createObjectURL(file); } 以上两种方法也都适用于视频，区别在于需要传值到标签的src。 IE8兼容 但是！但是！但是！以上方法IE8都不支持，所以只能用ajax把图片上传到服务器，然后返回图片在服务器上的地址，把地址塞到src里去。然而接下来还有如下的这些坑： 由于ie8不支持label的for属性，考虑使用js触发input[file]控件。 但是IE下 input[file]表单控件，不能用js控制打开文件选择器，必须要手动点击才可以，否则提交表单时会报 “拒绝访问”。无奈考虑把input[file]变透明，遮住设计好的按钮。 ie8不支持opacity属性，用滤镜实现 filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0); 应用实例 身份证图片上传预览 上传图片预览 .imglabel{ width: 200px; height: 120px; line-height: 120px; text-align: center; border: 1px solid #ddd; border-radius: 3px; background-color: #f8f8f8; cursor: pointer; display: block; margin: 8px; } .imgdiv{ position: relative; width: 200px; height: 120px; border: 1px solid #ddd; border-radius: 3px; display: none; margin: 8px; } .imgdiv img{ width: 100%; height: 100%; } .imgdiv span{ position: absolute; left: 0; bottom: 0; width: 100%; color: #fff; background-color: #000; opacity: 0.5; } .imgdiv label{ display: inline-block; width: 48%; text-align: center; cursor: pointer; } + 添加正面（人像面） 重新选择 删除 + 添加反面（非人像面） 重新选择 删除 // 删除方法，清空并触发onchange function cancel(id) { document.getElementById(id).value = \"\"; document.getElementById(id).onchange(); } // 切换隐藏方法 function triggerImg(index){ if(document.getElementById('file'+index).value == \"\"){ document.getElementById('imgdiv'+index).style=\"display:none;\" document.getElementById('imglabel'+index).style=\"display:block;\" } else { document.getElementById('imgdiv'+index).style=\"display:block;\" document.getElementById('imglabel'+index).style=\"display:none;\" } } //URL.createObjectURL方式实现 document.getElementById('file1').onchange = function(){ triggerImg(\"1\"); if(this.value != \"\"){ var file = this.files[0]; document.getElementById('img1').src = URL.createObjectURL(file); } } // FileReader方式实现 document.getElementById('file2').onchange = function(){ triggerImg(\"2\"); if(this.value != \"\"){ var file = this.files[0]; var reader = new FileReader(); // 监听reader对象的的onload事件，当图片加载完成时，把base64编码賦值给预览图片 reader.onload = function(event){ document.getElementById('img2').src = event.target.result; } // 调用reader.readAsDataURL()方法，把图片转成base64 reader.readAsDataURL(file); } } "},"snipaste.html":{"url":"snipaste.html","title":"Snipaste的使用","keywords":"","body":"Snipaste的使用 截图 F1：截图：就是一般意义上的截图。 Ctrl+F1：截屏并自动复制：选定区域后直接完成截图并复制到剪切板。 Shift+F1：自定义截图：设置截图的配置参数。 Esc/右键：退出截图。 Ctrl+C/Enter/双击截屏区域：保存到剪切板 Ctrl+S：保存到文件。 Ctrl+T：保存到贴图。 截图记录：F1进入截图，按，或。 Ctrl+Shift+S：快速保存，直接存入快速保存路径。 ` 显示/隐藏鼠标 拖动时不要松开鼠标，按下空格键即进入移动选区模式 贴图操作 F3：贴图：在截图完成确认之前，按下F3把截图变成一张贴图显示在桌面上。也可以复制一段文本到剪切板，然后按下F3把这段文本变成贴图展现在桌面上。 Shift+F3：隐藏/显示所有贴图。 Ctrl+F3：切换到另一贴图组。 鼠标滚轮或+/-：贴图缩放。 Ctrl+鼠标滚轮或+/-：贴图透明度调整。 Esc/鼠标左键双击：关闭贴图，可以通过再次按下F3恢复贴图。 Shit+Esc：销毁贴图，不可恢复。 鼠标中键单击：重置贴图大小后透明度。 Shift+鼠标左键双击：快速缩略贴图。 Crtl + Shift + C/Shift+鼠标右击： 选中在由文本转换成的贴图，按下快捷键可以复制文本内容。 F4：鼠标穿透开关：即贴图锁定在桌面，不能移动、缩小放大操作，但鼠标可以选中贴图下的文字（如贴图下有文字的话）。 Ctrl+S：贴图另存为，需选择路径。 Alt：唤出放大镜，按C可以取色。 12：旋转贴图。 34：水平/垂直翻转。 鼠标左键+WASD：微调截取区域，鼠标按住中间拖动，WASD是移动整体，鼠标按住一条边，WASD是控制边界。 Shift+拖动：可以自动对齐各个贴图的边缘。 标注 空格键：选中贴图时按下可以/关闭打开标注工具栏。 鼠标右键：所有标注都可以通过鼠标右键来结束标注。 "}}